# 📖スッキリわかるSQL入門

# 第0章 データベースを学ぶにあたって
私たちが日常的に利用するインターネット検索やSNSはもちろん、物流や金融といった社会基盤の多くが、情報システムに支えられています。その中枢で必ず使われているのが「データベース」です。

本書では、現代社会と情報システムに欠かせない存在であるデータベースについて学んでいきますが、まずはその全体像とロードマップを眺めてみましょう。

<details><summary>0.1 データベースを学ぼう</summary>
        
### 0.1.1 データベースとSQL  
- ATMの利用、チケットの予約、インターネットショッピング、オンラインゲームなどの仕組みの中枢で活躍しているのがデータベースです。
  データベースに格納されている情報は、専用の操作言語SQLを利用して、外部からアクセスして検索したり書き換えたりします。
  SQLの上達の近道は、実際に手を動かしてたくさんのSQL文を書き、実行してみることです。</details></details>

# 第1章 はじめてのSQL
第1章では、データベースの概要を紹介します。読み進めながら、頭の中に大まかなイメージを描いてみてください。
    
<details><summary>1.1 データベースとは</summary>

### 1.1.1 データベースってなんだろう
    
   狭い意味でデータベース(database)とは、検索や書き換え、分析などのデータ管理を目的として様々な情報を蓄積したものを指します。特にITの世界では、電子的な媒体にファイルなどの形式で保存・蓄積したものを言います。
   現在、分野を問わず広く用いられているのが複数の表の形式でデータを管理するリレーショナルデータベース(RDB:Relational Database)です。

- RDBの基本構造
- RDBには複数の表が入っており、ここの表をテーブル(table)という。
- 個々のテーブルには名前が付いており、その名前をテーブル名という。
- テーブルは列(column：カラム)と行(low：ロウ)で構成される。
- 1つの行が1件のデータに対応し、列はそのデータの要素に対応する。

 ※列のことをカラムやフィールドと呼ぶこともある。


たとえば、「社員」という名前が付いているテーブルには、社員の情報が格納されています。このテーブルには社員番号や名前といった社員に関する要素が列として存在し、社員1人ひとりに関する情報が一行ずつ格納されています。

| 社員番号 | 氏名 | 年齢 | 出身地 |
| --- | --- | --- | --- |
| 0101 | 菅原拓真 | 31 | 福岡県 |
| 0104 | 大江岳人 | 30 | 京都府 |
| 0108 | 立花いずみ | 29 | 千葉県 |
| 0292 | 朝香あゆみ | 24 | 北海道 |
| 0293 | 湊雄輔 | 22 | 千葉県 |

RDBとは、このような表形式の情報の集積であって、その実態は上図のような構造のデータを含んだただのファイルです。
            
そして、私たちは、SQLというデータベースを操作する専用の言語で書かれた命令を使って、これらのテーブルから特定の列や行のデータを自由に取り出したり、書き換えたりすることができます。
            
### 1.1.2 データベース管理システム(DBMS)
            
私たちがSQLを送る相手は、データベースファイルではなく、データベース管理システム(DBMS:Database Management System)と呼ばれるプログラムです。DBMSはコンピュータ内で常に稼働してSQLを待ち受けており、届いたSQLの内容に従って、データベースファイルの内容を検索したり書き換えたりする処理を実行してくれます。
            
ITの世界では、「データベースファイルとそれを管理するDBMS全体」と単にデータベースと表現することも多いので注意すること。
            
### 1.1.4 データベースにSQLを送るには
            
通常、DBMSに対しては、ネットワーク経由でSQLに送ります。この送信は各データベースが定める特有の手順や形式に従う必要があるため、たとえばメールソフトなどを使ってSQLを送ることはできません。</details>


<details><summary>1.2 はじめてのSQL</summary>

### 1.2.2 検索してみよう

- テーブル名および列名
    
    テーブルや列の名付け方は、会社やプロジェクトによってルールが定められていることがほとんどです。たいていは、次の3つの方法のいずれかでしょう。
    
    - 日本語　　(例)家計簿、費目
    - ローマ字　(例)KAKEIBO、HIMOKU
    - 英語　　　(例)HOUSEKIIPING_BOOK、EXPENSE_ITEM
    
    いずれの方法にも長短があります。ネーミングルールが定められていない場合、判読性や利用するDBMSの動作保証などを勘案して名前を付けてください。
    
    なお、実際の開発や設計では、DBMSの動作安定性を優先して日本語名を避けることも多くあります。
    
- リスト1-2 全ての列を検索する
    
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-03 | 食費 | コーヒーを購入 | 0 | 380 |
    | 2018-02-10 | 給料 | 1月の給料 | 280000 | 0 |
    | 2018-02-11 | 教養娯楽費 | 書籍を購入 | 0 | 2800 |
    | 2018-02-14 | 交際費 | 同期会の会費 | 0 | 5000 |
    | 2018-02-18 | 水道光熱費 | 1月の電気代 | 0 | 7560 |
    
    SELECTには目的とする列名を、FROMには検索したいテーブル名を記述します。
    
- リスト1-3 すべての列を取得する(簡略記法)
    
    列の指定に「＊」を記述すると、「すべての列」を取得します。


### 1.2.3 条件付きの検索
    
- WHEREは行を指定する。
    
### 1.2.4 データを追加してみよう
    
- INSERT INTO(インサートイントゥ)で追加先のテーブルを、VALUES(バリューズ)で追加するデータを指定する。
    
### 1.2.5 データを更新してみよう
    
- UPDATEでデータを修正する。
    
### 1.2.6 データを削除してみよう
    
- DELETEでデータを削除する。
    
    - 3命令の動作
        - SELECT文：ある条件を満たす行を探す→その行の内容を取得する
        - UPDATE文：ある条件を満たす行を探す→その行の内容を書き換える
        - DELETE文：ある条件を満たす行を探す→その行を削除する
        
        これらの3つの命令は、「目的の行に対する処理内容」それぞれ異なるものの、「目的のデータを探し当てるまで」は全く同じ動作です。目的の行を探すためのWHEREは、全く同じ書き方をすることができるのです。</details>


<details><summary>1.3 この章のまとめ</summary>

### 1.3.1 この章で学習した内容
データベースの概要

- データベースとは、管理や分析を目的としてさまざまなデータを蓄積したものを指す。
- ITにおけるデータベースの実態は、通常、ファイルである。
- データベースはデータベース管理システム(DBMS:Database Management System)によって管理される。
- 現在、さまざまなDBMSがソフトウェア製品として公開されている。
- 複数のテーブルの形式でデータを管理するものをリレーショナルデータベースという。
- テーブルには名前が付いており、行(low)と列(column)から構成される。

SQLの概要

- SQLは、データベースやデータを操作するための専門言語である。
- SQLで書かれた命令(SQL文)をDBMSに送信することで、データの検索・追加・更新・削除などを行うことができる。
- SQLを送信するには、ドライバを用いたプログラムを新しく開発するか、既存の送信プログラムを利用する。
- SQLの文法は利用するDBMS製品によって少しずつ異なるが、基本的な部分は同じである。</details>

# 第2章 基本文法と4大命令

SQL文を書くための基本的なルールについて紹介します。

そしてデータを操作する4つの命令、SELECT、UPDATE、DELETE、INSERTについて全体を俯瞰したうえで、ここに詳しくみていきましょう。

<details><summary>2.1 SQLの基本ルール</summary>

### 2.1.1 記述形式に関するルール
- SQLに共通する基本ルール(1)
    - 文の途中に改行を入れることができる。
    - 行の先頭や行の途中に半角の空白を入れることができる。

    SQLは文の途中で改行することが許されています。また、行の先頭や行の途中に空白を入れることも可能です。これらのルールを活用して、読みやすく整形されたSQL文の記述を心がけましょう。

- 一行で記述されたSELECT文

    ```sql
    SELECT 費目, 出金額 FROM 家計簿 WHERE 出金額 > 3000
    ```

- 整形されたSELECT文

    ```sql
    SELECT 費目, 出金額
     FROM 家計簿
     WHERE 出金額 > 3000
    ```

- 末尾のセミコロンで文の終了を表す
    
    文中に改行を含むことができるSQLの特性は、わかりやすいSQL文を書くためにはとても重宝します。一方で、複数のSQL文を続けて記述する場合などには、どこの文に区切りがあるのかが分かりにくいというデメリットがあります。そこで、1つのSQL文の末尾にセミコロン記号(;)を付けることにより、文の区切りを明示することがあります。
    
    ```sql
    SELECT *
    FROM 家計簿; # ここまででSELECT文終了
    DELETE FROM 家計簿;# ここまででDELETE文終了
    ```

    本書では、複数のSQL文を1つのリストとして掲載する場合のみ、セミコロンを付けています。


### 2.1.2 コメントに関する2つのルール
    
コメントの記述方法には、次の2つのルールがあります

- SQLに共通する基本ルール(2)
    - ハイフン2つ(- -)から行末まではコメントになり、無視される。
    - /* から*/まではコメントになり、無視される。

    コメントを記述したSQL

    ```sql
    /* 入出金表示用SQL バージョン0.1
       作成者:朝香あゆみ 作成日:2018-02-01 */
    SELECT 入金額, 出金額  -- 金額関連の列のみ表示
      FROM 家計簿
    ```

    改行や空白による生計とコメントを併せて活用することにより、後で見た時や、チームで共有した時にわかりやすいSQL文の記述が可能になります。


### 2.1.3 予約語に関するルール
    
SQL文に記述できる語句についてのルール。

- SQLに共通する基本ルール(3)
    - SELECTやWHEREなどの命令に使う単語は、SQLとして特別な意味を持つ「予約語」である。
    - 予約語を記述する際は、大文字と小文字の区別はない。
    - テーブル名や列名に予約語を利用することはできない。
    
    SELECTやWHEREなどの一部の単語は、SQLの機能として特別な意味を持つため、列名などに使うことはできません。これを予約語(keyword)といいます。
    
    SQLの文中では、予約語を大文字と小文字のどちらで書いても同じ意味になります。たとえば、
    
    ```sql
    select * FROM 家計簿
    ```
    
    でも
    
    ```sql
    Select * froM 家計簿
    ```
    
    でも同じように動作しますが、できるだけ判別しやすい書き方にすることをお薦めします。すでに会社やプロジェクトでルールが定められていればそれに従うと良いでしょう。
    
    なお、列名やテーブル名について、大文字と小文字を区別するかどうかは、DBMS製品や動作するOS、設定などによって異なります。</details>


<details><summary>2.2 データ型とリテラル</summary>

### 2.2.1 リテラルの種類

-
    
    ```sql
    INSERT INTO 家計簿
    		 VALUES ('2018-02-25', '居住費', '3月の家賃', 0, 85000)
    ```
    
    2行目には家計簿テーブルの各列に格納する5つのデータが記述されています。SQL文の中に書き込まれたデータそのものを特にリテラル(literal)といいます。
    
- リテラルの記述に関するルール
    - 「'」で括らずに記述されたリテラルは、数値情報として扱われる。
    - 「’」で括られたリテラルは、基本的に文字列情報として扱われる。
    - 「'」で括られ、’2018-02-25’のような一定の形式で記述されたリテラルは、日付情報として扱われる。
        
        たとえば、「123」と「'123'」では意味が異なります。前者は123(ひゃくにじゅうさん)という数量を表す数値データ、後者は123(いち・に・さん)という3つの文字の並びを表す文字列データです。


### 2.2.2 列とデータ型

数値のデータを誤って文字列情報として指定してデータ形式で格納されないように、データベースには安全装置が備わっています。DBMSは、数値ではないとして処理を中断するか、受け取った文字列を強制的に数値に変換して格納しようとします。

データベースの中には複数のテーブルがあり、テーブルは行と列から成り立っています。それぞれの列には名前がついていますが、それに加えて、列ごとに格納できるデータの種類を表すデータ型(data type)を定めることになっています。
| データ型の設定 | DATE(日付) | VARCHAR(20)(可変長文字列、最大20バイト) | VARCHAR(80)(可変超文字列、最大80バイト) | INTEGER(整数) | INTEGER(整数) |
| --- | --- | --- | --- | --- | --- |
| 列名 | 日付 | 費目 | メモ | 入金額 | 出金額 |

たとえば、入金額と出金額の列にはあらかじめ「INTEGER」という数値のデータがが設定されているため、格納できるデータは数値のみとなっています。

代表的なデータ型
| データ種別 | 区分 | 代表的なデータ型名 |
| --- | --- | --- |
| 数値 | 整数値 | INTEGER型 |
| 数値 | 小数 | DECIMAL型、REAL型 |
| 文字列 | 固定長 | CHAR型 |
| 文字列 | 可変長 | VARCHAR型 |
| 日付と時刻 | — | DATETIME型、DATE型、TIME型 |

利用可能なデータ型はDBMS製品によって異なりますが、数値型、文字列型、日付型は基本的に必ず用意されています。特に、INTEGER型、CHAR型、VARCHAR型は、多くのDBMS製品で共通して利用することができます。

- データ型
    - テーブルの各列には、データ型が指定されている。
    - 列には、データ型で指定された種類の情報しか格納することはできない。
    - 利用可能なデータ型は、DBMS製品によって異なる。


### 2.2.3 固定長と可変長

CHAR型は固定長の文字列データを扱うデータ型です。たとえば、CHAR(10)と指定されている列では、あらかじめ10バイトの領域が確保されており、格納するデータは常に10バイトになります。格納しようとする文字列が10バイトに満たない場合は、文字列の右側に空白が追加され、10バイトぴったりに調整されてから格納されます。

一方、VARCHAR型を指定された列は、格納する文字列の長さを勝手に調整することはありません。たとえば、VARCHAR(10)と指定された列では、3バイトや7バイトの文字列が入力された場合、それに合わせた領域が確保されるため、そのままの長さで格納することが可能です。ただし、最大長として10が指定してあるため、11バイトの文字列は格納できません。

- CHAR型は郵便番号や社員番号など、格納するデータの桁数が決まっているもの。
- VARCHAR型は氏名や書籍名など、格納するデータの桁数が変動する可能性のあるもの。

に向いたデータ型と言えます。

- DBMSに依存しやすい日付の取り扱い
    
    日付の取り扱いに関しては、各DBMS製品間での違いが比較的大きい点に注意が必要です。主に、次のような点が異なっています。
    
    - 日付リテラルとしてどのような記述を許すか
    - 日付に関するデータ型の名前や制度
    - 日付に関して利用できる命令(関数)の種類</details>


<details><summary>2.3 SQLの命令体系</summary>

### 2.3.1 4つの重要なSQL文

ほとんどのデータ操作は、SELECT、UPDATE、DELETE、INSERTのたった4つの命令で実現できてしまいます。これら4つのSQL命令は、DML(Data Manipulation Language)と総称されています。

- SQLの言語体系
    - SQLでデータ処理を行うには、命令をたくさん覚える必要はない。
    - 4大命令だけで、ほとんどの処理を実現できる。
    
    4つの命令にさまざまな修飾語のようなものを付加することで非常な複雑なデータ操作を実現できることが、SQLという言語の特徴です。
    
    ```sql
    シンプルな命令→検索をお願いします。
    豊富な修飾語→「日付」と「出金額」だけでいい。ただ、今年の1月分だけが欲しくて。
    あと、日付が新しい順に並べ替えてくれる？
    
    --SQLだと
    SELECT 日付, 出金額
      FROM ...
     WHERE ...
    ORDER BY ...
    ```
    
- 2.3.2 4大命令の全体像を俯瞰する
    
    命令の数は少なくてシンプルだが、複雑に修飾できるというSQLの特徴が混乱させることも少なくありません。しかし、4つの命令の文法をスッキリとマスターするコツが3つあります。
    
    - 4大命令をスッキリと学ぶコツ(1)
        
        4大命令の構造と修飾語の全体像をしっかり把握する。
        
        | 命令 | 各命令で固有の部分 | 対象行の絞り込み | 検索結果の加工 |
        | --- | --- | --- | --- |
        | SELECT | 列名•••FROM テーブル名 | WHERE 〜 | その他修飾 |
        | UPDATE | テーブル名 SET 列名 = 値••• | WHERE 〜 |  |
        | DELETE | FROM テーブル名 | WHERE 〜 |  |
        | INSERT | INTO テーブル名 (列名•••) VALUES (値•••) |  |  |
</details>


<details><summary>2.4 SELECT文—データの検索</summary>


### 2.4.1 SELECT文の基本構文
    
データベースとデータのやり取りをするにあたって、最も頻繁に使われるSQLがSELECT文です。テーブルから目的のデータを指定して取得することがその役割です。

SELECT文の基本構文

```sql
SELECT 列名••• # SELECT:取得しなさい　列名:この列のデータを
  FROM テーブル名 # FROM テーブル名:このテーブルから
(WHERE修飾)
(その他の修飾)
```

1行目のSELECTの後ろには、取得したい列の名前をカンマで区切って記述します。また「＊」アスタリスクを記述すれば、すべての列を指定することができます。

2行目はFROM句といい、データを取得するテーブルを指定するために必ず指定します。

以降、必要に応じて、WHEREによる修飾やその他の修飾を続けて記述します。


### 2.4.2 ASによる別名の定義
    
SELECT文における列名やテーブル名の指定では、それぞれの記述の後ろに「AS + 任意のキーワード」を付けることで、別名を定義することができます。
```sql
SELECT 費目 AS ITEM, 入金額 AS RECEIVE, 出金額 AS PAY
  FROM 家計簿 AS MONEYBOOK
 WHERE 費目 = '給料'
```

- **別名をつけるメリット**
    - 結果表における列のタイトルを任意のものに変更できる。
    - わかりにくい列名や長い列名でも、わかりやすく短い別名をつけて利用することができる。
- **SELECT ＊ の濫用に御用心**
    
    *による全列検索は便利ですが、データベースの設計変更などで列が増えたり減ったりすると、検索結果も変化してしまいます。そのため、データベースを検索するアプリケーションプログラムでSELECT *を使用していた場合、予期しないバグの原因になることがあります。実際の開発では極力使用を避けるか、十分な検討が必要です。</details>


<details><summary>2.5 UPDATE文—データの更新</summary>

### 2.5.1 UPDATE文の基本構文
UPDATE文は、すでにテーブルに存在するデータを書き換えるための命令です。

- UPDATE文の基本構文
    
    ```sql
    UPDATE テーブル名 # UPDATE:更新しなさい テーブル名:このテーブルの情報を
       SET 列名1 = 値1, 列名2 = 値2••• # 列名1を値1のデータで 列名2を値2のデータで
    (WHERE修飾)
    ```
    
    1行目のUPDATEの直後には、更新したいデータの存在するテーブル名を記述します。また、2行目をSET句といい、更新したい列名と、その列に書き込むデータを記述します。
    
    1つの列を更新するUPDATE文
    
    ```sql
    UPDATE 家計簿
       SET 入金額 = 99999
    # 「どの行を書き換えるべきか」という指定がないため、入金額のすべての行が99999に書き換えられてしまう
    ```
    
    条件付きのUPDATE文
    
    ```sql
    UPDATE 家計簿
       SET 入金額 = 99999
     WHERE 日付 = '2018-02-03'
    ```
    
    すべての行の値を同一のものに書き換えることは実務上稀なので、「WHEREを伴わないUPDATE文」は、ほとんど使う機会がないでしょう。

- WHEREのないUPDATE文は全件更新！
    
    WHEREで対象行を指定しないと、UPDATE文はすべての行を書き換えてしまう。</details>


<details><summary>2.6 DELETE文—データの削除</summary>

### 2.6.1 DELETE文の基本構文
DELETE文は、すでにテーブルに存在する行を削除するための命令です。行をまるごと削除する機能であるため、特定の列だけを指定するようなことはできません。
- DELETE文の基本構文
    
    ```sql
    DELETE # DELETE:削除しなさい
      FROM テーブル名 # FROM テーブル名:このテーブルの情報を
    (WHERE 修飾)
    ```
    
    DELETE文では列名を指定する必要がないため、1行目のDELETEの後ろには何も記述しません。
    
    DELETE文の例
    
    ```sql
    DELETE FROM 家計簿
    # DELETE文においてもWHEREを付けなければすべての行が削除対象となってしまう
    ```
    
    WHEREを付けなければすべての行が削除対象となってしまいます。
    
    WHEREなしのDELETE文は「データを全消去する」指示にほかなりません。見かけたら、本能的に「実行をためらう」感覚を身に付けてください。
    
- WHEREのないDELETE命令は全件削除！
    
    WHEREで対象行を指定しないDELETE文は、全データを削除する。</details>


<details><summary>2.7 INSERT文—データの追加</summary>

### 2.7.1 INSERT文の基本構文
INSERT文は、テーブルに新しいデータを追加するための命令です。テーブルの行を指定するWHEREはありません。そのかわり、どこに、どのようなデータを追加するのかを指定する構造になっています。
- INSERT文の基本構文
    
    ```sql
    INSERT INTO テーブル名 # INSERT INTO:追加しなさい テーブル名:このテーブルに
                (列名1, 列名2, 列名3...) # この列に
         VALUES (値1, 値2, 値3...) # このデータを
    ```
    
    1行目のINSERTには、INTOのキーワードに続けて、データを追加するテーブル名を記述します。さらにテーブル名の後ろに、括弧で括ってデータを追加する列名を指定します。ただし、そのテーブルのすべての列に値を追加する場合には、2行目を丸ごと省略可能です。
    
    3行目はVALUES句といい、2行目に記述した列名に対応するデータの値を指定します。列名を丸ごと省略した場合は、テーブルのすべての列について、値を指定する必要があります。
    
    複数の列に追加するINSERT文
    
    ```sql
    INSERT INTO 家計簿
                (費目, 日付, 出金額)
         VALUES ('通信費', '2018-02-20', 6200) # 2行目に対応して記述
    ```
    
    費目、日付、出金額の3つの列に対して格納すべき値を指定していますが、メモや入金額の列には値は何も格納されません。2行目で明示的に列を指定する場合、その指定順序は自由です。ただし、3行目で列挙する値も列に対応するよう同じ順番にする必要があります。
    
    **※VALUES句の値を記述する時は、2行目に記述した列指定と、順序、数、データ画の全てをピッタリ対応させること。**
    
    一方、2行目の列指定を丸ごと省略した場合、3行目に記述する値は、テーブルにおける列の順序(「SELECT *」を実行して表示される順)と同じでなければなりません。
    
    全列に追加するINSERT文
    
    ```sql
    INSERT INTO 家計簿
         VALUES ('2018-02-20', '通信費', '携帯電話料金', 0, 6200)
    # 家計簿テーブルの列の順と同じく、必ず日付、費目、メモ、入金額、出金額の順番で指定
    ```
    </details>


<details><summary>2.8 4つのSQLをスッキリ学ぶコツ</summary>

### 2.8.1 4大命令を振り返って
FROM、WHERE、AS、INTO、VALUESなど、さまざまな予約語が登場したため混乱してしまうかもしれません。そこで、「4大命令をスッキリと学ぶコツ」について、残りの2つも含めて紹介しておきましょう。
- 4大命令をスッキリ学ぶ3つのコツ
    1. 4大命令の構造と修飾語の全体像をしっかり把握する。
    2. 4大命令の2通りの分類方法を理解する。
    3. 4大目異例に共通するテーブル指定を先に書く。
    
    コツ1.については2.3節で紹介したとおりです。4大命令を個別に学び終えた今、図2-4(p053)のSQL体系図をもう一度見直しておくと良いでしょう。混乱したらいつでもこの図に戻ってください。


### 2.8.2 4大命令の2通りの分類を理解する
SELECT、UPDATE、DELETE、INSERTの4つを2つのグループに分類するとしたら、どのように考えますか？多くの人が思いつくのが、データベースに対する処理方法の違いによる次のような分類です。
- 4大命令の分類方法(1) 検索系と更新系
    
    検索系：SELECT
    
    更新系：UPDATE、DELETE、INSERT
    
    検索系の命令はデータベースのデータを書き換えることはありません。また、SQLの実行結果は表の形になります。一方、更新系の命令はデータベースのデータを書き換えることが仕事です。実行結果は基本的に「成功か失敗か」であり、表などが返されることはありません。
    
    ここで注目して欲しいのが、図2-4の右端にある「検索結果の加工」に関する修飾についてです。たとえば、「ORDER BY」という修飾語を使うことで検索結果の表の行を並べ替えることができます。しかし、この修飾は検索結果表に対する処理を指示するものなので、当然、実行結果が表ではないUPDATEやDELETE、INSERTには指定できないのです。
    
- 4大命令の分類方法(2) 既存系と新規系
    
    既存系：SELECT、UPDATE、DELETE
    
    新規系：INSERT
    
    既存系の命令は、すでにデータベースに存在するデータに対して何らかの処理を行うためのものです。一方、新規系の命令は、まだデータベースに存在しないデータについての指定をします。
    
    図2-4の右から2番目にある「対象行の絞り込み」(WHERE句)に着目してください。検索や更新そして削除は既存のデータに対して行う処理であるため、その対象行を指定するための共通した文法としてWHERE句が利用可能です。一方、既存のデータに対する処理ではないINSERT文では、WHERE句の利用はできません。


### 2.8.3 テーブル指定を先に記述する
WHERE句より前の部分について、より踏み込んで整理してみましょう。
- 4大命令の全てに共通すること
    
    処理対象とするテーブル名を必ず指定する必要がある。
    
    | 命令 | 各命令で固有の部分 |
    | --- | --- |
    | SELECT | 列名… FROM 　テーブル名 |
    | UPDATE | 　　　　　　　テーブル名　SET　列名　＝　値… |
    | DELETE |  　　    FROM　テーブル名 |
    | INSERT | 　　　INTO　  テーブル名　(列名…)　VALUES　(値…) |
    
    そして、ぜひ実践してほしいのが、次のような順序でのSQL文の記述です。
    
- スッキリ書けるSQL
    1. まず、命令文(SELECTやINSERTなど)を記述する。
    2. 次に、テーブル指定の部分を記述する。
    3. テーブル指定より後ろの部分を記述する。
    4. テーブル指定より前の部分を記述する(SELECT文のみ)。
    
    特に1〜2を考え込まずにできるよう訓練しておくと、どの命令にどのキーワードを書けばよいのかが自然に身に付くため、スムーズにSQL文を書けるようになるでしょう。
    
    ※このあたりは、練習量がモノを言う。いろんなSQL文を繰り返し書いてみることが近道。→dokoQLでたくさん練習すること。</details>


<details><summary>2.9 この章のまとめ</summary>

### 2.9.1 この章で学習した内容
- SQLの基本ルール
    - 記述の途中で改行してもよい。
    - 予約語は大文字、小文字が区別されない。また、列名などに利用できない。
    - 文中にコメントを記述することができる。
- データ型とリテラル
    - SQL文の中に直接記述されるデータのことをリテラルという。
    - 数値、文字列、日付など、データの種類に応じてリテラルの記述方法は異なる。
    - テーブルの各列にはデータ型が指定されている。
    - 列に指定された種類のデータのみ、その列に格納することができる。
- SQLの体系
    - SELECT、UPDATE、DELETE、INSERTの4つの命令を利用する。
    - 各命令をどのように実行するかを指示する修飾が豊富に用意されており、組み合わせることによって多用な命令を実現できる。
    - 4つの命令は、操作内容から見た検索系と更新系、対象とするデータから見た既存系と新規系に分類することができる。
- 4大命令をスッキリ学ぶコツ
    - 4大命令の構造と修飾語の全体像をしっかり把握する。
    - 4大命令の2通りの分類方法を理解する。
    - 4大命令に共通するテーブル指定を先に書く。
### 2.9.2 この章でできるようになったこと
家計簿の内容を全て表示したい。
    
```sql
SELECT ＊ FROM 家計簿
```

2,000円より大きな金額を使った日を知りたい。

```sql
SELECT 日付 FROM 家計簿 WHERE 出金額 > 2000
```

3月1日に1,800円で映画を見た記録を追加したい。

```sql
INSERT INTO 家計簿
     VALUES ('2018-03-01', '娯楽費', '映画を見た’, 0, 1800)
```

3月1日の映画は1,500円の誤りだったので修正したい。

```sql
RPDATE 家計簿 SET 出金額 ＝ 1500 WHERE 日付 ＝ '2018-03-01'
```

全データを消去したい

```sql
DELETE FROM 家計簿
```

</details>

# 第3章 操作する行の絞り込み
SQLを用いて思いどおりにデータを操るには、「どの行を対象として、どのように操作するか」をDBMSに的確に伝えなければなりません。

特にWHERE句による対象行の指定は、SQL記述のキーポイントといえるでしょう。

この章では、WHERE句と絞り込み条件に関するさまざまな文法を学びます。

データベースにおけるより高度で複雑な処理が可能になり、SQLがいっそう楽しくなるでしょう。

<details><summary>3.1 WHERE句による絞り込み</summary>

### 3.1.1 WHERE句の大切さ
SQL文の中でWHEREを使うことで、処理対象となる行の絞り込みができます。WHEREキーワードから始まる一連の記述をWHERE句といいます。

SQLを学び始めて間もない頃は、WHERE句のことをSELECTやDELETEのちょっとした付属品のように思いがちです。

- SQLの言語としての特徴
    - 命令自体は単純で、数も少ない(主に使うものは4つ)。
    - しかし、さまざまな修飾語を付けることで、複雑な処理が可能になる。
    
    修飾語のうち最もよく使われるものが、WHERE句です。データを検索、更新、削除など多くの場合、WHERE句を用いて「テーブルのどの行を処理したいのか」を指定します。むしろ、WHERE句が伴わないSQL文を使うことの方が少ないでしょう。なぜなら、テーブル内のすべての行を更新したり削除したりする機会はあまりないからです。
    
    私たちはWHERE句を自由自在に使えてはじめて、データを自由自在に操作することができるのです。


### 3.1.2 WHERE句の基本
WHERE句に関して、3つの基本。
- WHERE句の基本
    1. 処理対象行の絞り込みに用いる→WHEREを指定しないと「すべての行」が処理対象になる。
    2. SELECT、UPDATE、DELETE分で使用可能→INSERT文では使用できない。
    3. WHEREの後ろには条件式を記述する→絞り込み条件に沿った「正しい条件式」を記述する。
    
    1と2については第2章で紹介しました。残る3については、WHERE句の基本構文をしっかり押さえることが大切です。
    
- WHERE句の基本構文
    
    ```sql
    WHERE 条件式
    ```
    
    ただし、WHEREの後ろにはどんな式でも書けるというわけではありません。たとえば、「出金額 < 10000」のような式を記述することができますが、「出金額 + 10000」のような計算式は書くことができません。WHEREの後ろに記述できるのは、条件式と呼ばれる式だけです。</details>


<details><summary>3.2 条件式</summary>

### 3.2.1 真と偽
条件式とは、その結果が必ず真(TRUE)か偽(FALSE)になる式のことです。私たちの日常生活における「YesとNo」のようなものと考えても差し支えありません。

たとえば、「出金額 < 10000」という式は、出金額という列に格納されている値が10000未満の場合は式の意味が正しいので真、10000以上の場合は式の意味が正しくないため偽と判定できます。

では、「出金額 + 10000」という式ではどうでしょうか。

出金額はふつう数字の値です。仮に5000だとすると、「出金額 + 10000」という式の結果も15000という数値になります。結果が数値や文字列、日付などになる式は、WHERE句に記述することはできません。

- WHERE句に書けるもの
    
    結果が必ず真(TRUE)または偽(FALSE)となる条件式


### 3.2.2 WHERE句のしくみ
DBMSがどのようにWHJERE句を処理するか、その仕組みを見てみましょう。

一円以上の出金のあった行をすべて削除するDELETE文

```sql
DELETE FROM 家計簿 WHERE 出金額 > 0
```

**1行ずつ順番に、条件に合うかどうかをチェックするために、「真か偽になる式」しか書いてはいけない。**

WHERE句を含むSQL文を受け取ったDBMSは、テーブル中のすべての行について条件式が真になるかをそれぞれ調べます。そして、真になった行についてのみ、SELECTやUPDATE、DELETEなどの処理を行うのです。</details>


<details><summary>3.3 さまざまな比較演算子</summary>

### 3.3.1 基本的な比較演算子
条件式は、「＝」(等号)や「<」(不等号)のような記号を含んだ式になることがほとんどです。これらの記号は比較演算子といい、その記号の左右にある値を比較して、記号の意味が正しければ真(TRUE)、正しくなければ偽(FALSE)に「化ける」役割を持っています。本書では、SQLの実行によって演算子などが別の値に変化することを「化ける」と表現することにします。

```sql
出金額(3000) > 0 # TRUE
出金額(3000) = 0 # FALSE
```

SQLで利用される比較演算子には他にもたくさんのしゅるいがあります。なかでも次に挙げる6つは最も基本的な比較演算子です。

### 3.3.2 NULLの判定
- NULLとは
    - そこに何も格納されていない、未定義であることを表す。
    - 数字のゼロや空白文字とも異なる。
    
    次の家計簿テーブルは金額がゼロだった箇所がNULLになっています。つまり、0という値すら入っていない空欄の状態になっていることを表しています。
    
    たとえば、入金額が「0」の場合と「NULL」の場合では、意味が異なります。
    
    - 入金額が「0」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金し、0円入金した。
        
    - 入金額が「NULL」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金した。
        
    
    0という値が入金額として記入されているということは、「0円だけれども入金があった」という意味です。一方、NULLとは何もないこと、未定義であることを意味するのですから、入金が発生しなかった、または不明なことを表します。
    
    NULLかどうかを判定するには、=演算子や<>演算子は利用できません。たとえば「SELECT ＊ FROM 家計簿 WHERE 出金額 = NULL」という記述は、正しく判定されません。
    
    列の値がNULLであることを判定するためには`IS NULL 演算子`、NULLでないことを判定するためには`IS NOT NULL 演算子`を使います。
    
- NULLの判定
    - NULLであることを判定する。
    
    ```sql
    式 IS NULL
    ```
    
    - NULLでないことを判定する。
    
    ```sql
    式 IS NOT NULL
    ```
    
    正しいNULLの判定方法
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額　IS NULL
    ```
    
    NULLであるかの判定をすべきところに通常の比較演算子を使ってしまうという誤りは、SQLを学び始めて間もない頃によく犯してしまう代表的なミスです。はじめのうちは、意識して注意するようにしましょう。
    
- NULLは＝で判定できない！
    
    NULLは「＝」や「<>」では判定できない。必ずIS NULLやIS NOT NULLを使って条件式を作ること。
    
- 比較演算子の＝でNULLかどうかを判定してはいけない理由—3値論理
    
    ＝などの比較演算子ではNULLの判定ができない理由が気になるという人のために、少し踏み込んで仕組みを紹介しましょう。
    
    この章では、条件式の結果は常に真(TRUE)か偽(FALSE)になると説明しました。しかしSQLの条件式は、これら2つ以外にも、UNKNOWN(不明、計算不能)という3つ目の結果を持つ3値論理と呼ばれる仕組みを採用しています。このUNKNOWNについて、次の2つのことを理解すると、きっと謎が解けるでしょう。
    
    1. ＝や<>などの通常の比較演算子は、もともと値と値を比較するためのもの。よって、「値ではないNULL」を比較すると、不明な結果であるUNKNOWNになる。
    2. WHERE句による絞り込みは、条件式が真(TRUE)となる行だけが選ばれる。条件式が偽(FALSE)やUNKNOWNとなる行は処理対象にならない。


### 3.3.3 LIKE演算子
文字列があるパターンに合致しているかをチェックすることをパターンマッチングといいます。SQLではこのパターンマッチングにLIKE演算子を使います。パターンマッチングを行うと、部分一致の検索(〇〇○という文字列を一部に含むか？という判定)が簡単にできます。
- LIKE演算子によるパターンマッチング
    
    ```sql
    式 LIKE パターン文字列
    ```
    
    パターン文字列に使用できる文字には、主に次のようなものがあります。
    
    | パターン文字 | 意味 |
    | --- | --- |
    | % | 任意の0文字以上の文字列 |
    | _(アンダースコア) | 任意の1文字 |
    
    1月に関連する行を取得するSELECT文
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ LIKE '%1月%' # 1月の前後に任意の0文字以上の文字列が付いてもよい
    ```
    
    結果表
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-10 | 給料 | 1月の給料 | 280000 | 0 |
    | 2018-02-18 | 水道光熱費 | 1月の電気代 | 0 | 7560 |
    
    「％」は0文字以上の任意の文字列を意味する記号ですから、「**％1月％**」は1月の前後に0文字以上の文字が付いていてもよいこと、つまり1月という文字を含む文字列であることを意味します。
    
    同様に、「**％1月**」は、1月という文字で終わる文字列であることを意味し、「**1月_**」は「1月で始まり、その後ろに任意の1文字がある文字列」という意味になります。


### 3.3.4 BETWEEN 演算子
BETWEEN演算子は、ある範囲内に値が収まっているかを判定します。
- BETWEEN演算子による範囲判定
    
    ```sql
    式 BETWEEN 値1 AND 値2
    ```
    
- ％や_を含む文字列をLIKEで探したい
    
    「100％」という文字で終わるかを判定したい場合のように、％や_の文字そのものを含む文字列を部分一致検索したい時には、少し工夫が必要です。なぜなら、次のようにそのまま記述すると、％は特殊な意味の文字として扱われてしまうからです。
    
    ```sql
    /* 「100を含む文字列」という意味になる */
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100'
    ```
    
    パターン文字列の中で、単なる文字として％や_を使いたい場合、次のようにESCAPE句を併用した記述を行います。
    
    ```sql
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100$%' ESCAPE '$'
    ```
    
    ESCAPE句で指定した文字(上の行では$)はエスケープ文字といい、パターン文字列において特殊な取り扱いがされるようになります。この例では、今回のエスケープ文字$に続く%や_は、ただの文字として扱われます。
    
    BETWEEN演算子では、値が「値1以上かつ値2以下」の場合に真になります。値がちょうど値1や値2の場合も真になる点に注意してください。
    
    たとえば、出金額の列が100以上3000以下の範囲になる行のみを検索するには、次のようなSQL文を記述します。
    
    100〜3,000円の出費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額 BETWEEN 100 AND 3000
    ```
    
    ※次節に登場する論理演算子ANDでも同じ判定が可能。状況にもよるが、BETWEENのほうが処理性能が悪いことがあるから注意すること。


### 3.3.5 IN/NOT IN演算子
IN演算子は、値が括弧内に列挙した複数の値の(値リスト)のいずれかに合致するかを判定する演算子です。＝演算子では、1つの値との比較しかできませんが、IN演算子を使えば、一度にたくさんの値との比較が可能です。
- IN演算子による複数値との比較
    
    ```sql
    式 IN (値1, 値2, 値3...)
    ```
    
    食費・交通費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 IN ('食費', '交際費') # 値リスト
    ```
    
    逆に、括弧内に列挙した値のどれとも合致しないことを判定するには、NOT IN演算子を使います。次のリストは、費目の列が「食費」でも「交通費」でもない行が抽出対象となります。
    
    食費でも交際費でもない行を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 NOT IN ('食費', '交際費')
    ```


### 3.3.6 ANY/ALL演算子
IN演算子では、ある値が複数の値のどれかと等しいかを判定することができました。もし、複数の値と代償を比較したい場合には、ANY演算子やALL演算子を利用することができます。

ANYやALLは、必ずその直前に比較演算子をつけて利用します。これにより複数の値との比較を一度に行うことができます。

ただし、DBMSによっては、「副問い合わせ」でしか使えないことがあります。
- ANY/ALL演算子による複数値との比較
    - 値リストのそれぞれと比較して、いずれかが真なら真
    
    ```sql
    式 基本比較演算子 ANY (値1, 値2, 値3...)
    ```
    
    - 値リストのそれぞれと比較して、すべて真なら真
    
    ```sql
    式 基本比較演算子 ALL (値1, 値2, 値3...)
    ```
    
    ※基本比較演算子とは、「＝」「<」「<>」などの6つの演算子のこと
    
    - IN演算子の場合……出金額が値リストの中の**「どれか」**と**「一致」**するなら真。
        - 出金額(3000) IN (1000, 2000, 3000)
            - 出金額(3000)はINの右辺の3000と一致するので式の値は真
    - < ANY演算子の場合……出金額が値リストの中の**「どれか」**より**「小さい」**なら真。
        - 出金額(2500) < ANY (1000, 2000, 3000)
            - 出金額(2500)はANYの右辺の3000より小さいので式の値は真。
    - < ALL演算子の場合……出金額が値リストの中の**「すべて」**より**「小さい」**なら真。
        - 出金額(1000) < ALL (1000, 2000, 3000)
            - 出金額(1000)はANYの右辺の2000と3000より小さいが、1000より小さくないので式の値は偽。
    
    ANYやALLの例を冷静に見てみると、わざわざANYを使って「1000と2000と3000のどれかより小さい」という複雑な条件を書かなくても、はじめから「出金額 < 3000」と書けばよいのです。
    
    ANYやALLといった演算子は、単体で利用してもあまりメリットはなく、**「式」や「副問い合わせ」などの道具と組み合わせて初めて、その真価を発揮**します。**まずはANYやALLの構文と仕組みをしっかりマスター**しておいてください。</details>


<details><summary>3.4 複数の条件式を組み合わせる</summary>

### 3.4.1 論理演算子
WHERE句に条件式を使用することは前節で解説した通りです。しかし1つの条件式ではうまく行を絞り込めない場合、論理演算子を用いて、複数の条件式を組み合わせることができます。

代表的な論理演算子には、AND演算子とOR演算子があります。
- AND演算子とOR演算子
    - 2つの条件式の両方が真の場合だけ、真となる(AかつB)。
    
    ```sql
    条件式1 AND 条件式2
    ```
    
    - 2つの条件式のどちらかが真ならば、真となる(AまたはB)。
    
    ```sql
    条件式1 OR 条件式2
    ```
    
    2つの条件式を組み合わせたWHERE句
    
    ```sql
    UPDATE 湊くんの買い物リスト
       SET 価格 = 6200
     WHERE 名称 = 'スッキリ勇者クエスト'
       AND 販売店 = 'B'
    ```
    
    ANDとORは、両辺に条件式を必要とする演算子です。一方、右辺しか必要としないNOT演算子も存在します。NOTを記述すると、右辺の条件式の結果は、真は偽に、偽は真に逆転します。
    
- NOT演算子による真偽値の逆転
    
    ```sql
    NOT 条件式
    ```
    
    たとえば、「WHERE NOT 販売店 = ‘B’」という記述で、「販売店がB以外の行」を取り出すことができます。


### 3.4.2 論理演算子の優先度
論理演算子で条件式を組み合わせる際は、演算子が評価される優先順位に注意を払う必要があります。複数の論理演算子が使われている場合では、(1)NOT、(2)AND、(3)ORの優先順位に従って処理されていきます。

特に、ANDとORの優先順位については注意が必要です。

たとえば、「販売店AかBで売っている、ゲームかDVD」を検索したいために、以下の内容を実行すると、意図に反して2行目以外のすべての行が返されてしまします。

複数の論理演算子を使ったSELECT文

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B'     /* 条件式2 */
   AND カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD'   /* 条件式4 */

SELECT * FROM 湊くんの買い物リスト  WHERE 販売店 = 'A' OR 販売店 = 'B' AND カテゴリ = 'ゲーム' OR カテゴリ = 'DVD' 
```

これはORよりもANDの優先順位が高いため、DBMSがまず条件式2と3を先に評価し、その結果と条件式1と4をORで評価してしまったからです。

このような場合は、条件式に括弧をつけることでその評価の優先順位を引き上げることができます。

複数の論理演算子を使ったSELECT文(条件式に括弧を付ける)

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE ( 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B' )    /* 条件式2 */
   AND ( カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD' )  /* 条件式4 */
```

DBMSは、括弧で括られた条件式1と2、3と4をそれぞれORで処理し、最後にその結果をANDで評価します。これで目的通り、上の結果表のように「販売店AかBで売っているゲームかDVD」の行を得ることができます。

- 括弧による優先順位の引き上げ
    
    条件式を括弧で括ると、評価の優先順位が引き上がる。</details>


<details><summary>3.5 主キーとその必要性</summary>


### 3.5.1 思いどおりに削除できない!?
| 日付 | 費目 | メモ | 入金額 | 出金額 |
| --- | --- | --- | --- | --- |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-06 | 教育娯楽費 | 月刊SQLを購入 | 0 | 1280 |
このテーブルの1行目だけを削除する方法を考えてみましょう。たとえば、「DELETE FROM 家計簿 WHERE 日付 = ‘2018-03-03’ AND 出金額 = 105」としても、1行目と2行目の両方が削除されてしまいます。

紙面では「上の行」「下の行」と記述できますが、データとしては1行目と2行目は全く同じものであり、区別する手段がありません。そして、行を区別できないということは、ある特定の行だけを指定して操作することができないことを意味します。

- 重複した行がもたらす問題
    
    完全に重複した行が存在すると、そのうちのある行だけを区別、識別することはできない。よって、ある行だけを操作することもできない。
    
    このような理由から、よほど特殊な状況を除いて、テーブルの中に重複した行が格納されるようなことは避けるべきとされています。今回の場合は、1日にまったく同じ内容の買い物を複数回するとどうしても重複した行を記録することになってしまうため、そもそもテーブルの構造自体に問題があるといえます。


### 3.5.2 特定の行を削除する方法
| 社員番号 | 年齢 | 性別 | 名前 |
| --- | --- | --- | --- |
| 2003031 | 45 | 1 | ヨシダ　シゲル |
| 2003032 | 45 | 1 | ヨシダ　シゲル |
| 2005011 | 31 | 1 | スガワラ　タクマ |
| 2012001 | 22 | 1 | ミナト　ユウスケ |
| 2012002 | 24 | 2 | アサカ　アユミ |
「ヨシダ　シゲル」さんという同姓同名で年齢も性別も同じ社員が2名在籍しています。しかし、次のようにして「上の行」のヨシダシゲルさんだけを削除することができます。

上のヨシダシゲルさんだけを削除する

```sql
DELETE FROM 社員
 WHERE 社員番号 = '2003031' /* 社員番号で対象行を特定 */
```

同姓同名にもかかわらず削除したい行を正しく識別することができたのはこのテーブルが「社員番号」という列を持っていたおかげです。加えて、この「社員番号」という情報が、次のような特殊な条件を満たすものであることも非常に重要です。

- 「社員番号」が備える特殊な性質
    - 社員番号を持たない社員は存在しない。
    - 同じ社員番号が、異なる社員に割り振られることはない。
    
    →「社員テーブルで行が重複することはあり得ない」
    
    社員テーブルにおける社員番号のように、「この値を指定することで、ある1行を完全に特定できる」という役割を担う列のことを、主キー(primary key)といいます。主キーとなる列は、次のような特性を持っています。
    
- 主キーとなる列が持つべき特性
    - 必ず何らかのデータが格納される(NULLではない)。
    - 他の行と値が重複しない。
    
    私たちがデータベースで情報を管理する場合、ある特定の行を削除したり更新したりすることは頻繁に発生します。従って、あらゆる行をいつでも自由にWHERE句で特定できるためにも、すべてのテーブルは主キーとなるような列を必ず持つべきなのです。


### 3.5.3 主キー列を作り出す
社員情報を管理するために社員テーブルを作ろうと考える過程で、「氏名」や「性別」などに加えて、「社員番号」という列を作ることも自然に思いつくでしょう。自然に登場し、主キーの役割を果たせるこの列は、自然キー(natural key)と呼ばれます。

一方、家計簿テーブルの場合、「日付」「出金額」「入金額」など思いつくままに列を作っていっても、主キーの役割を果たせる列が登場しません。このような場合は、特定の行を識別可能にするためだけに、主キーのための列を無理やり作ってしまうことが一般的です。家計簿テーブルの場合、「1回の入出金行為」それぞれに連番で番号を振り、「入出金ID」のような列として管理します。

それぞれの入出金行為ごとに番号を振って、管理する

- 朝チョコを買った行為
    - 入出金ID：102　出金￥105
- 夕方チョコを買った行為
    - 入出金ID：103　出金￥105
- 翌日給料をもらった行為
    - 入出金ID：104　入金￥250000

「入出金ID」列のように、管理目的のためだけに人為的に追加された列を、自然キーに対して人工キー(artificial key)や代替キー(surrogate key)といいます。


### 3.5.4 複数の列で行を意識する
これまで解説してきたように、「内容が重複する可能性がある列」は主キーとして利用することはできません。しかし、単独では重複の可能性がある列でも、複数を組み合わせれば重複する可能性が実質的になくなる場合があります。

図3-7の場合、氏名、住所、生年月日の3つの列を組み合わせれば主キーとして扱うことが可能です。このように、複数の列を1つの主キーとして扱うものを複合主キー(compound key)といいます。

※各列は、単独では重複する可能性があり「主キー」の役割を果たせない。そのため、複数の列で1つの主キーを構成する。
- 時刻情報を含む日付の判定
    
    DATE型を条件式に用いる場合は、時刻情報について注意が必要です。
    
    たとえば、2018年3月以前のデータを抽出するために、「日付 <= ‘2018-03-31’」とした場合、時刻を指定してないため、DBMS製品によっては「2018-03-31 00:00:00」と解釈する可能性があります。その結果、「2018-03-31 10:30:00」などのデータはこの条件には合致せず、正しい結果を得ることができません。そこで、このような落とし穴を回避するために、判定の基準となる日付の翌日より過去という条件(「日付 < ‘2018-04-01’」)を指定します。
    
    なお、本書ではDATE型には時刻情報が含まれないものとして記述しています。</details>


<details><summary>3.6 この章のまとめ</summary>

### 3.6.1 この章で学習した内容
- WHERE句
    - WHERE句に記述した条件式によって、対象データを絞り込むことができる。
    - WHERE句は、SELECT、UPDATE、DELETE文で使うことができる。
- 演算子
    - 条件式にはさまざまな演算子を記述できる。
        
        比較演算子：=,<,>,<=, >=,<>,IS NULL,LIKE,BETWEEN,IN,ANY,ALL
        
        論理演算子：AND,OR,NOT
        
    - 論理演算子は、NOT,AND,ORの順で優先度が高く、先に評価される。
- NULL
    - データが格納されておらず、未定義の状態を「NULLが格納されている」と表現する。
    - NULLを判定するための条件式では、IS NULLとIS NOT NULLを使用する。「＝NULL」では正しく判定できない。
- 主キー
    - 主キーによって、テーブル内の1つひとつのデータが識別可能になる。
    - 主キーとなる列には、重複しない値が必ず格納される必要がある。
    - 自然キーが存在しない場合は、人工キーを追加して識別可能にする。
    - 複数の列を組み合わせて複合主キーを構成し、行を識別するために用いることができる。


### 3.6.2 この章でできるようになったこと
3月1日に使った食費を知りたい。

```sql
SELECT * FROM 家計簿
 WHERE 日付 = '2018-03-01' AND = '食費'
```

支出に関係のない行を取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 出金額 IS NULL
```

メモに「購入」を含む支払いを調べたい。

```sql
SELECT * FROM 家計簿
 WHERE メモ LIKE '%購入%' AND 出金額 > 0
```

住居費(家賃、電気代、水道代の総称)に関わる支払いを調べたい

```sql
SELECT * FROM 家計簿
 WHERE 費目 IN ('家賃', '電気代', '水道代')
```

3月の行だけを取り出したい

```sql
SELECT * FROM 家計簿
 WHERE 日付 BETWEEN '2018-03-01' AND '2018-03-31'
```

</details>

# 第4章 検索結果の加工
SELECT文は基本的に、抽出の対象である選択列リスト、抽出元であるFROM句、抽出の条件であるWHERE句から成り立っています。

さらにSELECT文には、検索した結果を加工し、目的に合わせた形に整形する指示を加えることもできます。

この章ではSELECT文にスポットを当て、その多様な修飾方法を見ていきましょう。


<details><summary>4.1 検索結果の加工</summary>

### 4.1.1 SELECT文だけに可能な修飾
SQLの4大命令
| 命令 | 各命令で固有の部分 | 対象行の絞り込み | 検索結果の加工 |
| --- | --- | --- | --- |
| SELECT | 列名…FROM　テーブル名 | WHERE | その他修飾 |
| UPDATE | テーブル名　SET　列名　=　値… | WHERE |  |
| DELETE | FROM　テーブル名 | WHERE |  |
| INSERT | INTO　テーブル名(列名…)　VALUES(値…) |  |  |
前章では、INSERT文以外のSQLに共通して利用可能なWHERE句について学びました。そして第Ⅰ部最後のこの章では、さらにSELECT文にだけ付けることのできる修飾について紹介していきます。

SELECT文専用の修飾は、どれも「SELECT文によって得られた検索結果をさまざまな形に加工するためのもの」です。多くのDBMSでは、SELECTによる検索とともに加工も行われますが、2段階の処理を考えるとイメージしやすいでしょう。

- ステップ①：通常の検索実行
- ステップ②：検索結果を加工
    - 並び替えや、重複行の排除など

次節からは修飾の具体的な内容として、6つの修飾語を順に紹介していきます。

検索結果を加工する主なキーワード
| キーワード | 内容 | 解説 |
| --- | --- | --- |
| DISTINCT | 検索結果から重複行を除外する | 4.2 節 |
| ORDER BY | 検索結果の順序を並べ替える | 4.3 節 |
| OFFSET - FETCH | 検索結果から件数を限定して取得する | 4.4 節 |
| UNION | 検索結果に他の検索結果を足し合わせる | 4.5 節 |
| EXCEPT | 検索結果から他の検索結果を差し引く | 4.5 節 |
| INTERSECT | 検索結果と他の検索結果で重複する部分を取得する | 4.5 節 |
  </details>


<details><summary>4.2 DISTINCT — 重複行を除外する</summary>

### 4.2.1 値の一覧を得る
DISTINCTキーワードをSELECT分に付加すると、結果表の中で内容が重複している行があれば、その重複を取り除いてくれます。

重複行を除外する

```sql
SELECT DISTINCT 列名...
  FROM テーブル名
```

たとえば、家計簿テーブルから入金額の列のみを抽出する場合、DISTINCTを付けるか付けないかで検索結果が変わってきます。

リスト4-1 DISTINCTを使わないSELECT文

```sql
SELECT 入金額 FROM 家計簿
```

リスト4-2 DISTINCTを使ったSELECT文

```sql
SELECT DISTINCT 入金額
  FROM 家計簿
```

DISTINCTは、データの種類を取得したい場合に役立ちます。たとえば、家計簿テーブルの費目には、「食費」「水道光熱費」「給料」などの支出の記録が何度も登場することが考えられます。このとき、DISTINCTを使って重複を取り除くことで、どのような種類の支出があったかを、一覧で抽出することができます。

リスト4-3 費目一覧の取得

```sql
SELECT DISTINCT 費目 FROM 家計簿
```

- ステップ①：SELECT 費目
- ステップ②：DISTINCT

なお、このDISTINCT修飾は、他の修飾と異なり、SELECT文の最初に記述する必要がありますので注意してください。</details>


<details><summary>4.3 ORDER BY — 結果を並べ替える</summary>

### 4.3.1 並び替えの基本
SELECT文の最後にORDER BY 句を記述すると、指定した列の値を基準として検索結果を並べ替えて取得することができます。

検索結果を並べ替える

```sql
SELECT 列名... FROM テーブル名
 ORDER BY 列名 並び順

※並び順は、ASCまたはDESC(省略するとASCと同じ意味になる)。
```

ORDER BY句はSELECT文の最後に、並び替えの基準とする列名と並び順を指定します。並び順は、昇順にする場合はASC、降順にする場合はDESCを指定します。但し、ORDER BY句の初期値は昇順ですので、並び順の指定を省略すると、結果は昇順になります。

なお、ORDER BY句に文字列を指定すると、DBMSに設定された照合順序(文字コード順、アルファベット順など)を基準として並べ替えられます。

リスト4-4 出金額で昇順となるよう並べ替えて取得する

```sql
SELECT * FROM 家計簿
 ORDER BY 出金額
```

リスト4-5 日付で降順となるよう並べ替えて取得する

```sql
SELECT ※ FROM 家計簿
 ORDER BY 日付 DESC
```

お買い物サイトの「売れ筋ランキング」の表示も、内部ではORDER BYを使っている。

### 4.3.2 複数の列を基準にした並び替え
ORDER BY句による並び替えの際、複数の列をカンマで区切って指定することができます。このような指定を行うと、最初に指定された列で並べ替えて同じ値が複数行あれば、次に指定された列で並び替えが行われます。

たとえば、「原則として入金額の降順で並べ替える。入金額が等しい行については、さらに出金額の降順で並べ替える」という指定をするには、次のようなSQL文を記述します。

リスト 4-6 複数の列で並べ替える

```sql
SELECT * FROM 家計簿
 ORDER BY 入金額 DESC, 出金額 DESC
```

ORDER BY句では、並び替えの基準とする列を列名ではなく列番号で指定することも可能です。列番号とは、選択列リストにおける列の順番のことで、SELECT命令に記述した順に1から数えます。先程のリストを列番号で書き換えてみます。

リスト4-7 列番号を指定するORDER BY句

```sql
SELECT * FROM 家計簿
 ORDER BY 4 DESC, 5 DESC
# 結果表はリスト4-6と同じ
```

テーブルの前列を指定する「＊」を選択列リストに使った場合も、実際に取得の対象となる列に置き換えた列番号を指定します。

ORDER BY句における列指定に列番号を用いる場合、SELECT文の選択列リストの記述を修正すると並び替えの結果にも影響が及ぶ点には注意が必要です。

このような注意があることから、列番号指定を用いる機会はあまり多くはありません。</details>


<details><summary>4.4 OFFSET - FETCH —先頭から数行だけ取得する</summary>

### 4.4.1 OFFSET - FETCH句の利用
検索結果の全行ではなく、並べ替えた結果の一部だけを得られればよいケースもあります。そのような場合、ORDER BY句に続けてOFFSET - FETCH(オフセット-フェッチ)句を付けることによって簡単に実現できます。
- 先頭から数件だけを取得する
    
    ```sql
    SELECT 列名... FROM テーブル名
     ORDER BY 列名...
    OFFSET 先頭から除外する行数 ROWS
    (FETCH NEXT 取得行数 ROWS ONLY)
    # MySQL,MariaDB,SQLiteではサポートされない
    ```
    

OFFSET句には、先頭から除外したい行数を記述します。省略はできませんので、除外せずに1件目から取得したい場合には0を指定しましょう。

FETCH句には、取得したい行数を指定します。FETCH句を省略すると、該当するすべての行が抽出されます。

たとえば、結果の11〜15番目の行だけを取得したい場合は、OFFSET句に10、FETCH句に5を指定することになります。

リスト4-8 出金額の高い順に3件を取得する

```sql
SELECT 費目, 出金額 FROM 家計簿
 ORDER BY 出金額 DESC
OFFSET 0 ROWS
 FETCH NEXT 3 ROWS ONLY
```

リスト4-9 3番目に高い出金額だけを取得する

```sql
SELECT 費目, 出金額 FROM 家計簿
 ORDER BY 出金額 DESC
OFFSET 2 ROWS
 FETCH NEXT 1 ROWS ONLY
```

OFFSET - FETCH句はORDER BY句と併用されることが多い機能ですが、SQL Serverを除き、OFFSET - FETCH句だけでも使用することが可能です。但しその場合は、どのような並び順で帰ってくるかは実行してみるまでわかりません。

なお、OFFSET ~ FETCH句に対応していないDBMSも存在します。行を制限して取得する別の方法も紹介しておきます。これらはいずれもリスト4-8と同等の動きをします。

リスト4-10 取得行を限定するその他の方法

```sql
-- LIMITの利用
   (Db2,MySQL,MariaDB,PostgreSQL,SQLite,H2 Database)
SELECT 費目, 出金額 
  FROM 家計簿
 ORDER BY 出金額 DESC LIMIT 3 # 最後から3つ分の行を抽出
# OFFSETで読み飛ばす行数を指定することも可能
```

</details>


<details><summary>4.5 集合演算子</summary>

### 4.5.1 集合演算子とは
構造がよく似た複数のテーブルにSELECT分をそれぞれ送り、その結果を組み合わせたい場合は、集合演算子を活用することにより、1つのSQL文で目的を達成することができます。

集合演算とは、SELECT命令によって抽出した結果表を1つのデータの集合と捉え、その結果同士を足し合わせたり、共通部分を探したりといったさまざまな演算を行ってくれる仕組みです。SQLでは、3つの集合演算を利用することができます。
1. UNION - 和集合：2つの検索結果を足し合わせたもの
2. EXCEPT(MINUS) - 差集合：最初の検索結果から次の検索結果と重複する部分を取り除いたもの
3. INTERSECT - 積集合：2つの検索結果で重複するもの

**※Oracle DBではEXCEPTの代わりにMINUSを利用。MySQLではUNIONのみ使用可。**


### 4.5.2 UNION — 和集合を求める
UNION演算子は、最も代表的な集合演算子です。2つのSELECT文をUNIONで繋いで記述すると、それぞれの検索結果を足し合わせた結果(和集合)が返されます。
- 2つのSELECT文の結果を足し合わせる
    
    ```sql
    SELECT 文1
     UNION (ALL)
    SELECT 文2
    ```
    

また、UNIONにALLというキーワードを付加すると、和集合の結果に重複行があった場合に動作が違ってきます。UNIONでは重複行を1行にまとめるのに対し、UNION ALLでは重複行をすべてそのまま返します。

リスト4-11 和集合を取得する

```sql
SELECT 費目, 入金額, 出金額 FROM 家計簿
 UNION
SELECT 費目, 入金額, 出金額 FROM 家計簿アーカイブ
 ORDER BY 2, 3, 1
```

集合演算は、選択列リストに記述した列の組み合わせで計算されます。リスト4-11の例では、家計簿テーブルと家計簿アーカイブテーブルにあるすべての行が抽出され、1つの結果表として返ってきました。また、ALLキーワードがついていないため、重複した住居費などの行は、1行だけになっています。

- 集合演算子を使える条件
    
    SELECTの結果を集合演算子でまとめるときは、選択列リストの列数とそれぞれのデータ型が一致していなければならない。
    

つまり、列数とデータ型さえ一致していれば、まったく異なるテーブルや列でもひとまとめにして抽出することができます。

また、1つのテーブルに格納されたデータを複数の異なる条件で抽出したい場合にもUNIONは活用できます。それぞれのWHERE条件を記述したSELECT文を用意し、UNIONで1つのSQL文としてまとめることで、SQLの実行回数を抑えることが可能になります。

1つの集合演算子がまとめることのできる検索結果は2つだけですが、さらに別の集合演算子を記述することによって、3つ以上の検索結果について集合演算させることも可能です。その場合は、UNIONだけでなく、後述する他の種類の集合演算子を組み合わせることもできます。

なお、集合演算子を使ったSQL文でORDER BY句による並び替えをする場合には、次のことに注意してください。

- 集合演算子でORDER BY句を使う時の注意点
    - ORDER BY句は最後のSELECT文に記述する。
    - 列番号以外による指定(列名やASによる別名)の場合、1つめのSELECT文のものを指定する。
- 数が一致しないSELECT文を繋げるテクニック
    
    選択列リストの数が合わないSELECT文で、どうしても集合演算子を使いたい場合は、足りないほうの選択列リストにNULLを追加することで、数を一致させることができます。
    
- DBMSにとって並び替えは大仕事
    
    SELECT文の最後にくっつけるだけで検索結果を並べ替えてくれるORDER BY句はとても便利な機能です。しかし、この並び替えという処理は、DBMSにとってはかなり負荷のかかる作業であることをぜひ頭の片隅に置いておいてください。
    
    性能上のボトルネックになることを防ぐため、第Ⅲ部で紹介するインデックスの併用を推奨しますが、一時的に定量のメモリを消費する可能性もあります。
    
    また、DISTINCTやUNIONも内部的には並び替えを行っていることがあります。これも大量のメモリを消費する可能性があるため、乱用は控えましょう。</details>


<details><summary>4.6 この章のまとめ</summary>

### 4.6.1 この章で学習した内容
検索結果の加工
- SELECT文で取得したデータは、以下のようなさまざま形に加工できる。
- DBMSによって、使うことのできる機能やキーワードが異なる場合がある。

**集合演算子**

- 集合演算子は、複数のSELECT文の結果を使った演算ができる。
- UNIONは、和集合を求める。
- EXCEPT,MINUSは、差集合を求める。
- INTERSECTは、積集合を求める。


### 4.6.2 家計簿DBでできるようになったこと
- これまでに使った費目一覧を、重複を除外して作りたい。

```sql
SELECT DISTINCT 費目 FROM 家計簿
```

- 3月に使った金額を大きい順に取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 日付 >= '2018-03-01'
   AND 日付 <= '2018-03-31'
 ORDER BY 出金額 DESC
```

- これまでの給料を大きい順に5件だけ取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 費目 = '給料' ORDER BY 入金額 DESC
OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY # MySQLではOFFSET 0 ROWS LIMIT 5またはLIMIT 5
```

- 家計簿と、アーカイブにある2月のデータをまとめて日付順に取り出したい。

```sql
SELECT * FROM 家計簿
 UNION
SELECT * FROM 家計簿アーカイブ
 WHERE 日付 >= '2018-02-01'
   AND 日付 <= '2018-02-28'
 ORDER BY 1;
```

- 今月初めて発生した費目を知りたい。

```sql
SELECT 費目 FROM 家計簿
EXCEPT
SELECT 費目 FROM 家計簿アーカイブ
```

</details>
