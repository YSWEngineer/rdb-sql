# 📖スッキリわかるSQL入門

# 第0章 データベースを学ぶにあたって
私たちが日常的に利用するインターネット検索やSNSはもちろん、物流や金融といった社会基盤の多くが、情報システムに支えられています。その中枢で必ず使われているのが「データベース」です。

本書では、現代社会と情報システムに欠かせない存在であるデータベースについて学んでいきますが、まずはその全体像とロードマップを眺めてみましょう。

<details><summary>0.1 データベースを学ぼう</summary>
        
### 0.1.1 データベースとSQL  
- ATMの利用、チケットの予約、インターネットショッピング、オンラインゲームなどの仕組みの中枢で活躍しているのがデータベースです。
  データベースに格納されている情報は、専用の操作言語SQLを利用して、外部からアクセスして検索したり書き換えたりします。
  SQLの上達の近道は、実際に手を動かしてたくさんのSQL文を書き、実行してみることです。</details></details>

# 第1章 はじめてのSQL
第1章では、データベースの概要を紹介します。読み進めながら、頭の中に大まかなイメージを描いてみてください。
    
<details><summary>1.1 データベースとは</summary>

### 1.1.1 データベースってなんだろう
    
   狭い意味でデータベース(database)とは、検索や書き換え、分析などのデータ管理を目的として様々な情報を蓄積したものを指します。特にITの世界では、電子的な媒体にファイルなどの形式で保存・蓄積したものを言います。
   現在、分野を問わず広く用いられているのが複数の表の形式でデータを管理するリレーショナルデータベース(RDB:Relational Database)です。

- RDBの基本構造
- RDBには複数の表が入っており、ここの表をテーブル(table)という。
- 個々のテーブルには名前が付いており、その名前をテーブル名という。
- テーブルは列(column：カラム)と行(low：ロウ)で構成される。
- 1つの行が1件のデータに対応し、列はそのデータの要素に対応する。

 ※列のことをカラムやフィールドと呼ぶこともある。


たとえば、「社員」という名前が付いているテーブルには、社員の情報が格納されています。このテーブルには社員番号や名前といった社員に関する要素が列として存在し、社員1人ひとりに関する情報が一行ずつ格納されています。

| 社員番号 | 氏名 | 年齢 | 出身地 |
| --- | --- | --- | --- |
| 0101 | 菅原拓真 | 31 | 福岡県 |
| 0104 | 大江岳人 | 30 | 京都府 |
| 0108 | 立花いずみ | 29 | 千葉県 |
| 0292 | 朝香あゆみ | 24 | 北海道 |
| 0293 | 湊雄輔 | 22 | 千葉県 |

RDBとは、このような表形式の情報の集積であって、その実態は上図のような構造のデータを含んだただのファイルです。
            
そして、私たちは、SQLというデータベースを操作する専用の言語で書かれた命令を使って、これらのテーブルから特定の列や行のデータを自由に取り出したり、書き換えたりすることができます。
            
### 1.1.2 データベース管理システム(DBMS)
            
私たちがSQLを送る相手は、データベースファイルではなく、データベース管理システム(DBMS:Database Management System)と呼ばれるプログラムです。DBMSはコンピュータ内で常に稼働してSQLを待ち受けており、届いたSQLの内容に従って、データベースファイルの内容を検索したり書き換えたりする処理を実行してくれます。
            
ITの世界では、「データベースファイルとそれを管理するDBMS全体」と単にデータベースと表現することも多いので注意すること。
            
### 1.1.4 データベースにSQLを送るには
            
通常、DBMSに対しては、ネットワーク経由でSQLに送ります。この送信は各データベースが定める特有の手順や形式に従う必要があるため、たとえばメールソフトなどを使ってSQLを送ることはできません。</details>


<details><summary>1.2 はじめてのSQL</summary>

### 1.2.2 検索してみよう

- テーブル名および列名
    
    テーブルや列の名付け方は、会社やプロジェクトによってルールが定められていることがほとんどです。たいていは、次の3つの方法のいずれかでしょう。
    
    - 日本語　　(例)家計簿、費目
    - ローマ字　(例)KAKEIBO、HIMOKU
    - 英語　　　(例)HOUSEKIIPING_BOOK、EXPENSE_ITEM
    
    いずれの方法にも長短があります。ネーミングルールが定められていない場合、判読性や利用するDBMSの動作保証などを勘案して名前を付けてください。
    
    なお、実際の開発や設計では、DBMSの動作安定性を優先して日本語名を避けることも多くあります。
    
- リスト1-2 全ての列を検索する
    
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-03 | 食費 | コーヒーを購入 | 0 | 380 |
    | 2018-02-10 | 給料 | 1月の給料 | 280000 | 0 |
    | 2018-02-11 | 教養娯楽費 | 書籍を購入 | 0 | 2800 |
    | 2018-02-14 | 交際費 | 同期会の会費 | 0 | 5000 |
    | 2018-02-18 | 水道光熱費 | 1月の電気代 | 0 | 7560 |
    
    SELECTには目的とする列名を、FROMには検索したいテーブル名を記述します。
    
- リスト1-3 すべての列を取得する(簡略記法)
    
    列の指定に「＊」を記述すると、「すべての列」を取得します。


### 1.2.3 条件付きの検索
    
- WHEREは行を指定する。
    
### 1.2.4 データを追加してみよう
    
- INSERT INTO(インサートイントゥ)で追加先のテーブルを、VALUES(バリューズ)で追加するデータを指定する。
    
### 1.2.5 データを更新してみよう
    
- UPDATEでデータを修正する。
    
### 1.2.6 データを削除してみよう
    
- DELETEでデータを削除する。
    
    - 3命令の動作
        - SELECT文：ある条件を満たす行を探す→その行の内容を取得する
        - UPDATE文：ある条件を満たす行を探す→その行の内容を書き換える
        - DELETE文：ある条件を満たす行を探す→その行を削除する
        
        これらの3つの命令は、「目的の行に対する処理内容」それぞれ異なるものの、「目的のデータを探し当てるまで」は全く同じ動作です。目的の行を探すためのWHEREは、全く同じ書き方をすることができるのです。</details>


<details><summary>1.3 この章のまとめ</summary>

### 1.3.1 この章で学習した内容
データベースの概要

- データベースとは、管理や分析を目的としてさまざまなデータを蓄積したものを指す。
- ITにおけるデータベースの実態は、通常、ファイルである。
- データベースはデータベース管理システム(DBMS:Database Management System)によって管理される。
- 現在、さまざまなDBMSがソフトウェア製品として公開されている。
- 複数のテーブルの形式でデータを管理するものをリレーショナルデータベースという。
- テーブルには名前が付いており、行(low)と列(column)から構成される。

SQLの概要

- SQLは、データベースやデータを操作するための専門言語である。
- SQLで書かれた命令(SQL文)をDBMSに送信することで、データの検索・追加・更新・削除などを行うことができる。
- SQLを送信するには、ドライバを用いたプログラムを新しく開発するか、既存の送信プログラムを利用する。
- SQLの文法は利用するDBMS製品によって少しずつ異なるが、基本的な部分は同じである。</details>

# 第2章 基本文法と4大命令

SQL文を書くための基本的なルールについて紹介します。

そしてデータを操作する4つの命令、SELECT、UPDATE、DELETE、INSERTについて全体を俯瞰したうえで、ここに詳しくみていきましょう。

<details><summary>2.1 SQLの基本ルール</summary>

### 2.1.1 記述形式に関するルール
- SQLに共通する基本ルール(1)
    - 文の途中に改行を入れることができる。
    - 行の先頭や行の途中に半角の空白を入れることができる。

    SQLは文の途中で改行することが許されています。また、行の先頭や行の途中に空白を入れることも可能です。これらのルールを活用して、読みやすく整形されたSQL文の記述を心がけましょう。

- 一行で記述されたSELECT文

    ```sql
    SELECT 費目, 出金額 FROM 家計簿 WHERE 出金額 > 3000
    ```

- 整形されたSELECT文

    ```sql
    SELECT 費目, 出金額
     FROM 家計簿
     WHERE 出金額 > 3000
    ```

- 末尾のセミコロンで文の終了を表す
    
    文中に改行を含むことができるSQLの特性は、わかりやすいSQL文を書くためにはとても重宝します。一方で、複数のSQL文を続けて記述する場合などには、どこの文に区切りがあるのかが分かりにくいというデメリットがあります。そこで、1つのSQL文の末尾にセミコロン記号(;)を付けることにより、文の区切りを明示することがあります。
    
    ```sql
    SELECT *
    FROM 家計簿; # ここまででSELECT文終了
    DELETE FROM 家計簿;# ここまででDELETE文終了
    ```

    本書では、複数のSQL文を1つのリストとして掲載する場合のみ、セミコロンを付けています。


### 2.1.2 コメントに関する2つのルール
    
コメントの記述方法には、次の2つのルールがあります

- SQLに共通する基本ルール(2)
    - ハイフン2つ(- -)から行末まではコメントになり、無視される。
    - /* から*/まではコメントになり、無視される。

    コメントを記述したSQL

    ```sql
    /* 入出金表示用SQL バージョン0.1
       作成者:朝香あゆみ 作成日:2018-02-01 */
    SELECT 入金額, 出金額  -- 金額関連の列のみ表示
      FROM 家計簿
    ```

    改行や空白による生計とコメントを併せて活用することにより、後で見た時や、チームで共有した時にわかりやすいSQL文の記述が可能になります。


### 2.1.3 予約語に関するルール
    
SQL文に記述できる語句についてのルール。

- SQLに共通する基本ルール(3)
    - SELECTやWHEREなどの命令に使う単語は、SQLとして特別な意味を持つ「予約語」である。
    - 予約語を記述する際は、大文字と小文字の区別はない。
    - テーブル名や列名に予約語を利用することはできない。
    
    SELECTやWHEREなどの一部の単語は、SQLの機能として特別な意味を持つため、列名などに使うことはできません。これを予約語(keyword)といいます。
    
    SQLの文中では、予約語を大文字と小文字のどちらで書いても同じ意味になります。たとえば、
    
    ```sql
    select * FROM 家計簿
    ```
    
    でも
    
    ```sql
    Select * froM 家計簿
    ```
    
    でも同じように動作しますが、できるだけ判別しやすい書き方にすることをお薦めします。すでに会社やプロジェクトでルールが定められていればそれに従うと良いでしょう。
    
    なお、列名やテーブル名について、大文字と小文字を区別するかどうかは、DBMS製品や動作するOS、設定などによって異なります。</details>


<details><summary>2.2 データ型とリテラル</summary>

### 2.2.1 リテラルの種類

-
    
    ```sql
    INSERT INTO 家計簿
    		 VALUES ('2018-02-25', '居住費', '3月の家賃', 0, 85000)
    ```
    
    2行目には家計簿テーブルの各列に格納する5つのデータが記述されています。SQL文の中に書き込まれたデータそのものを特にリテラル(literal)といいます。
    
- リテラルの記述に関するルール
    - 「'」で括らずに記述されたリテラルは、数値情報として扱われる。
    - 「’」で括られたリテラルは、基本的に文字列情報として扱われる。
    - 「'」で括られ、’2018-02-25’のような一定の形式で記述されたリテラルは、日付情報として扱われる。
        
        たとえば、「123」と「'123'」では意味が異なります。前者は123(ひゃくにじゅうさん)という数量を表す数値データ、後者は123(いち・に・さん)という3つの文字の並びを表す文字列データです。


### 2.2.2 列とデータ型

数値のデータを誤って文字列情報として指定してデータ形式で格納されないように、データベースには安全装置が備わっています。DBMSは、数値ではないとして処理を中断するか、受け取った文字列を強制的に数値に変換して格納しようとします。

データベースの中には複数のテーブルがあり、テーブルは行と列から成り立っています。それぞれの列には名前がついていますが、それに加えて、列ごとに格納できるデータの種類を表すデータ型(data type)を定めることになっています。
| データ型の設定 | DATE(日付) | VARCHAR(20)(可変長文字列、最大20バイト) | VARCHAR(80)(可変超文字列、最大80バイト) | INTEGER(整数) | INTEGER(整数) |
| --- | --- | --- | --- | --- | --- |
| 列名 | 日付 | 費目 | メモ | 入金額 | 出金額 |

たとえば、入金額と出金額の列にはあらかじめ「INTEGER」という数値のデータがが設定されているため、格納できるデータは数値のみとなっています。

代表的なデータ型
| データ種別 | 区分 | 代表的なデータ型名 |
| --- | --- | --- |
| 数値 | 整数値 | INTEGER型 |
| 数値 | 小数 | DECIMAL型、REAL型 |
| 文字列 | 固定長 | CHAR型 |
| 文字列 | 可変長 | VARCHAR型 |
| 日付と時刻 | — | DATETIME型、DATE型、TIME型 |

利用可能なデータ型はDBMS製品によって異なりますが、数値型、文字列型、日付型は基本的に必ず用意されています。特に、INTEGER型、CHAR型、VARCHAR型は、多くのDBMS製品で共通して利用することができます。

- データ型
    - テーブルの各列には、データ型が指定されている。
    - 列には、データ型で指定された種類の情報しか格納することはできない。
    - 利用可能なデータ型は、DBMS製品によって異なる。


### 2.2.3 固定長と可変長

CHAR型は固定長の文字列データを扱うデータ型です。たとえば、CHAR(10)と指定されている列では、あらかじめ10バイトの領域が確保されており、格納するデータは常に10バイトになります。格納しようとする文字列が10バイトに満たない場合は、文字列の右側に空白が追加され、10バイトぴったりに調整されてから格納されます。

一方、VARCHAR型を指定された列は、格納する文字列の長さを勝手に調整することはありません。たとえば、VARCHAR(10)と指定された列では、3バイトや7バイトの文字列が入力された場合、それに合わせた領域が確保されるため、そのままの長さで格納することが可能です。ただし、最大長として10が指定してあるため、11バイトの文字列は格納できません。

- CHAR型は郵便番号や社員番号など、格納するデータの桁数が決まっているもの。
- VARCHAR型は氏名や書籍名など、格納するデータの桁数が変動する可能性のあるもの。

に向いたデータ型と言えます。

- DBMSに依存しやすい日付の取り扱い
    
    日付の取り扱いに関しては、各DBMS製品間での違いが比較的大きい点に注意が必要です。主に、次のような点が異なっています。
    
    - 日付リテラルとしてどのような記述を許すか
    - 日付に関するデータ型の名前や制度
    - 日付に関して利用できる命令(関数)の種類</details>


<details><summary>2.3 SQLの命令体系</summary>

### 2.3.1 4つの重要なSQL文

ほとんどのデータ操作は、SELECT、UPDATE、DELETE、INSERTのたった4つの命令で実現できてしまいます。これら4つのSQL命令は、DML(Data Manipulation Language)と総称されています。

- SQLの言語体系
    - SQLでデータ処理を行うには、命令をたくさん覚える必要はない。
    - 4大命令だけで、ほとんどの処理を実現できる。
    
    4つの命令にさまざまな修飾語のようなものを付加することで非常な複雑なデータ操作を実現できることが、SQLという言語の特徴です。
    
    ```sql
    シンプルな命令→検索をお願いします。
    豊富な修飾語→「日付」と「出金額」だけでいい。ただ、今年の1月分だけが欲しくて。
    あと、日付が新しい順に並べ替えてくれる？
    
    --SQLだと
    SELECT 日付, 出金額
      FROM ...
     WHERE ...
    ORDER BY ...
    ```
    
- 2.3.2 4大命令の全体像を俯瞰する
    
    命令の数は少なくてシンプルだが、複雑に修飾できるというSQLの特徴が混乱させることも少なくありません。しかし、4つの命令の文法をスッキリとマスターするコツが3つあります。
    
    - 4大命令をスッキリと学ぶコツ(1)
        
        4大命令の構造と修飾語の全体像をしっかり把握する。
        
        | 命令 | 各命令で固有の部分 | 対象行の絞り込み | 検索結果の加工 |
        | --- | --- | --- | --- |
        | SELECT | 列名•••FROM テーブル名 | WHERE 〜 | その他修飾 |
        | UPDATE | テーブル名 SET 列名 = 値••• | WHERE 〜 |  |
        | DELETE | FROM テーブル名 | WHERE 〜 |  |
        | INSERT | INTO テーブル名 (列名•••) VALUES (値•••) |  |  |
</details>


<details><summary>2.4 SELECT文—データの検索</summary>


### 2.4.1 SELECT文の基本構文
    
データベースとデータのやり取りをするにあたって、最も頻繁に使われるSQLがSELECT文です。テーブルから目的のデータを指定して取得することがその役割です。

SELECT文の基本構文

```sql
SELECT 列名••• # SELECT:取得しなさい　列名:この列のデータを
  FROM テーブル名 # FROM テーブル名:このテーブルから
(WHERE修飾)
(その他の修飾)
```

1行目のSELECTの後ろには、取得したい列の名前をカンマで区切って記述します。また「＊」アスタリスクを記述すれば、すべての列を指定することができます。

2行目はFROM句といい、データを取得するテーブルを指定するために必ず指定します。

以降、必要に応じて、WHEREによる修飾やその他の修飾を続けて記述します。


### 2.4.2 ASによる別名の定義
    
SELECT文における列名やテーブル名の指定では、それぞれの記述の後ろに「AS + 任意のキーワード」を付けることで、別名を定義することができます。
```sql
SELECT 費目 AS ITEM, 入金額 AS RECEIVE, 出金額 AS PAY
  FROM 家計簿 AS MONEYBOOK
 WHERE 費目 = '給料'
```

- **別名をつけるメリット**
    - 結果表における列のタイトルを任意のものに変更できる。
    - わかりにくい列名や長い列名でも、わかりやすく短い別名をつけて利用することができる。
- **SELECT ＊ の濫用に御用心**
    
    *による全列検索は便利ですが、データベースの設計変更などで列が増えたり減ったりすると、検索結果も変化してしまいます。そのため、データベースを検索するアプリケーションプログラムでSELECT *を使用していた場合、予期しないバグの原因になることがあります。実際の開発では極力使用を避けるか、十分な検討が必要です。</details>


<details><summary>2.5 UPDATE文—データの更新</summary>

### 2.5.1 UPDATE文の基本構文
UPDATE文は、すでにテーブルに存在するデータを書き換えるための命令です。

- UPDATE文の基本構文
    
    ```sql
    UPDATE テーブル名 # UPDATE:更新しなさい テーブル名:このテーブルの情報を
       SET 列名1 = 値1, 列名2 = 値2••• # 列名1を値1のデータで 列名2を値2のデータで
    (WHERE修飾)
    ```
    
    1行目のUPDATEの直後には、更新したいデータの存在するテーブル名を記述します。また、2行目をSET句といい、更新したい列名と、その列に書き込むデータを記述します。
    
    1つの列を更新するUPDATE文
    
    ```sql
    UPDATE 家計簿
       SET 入金額 = 99999
    # 「どの行を書き換えるべきか」という指定がないため、入金額のすべての行が99999に書き換えられてしまう
    ```
    
    条件付きのUPDATE文
    
    ```sql
    UPDATE 家計簿
       SET 入金額 = 99999
     WHERE 日付 = '2018-02-03'
    ```
    
    すべての行の値を同一のものに書き換えることは実務上稀なので、「WHEREを伴わないUPDATE文」は、ほとんど使う機会がないでしょう。

- WHEREのないUPDATE文は全件更新！
    
    WHEREで対象行を指定しないと、UPDATE文はすべての行を書き換えてしまう。</details>


<details><summary>2.6 DELETE文—データの削除</summary>

### 2.6.1 DELETE文の基本構文
DELETE文は、すでにテーブルに存在する行を削除するための命令です。行をまるごと削除する機能であるため、特定の列だけを指定するようなことはできません。
- DELETE文の基本構文
    
    ```sql
    DELETE # DELETE:削除しなさい
      FROM テーブル名 # FROM テーブル名:このテーブルの情報を
    (WHERE 修飾)
    ```
    
    DELETE文では列名を指定する必要がないため、1行目のDELETEの後ろには何も記述しません。
    
    DELETE文の例
    
    ```sql
    DELETE FROM 家計簿
    # DELETE文においてもWHEREを付けなければすべての行が削除対象となってしまう
    ```
    
    WHEREを付けなければすべての行が削除対象となってしまいます。
    
    WHEREなしのDELETE文は「データを全消去する」指示にほかなりません。見かけたら、本能的に「実行をためらう」感覚を身に付けてください。
    
- WHEREのないDELETE命令は全件削除！
    
    WHEREで対象行を指定しないDELETE文は、全データを削除する。</details>


<details><summary>2.7 INSERT文—データの追加</summary>

### 2.7.1 INSERT文の基本構文
INSERT文は、テーブルに新しいデータを追加するための命令です。テーブルの行を指定するWHEREはありません。そのかわり、どこに、どのようなデータを追加するのかを指定する構造になっています。
- INSERT文の基本構文
    
    ```sql
    INSERT INTO テーブル名 # INSERT INTO:追加しなさい テーブル名:このテーブルに
                (列名1, 列名2, 列名3...) # この列に
         VALUES (値1, 値2, 値3...) # このデータを
    ```
    
    1行目のINSERTには、INTOのキーワードに続けて、データを追加するテーブル名を記述します。さらにテーブル名の後ろに、括弧で括ってデータを追加する列名を指定します。ただし、そのテーブルのすべての列に値を追加する場合には、2行目を丸ごと省略可能です。
    
    3行目はVALUES句といい、2行目に記述した列名に対応するデータの値を指定します。列名を丸ごと省略した場合は、テーブルのすべての列について、値を指定する必要があります。
    
    複数の列に追加するINSERT文
    
    ```sql
    INSERT INTO 家計簿
                (費目, 日付, 出金額)
         VALUES ('通信費', '2018-02-20', 6200) # 2行目に対応して記述
    ```
    
    費目、日付、出金額の3つの列に対して格納すべき値を指定していますが、メモや入金額の列には値は何も格納されません。2行目で明示的に列を指定する場合、その指定順序は自由です。ただし、3行目で列挙する値も列に対応するよう同じ順番にする必要があります。
    
    **※VALUES句の値を記述する時は、2行目に記述した列指定と、順序、数、データ画の全てをピッタリ対応させること。**
    
    一方、2行目の列指定を丸ごと省略した場合、3行目に記述する値は、テーブルにおける列の順序(「SELECT *」を実行して表示される順)と同じでなければなりません。
    
    全列に追加するINSERT文
    
    ```sql
    INSERT INTO 家計簿
         VALUES ('2018-02-20', '通信費', '携帯電話料金', 0, 6200)
    # 家計簿テーブルの列の順と同じく、必ず日付、費目、メモ、入金額、出金額の順番で指定
    ```
    </details>


<details><summary>2.8 4つのSQLをスッキリ学ぶコツ</summary>

### 2.8.1 4大命令を振り返って
FROM、WHERE、AS、INTO、VALUESなど、さまざまな予約語が登場したため混乱してしまうかもしれません。そこで、「4大命令をスッキリと学ぶコツ」について、残りの2つも含めて紹介しておきましょう。
- 4大命令をスッキリ学ぶ3つのコツ
    1. 4大命令の構造と修飾語の全体像をしっかり把握する。
    2. 4大命令の2通りの分類方法を理解する。
    3. 4大目異例に共通するテーブル指定を先に書く。
    
    コツ1.については2.3節で紹介したとおりです。4大命令を個別に学び終えた今、図2-4(p053)のSQL体系図をもう一度見直しておくと良いでしょう。混乱したらいつでもこの図に戻ってください。


### 2.8.2 4大命令の2通りの分類を理解する
SELECT、UPDATE、DELETE、INSERTの4つを2つのグループに分類するとしたら、どのように考えますか？多くの人が思いつくのが、データベースに対する処理方法の違いによる次のような分類です。
- 4大命令の分類方法(1) 検索系と更新系
    
    検索系：SELECT
    
    更新系：UPDATE、DELETE、INSERT
    
    検索系の命令はデータベースのデータを書き換えることはありません。また、SQLの実行結果は表の形になります。一方、更新系の命令はデータベースのデータを書き換えることが仕事です。実行結果は基本的に「成功か失敗か」であり、表などが返されることはありません。
    
    ここで注目して欲しいのが、図2-4の右端にある「検索結果の加工」に関する修飾についてです。たとえば、「ORDER BY」という修飾語を使うことで検索結果の表の行を並べ替えることができます。しかし、この修飾は検索結果表に対する処理を指示するものなので、当然、実行結果が表ではないUPDATEやDELETE、INSERTには指定できないのです。
    
- 4大命令の分類方法(2) 既存系と新規系
    
    既存系：SELECT、UPDATE、DELETE
    
    新規系：INSERT
    
    既存系の命令は、すでにデータベースに存在するデータに対して何らかの処理を行うためのものです。一方、新規系の命令は、まだデータベースに存在しないデータについての指定をします。
    
    図2-4の右から2番目にある「対象行の絞り込み」(WHERE句)に着目してください。検索や更新そして削除は既存のデータに対して行う処理であるため、その対象行を指定するための共通した文法としてWHERE句が利用可能です。一方、既存のデータに対する処理ではないINSERT文では、WHERE句の利用はできません。


### 2.8.3 テーブル指定を先に記述する
WHERE句より前の部分について、より踏み込んで整理してみましょう。
- 4大命令の全てに共通すること
    
    処理対象とするテーブル名を必ず指定する必要がある。
    
    | 命令 | 各命令で固有の部分 |
    | --- | --- |
    | SELECT | 列名… FROM 　テーブル名 |
    | UPDATE | 　　　　　　　テーブル名　SET　列名　＝　値… |
    | DELETE |  　　    FROM　テーブル名 |
    | INSERT | 　　　INTO　  テーブル名　(列名…)　VALUES　(値…) |
    
    そして、ぜひ実践してほしいのが、次のような順序でのSQL文の記述です。
    
- スッキリ書けるSQL
    1. まず、命令文(SELECTやINSERTなど)を記述する。
    2. 次に、テーブル指定の部分を記述する。
    3. テーブル指定より後ろの部分を記述する。
    4. テーブル指定より前の部分を記述する(SELECT文のみ)。
    
    特に1〜2を考え込まずにできるよう訓練しておくと、どの命令にどのキーワードを書けばよいのかが自然に身に付くため、スムーズにSQL文を書けるようになるでしょう。
    
    ※このあたりは、練習量がモノを言う。いろんなSQL文を繰り返し書いてみることが近道。→dokoQLでたくさん練習すること。</details>


<details><summary>2.9 この章のまとめ</summary>

### 2.9.1 この章で学習した内容
- SQLの基本ルール
    - 記述の途中で改行してもよい。
    - 予約語は大文字、小文字が区別されない。また、列名などに利用できない。
    - 文中にコメントを記述することができる。
- データ型とリテラル
    - SQL文の中に直接記述されるデータのことをリテラルという。
    - 数値、文字列、日付など、データの種類に応じてリテラルの記述方法は異なる。
    - テーブルの各列にはデータ型が指定されている。
    - 列に指定された種類のデータのみ、その列に格納することができる。
- SQLの体系
    - SELECT、UPDATE、DELETE、INSERTの4つの命令を利用する。
    - 各命令をどのように実行するかを指示する修飾が豊富に用意されており、組み合わせることによって多用な命令を実現できる。
    - 4つの命令は、操作内容から見た検索系と更新系、対象とするデータから見た既存系と新規系に分類することができる。
- 4大命令をスッキリ学ぶコツ
    - 4大命令の構造と修飾語の全体像をしっかり把握する。
    - 4大命令の2通りの分類方法を理解する。
    - 4大命令に共通するテーブル指定を先に書く。
### 2.9.2 この章でできるようになったこと
家計簿の内容を全て表示したい。
    
```sql
SELECT ＊ FROM 家計簿
```

2,000円より大きな金額を使った日を知りたい。

```sql
SELECT 日付 FROM 家計簿 WHERE 出金額 > 2000
```

3月1日に1,800円で映画を見た記録を追加したい。

```sql
INSERT INTO 家計簿
     VALUES ('2018-03-01', '娯楽費', '映画を見た’, 0, 1800)
```

3月1日の映画は1,500円の誤りだったので修正したい。

```sql
RPDATE 家計簿 SET 出金額 ＝ 1500 WHERE 日付 ＝ '2018-03-01'
```

全データを消去したい

```sql
DELETE FROM 家計簿
```

</details>

# 第3章 操作する行の絞り込み
SQLを用いて思いどおりにデータを操るには、「どの行を対象として、どのように操作するか」をDBMSに的確に伝えなければなりません。

特にWHERE句による対象行の指定は、SQL記述のキーポイントといえるでしょう。

この章では、WHERE句と絞り込み条件に関するさまざまな文法を学びます。

データベースにおけるより高度で複雑な処理が可能になり、SQLがいっそう楽しくなるでしょう。

<details><summary>3.1 WHERE句による絞り込み</summary>

### 3.1.1 WHERE句の大切さ
SQL文の中でWHEREを使うことで、処理対象となる行の絞り込みができます。WHEREキーワードから始まる一連の記述をWHERE句といいます。

SQLを学び始めて間もない頃は、WHERE句のことをSELECTやDELETEのちょっとした付属品のように思いがちです。

- SQLの言語としての特徴
    - 命令自体は単純で、数も少ない(主に使うものは4つ)。
    - しかし、さまざまな修飾語を付けることで、複雑な処理が可能になる。
    
    修飾語のうち最もよく使われるものが、WHERE句です。データを検索、更新、削除など多くの場合、WHERE句を用いて「テーブルのどの行を処理したいのか」を指定します。むしろ、WHERE句が伴わないSQL文を使うことの方が少ないでしょう。なぜなら、テーブル内のすべての行を更新したり削除したりする機会はあまりないからです。
    
    私たちはWHERE句を自由自在に使えてはじめて、データを自由自在に操作することができるのです。


### 3.1.2 WHERE句の基本
WHERE句に関して、3つの基本。
- WHERE句の基本
    1. 処理対象行の絞り込みに用いる→WHEREを指定しないと「すべての行」が処理対象になる。
    2. SELECT、UPDATE、DELETE分で使用可能→INSERT文では使用できない。
    3. WHEREの後ろには条件式を記述する→絞り込み条件に沿った「正しい条件式」を記述する。
    
    1と2については第2章で紹介しました。残る3については、WHERE句の基本構文をしっかり押さえることが大切です。
    
- WHERE句の基本構文
    
    ```sql
    WHERE 条件式
    ```
    
    ただし、WHEREの後ろにはどんな式でも書けるというわけではありません。たとえば、「出金額 < 10000」のような式を記述することができますが、「出金額 + 10000」のような計算式は書くことができません。WHEREの後ろに記述できるのは、条件式と呼ばれる式だけです。</details>


<details><summary>3.2 条件式</summary>

### 3.2.1 真と偽
条件式とは、その結果が必ず真(TRUE)か偽(FALSE)になる式のことです。私たちの日常生活における「YesとNo」のようなものと考えても差し支えありません。

たとえば、「出金額 < 10000」という式は、出金額という列に格納されている値が10000未満の場合は式の意味が正しいので真、10000以上の場合は式の意味が正しくないため偽と判定できます。

では、「出金額 + 10000」という式ではどうでしょうか。

出金額はふつう数字の値です。仮に5000だとすると、「出金額 + 10000」という式の結果も15000という数値になります。結果が数値や文字列、日付などになる式は、WHERE句に記述することはできません。

- WHERE句に書けるもの
    
    結果が必ず真(TRUE)または偽(FALSE)となる条件式


### 3.2.2 WHERE句のしくみ
DBMSがどのようにWHJERE句を処理するか、その仕組みを見てみましょう。

一円以上の出金のあった行をすべて削除するDELETE文

```sql
DELETE FROM 家計簿 WHERE 出金額 > 0
```

**1行ずつ順番に、条件に合うかどうかをチェックするために、「真か偽になる式」しか書いてはいけない。**

WHERE句を含むSQL文を受け取ったDBMSは、テーブル中のすべての行について条件式が真になるかをそれぞれ調べます。そして、真になった行についてのみ、SELECTやUPDATE、DELETEなどの処理を行うのです。</details>


<details><summary>3.3 さまざまな比較演算子</summary>

### 3.3.1 基本的な比較演算子
条件式は、「＝」(等号)や「<」(不等号)のような記号を含んだ式になることがほとんどです。これらの記号は比較演算子といい、その記号の左右にある値を比較して、記号の意味が正しければ真(TRUE)、正しくなければ偽(FALSE)に「化ける」役割を持っています。本書では、SQLの実行によって演算子などが別の値に変化することを「化ける」と表現することにします。

```sql
出金額(3000) > 0 # TRUE
出金額(3000) = 0 # FALSE
```

SQLで利用される比較演算子には他にもたくさんのしゅるいがあります。なかでも次に挙げる6つは最も基本的な比較演算子です。

### 3.3.2 NULLの判定
- NULLとは
    - そこに何も格納されていない、未定義であることを表す。
    - 数字のゼロや空白文字とも異なる。
    
    次の家計簿テーブルは金額がゼロだった箇所がNULLになっています。つまり、0という値すら入っていない空欄の状態になっていることを表しています。
    
    たとえば、入金額が「0」の場合と「NULL」の場合では、意味が異なります。
    
    - 入金額が「0」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金し、0円入金した。
        
    - 入金額が「NULL」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金した。
        
    
    0という値が入金額として記入されているということは、「0円だけれども入金があった」という意味です。一方、NULLとは何もないこと、未定義であることを意味するのですから、入金が発生しなかった、または不明なことを表します。
    
    NULLかどうかを判定するには、=演算子や<>演算子は利用できません。たとえば「SELECT ＊ FROM 家計簿 WHERE 出金額 = NULL」という記述は、正しく判定されません。
    
    列の値がNULLであることを判定するためには`IS NULL 演算子`、NULLでないことを判定するためには`IS NOT NULL 演算子`を使います。
    
- NULLの判定
    - NULLであることを判定する。
    
    ```sql
    式 IS NULL
    ```
    
    - NULLでないことを判定する。
    
    ```sql
    式 IS NOT NULL
    ```
    
    正しいNULLの判定方法
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額　IS NULL
    ```
    
    NULLであるかの判定をすべきところに通常の比較演算子を使ってしまうという誤りは、SQLを学び始めて間もない頃によく犯してしまう代表的なミスです。はじめのうちは、意識して注意するようにしましょう。
    
- NULLは＝で判定できない！
    
    NULLは「＝」や「<>」では判定できない。必ずIS NULLやIS NOT NULLを使って条件式を作ること。
    
- 比較演算子の＝でNULLかどうかを判定してはいけない理由—3値論理
    
    ＝などの比較演算子ではNULLの判定ができない理由が気になるという人のために、少し踏み込んで仕組みを紹介しましょう。
    
    この章では、条件式の結果は常に真(TRUE)か偽(FALSE)になると説明しました。しかしSQLの条件式は、これら2つ以外にも、UNKNOWN(不明、計算不能)という3つ目の結果を持つ3値論理と呼ばれる仕組みを採用しています。このUNKNOWNについて、次の2つのことを理解すると、きっと謎が解けるでしょう。
    
    1. ＝や<>などの通常の比較演算子は、もともと値と値を比較するためのもの。よって、「値ではないNULL」を比較すると、不明な結果であるUNKNOWNになる。
    2. WHERE句による絞り込みは、条件式が真(TRUE)となる行だけが選ばれる。条件式が偽(FALSE)やUNKNOWNとなる行は処理対象にならない。


### 3.3.3 LIKE演算子
文字列があるパターンに合致しているかをチェックすることをパターンマッチングといいます。SQLではこのパターンマッチングにLIKE演算子を使います。パターンマッチングを行うと、部分一致の検索(〇〇○という文字列を一部に含むか？という判定)が簡単にできます。
- LIKE演算子によるパターンマッチング
    
    ```sql
    式 LIKE パターン文字列
    ```
    
    パターン文字列に使用できる文字には、主に次のようなものがあります。
    
    | パターン文字 | 意味 |
    | --- | --- |
    | % | 任意の0文字以上の文字列 |
    | _(アンダースコア) | 任意の1文字 |
    
    1月に関連する行を取得するSELECT文
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ LIKE '%1月%' # 1月の前後に任意の0文字以上の文字列が付いてもよい
    ```
    
    結果表
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-10 | 給料 | 1月の給料 | 280000 | 0 |
    | 2018-02-18 | 水道光熱費 | 1月の電気代 | 0 | 7560 |
    
    「％」は0文字以上の任意の文字列を意味する記号ですから、「**％1月％**」は1月の前後に0文字以上の文字が付いていてもよいこと、つまり1月という文字を含む文字列であることを意味します。
    
    同様に、「**％1月**」は、1月という文字で終わる文字列であることを意味し、「**1月_**」は「1月で始まり、その後ろに任意の1文字がある文字列」という意味になります。


### 3.3.4 BETWEEN 演算子
BETWEEN演算子は、ある範囲内に値が収まっているかを判定します。
- BETWEEN演算子による範囲判定
    
    ```sql
    式 BETWEEN 値1 AND 値2
    ```
    
- ％や_を含む文字列をLIKEで探したい
    
    「100％」という文字で終わるかを判定したい場合のように、％や_の文字そのものを含む文字列を部分一致検索したい時には、少し工夫が必要です。なぜなら、次のようにそのまま記述すると、％は特殊な意味の文字として扱われてしまうからです。
    
    ```sql
    /* 「100を含む文字列」という意味になる */
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100'
    ```
    
    パターン文字列の中で、単なる文字として％や_を使いたい場合、次のようにESCAPE句を併用した記述を行います。
    
    ```sql
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100$%' ESCAPE '$'
    ```
    
    ESCAPE句で指定した文字(上の行では$)はエスケープ文字といい、パターン文字列において特殊な取り扱いがされるようになります。この例では、今回のエスケープ文字$に続く%や_は、ただの文字として扱われます。
    
    BETWEEN演算子では、値が「値1以上かつ値2以下」の場合に真になります。値がちょうど値1や値2の場合も真になる点に注意してください。
    
    たとえば、出金額の列が100以上3000以下の範囲になる行のみを検索するには、次のようなSQL文を記述します。
    
    100〜3,000円の出費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額 BETWEEN 100 AND 3000
    ```
    
    ※次節に登場する論理演算子ANDでも同じ判定が可能。状況にもよるが、BETWEENのほうが処理性能が悪いことがあるから注意すること。


### 3.3.5 IN/NOT IN演算子
IN演算子は、値が括弧内に列挙した複数の値の(値リスト)のいずれかに合致するかを判定する演算子です。＝演算子では、1つの値との比較しかできませんが、IN演算子を使えば、一度にたくさんの値との比較が可能です。
- IN演算子による複数値との比較
    
    ```sql
    式 IN (値1, 値2, 値3...)
    ```
    
    食費・交通費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 IN ('食費', '交際費') # 値リスト
    ```
    
    逆に、括弧内に列挙した値のどれとも合致しないことを判定するには、NOT IN演算子を使います。次のリストは、費目の列が「食費」でも「交通費」でもない行が抽出対象となります。
    
    食費でも交際費でもない行を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 NOT IN ('食費', '交際費')
    ```


### 3.3.6 ANY/ALL演算子
IN演算子では、ある値が複数の値のどれかと等しいかを判定することができました。もし、複数の値と代償を比較したい場合には、ANY演算子やALL演算子を利用することができます。

ANYやALLは、必ずその直前に比較演算子をつけて利用します。これにより複数の値との比較を一度に行うことができます。

ただし、DBMSによっては、「副問い合わせ」でしか使えないことがあります。
- ANY/ALL演算子による複数値との比較
    - 値リストのそれぞれと比較して、いずれかが真なら真
    
    ```sql
    式 基本比較演算子 ANY (値1, 値2, 値3...)
    ```
    
    - 値リストのそれぞれと比較して、すべて真なら真
    
    ```sql
    式 基本比較演算子 ALL (値1, 値2, 値3...)
    ```
    
    ※基本比較演算子とは、「＝」「<」「<>」などの6つの演算子のこと
    
    - IN演算子の場合……出金額が値リストの中の**「どれか」**と**「一致」**するなら真。
        - 出金額(3000) IN (1000, 2000, 3000)
            - 出金額(3000)はINの右辺の3000と一致するので式の値は真
    - < ANY演算子の場合……出金額が値リストの中の**「どれか」**より**「小さい」**なら真。
        - 出金額(2500) < ANY (1000, 2000, 3000)
            - 出金額(2500)はANYの右辺の3000より小さいので式の値は真。
    - < ALL演算子の場合……出金額が値リストの中の**「すべて」**より**「小さい」**なら真。
        - 出金額(1000) < ALL (1000, 2000, 3000)
            - 出金額(1000)はANYの右辺の2000と3000より小さいが、1000より小さくないので式の値は偽。
    
    ANYやALLの例を冷静に見てみると、わざわざANYを使って「1000と2000と3000のどれかより小さい」という複雑な条件を書かなくても、はじめから「出金額 < 3000」と書けばよいのです。
    
    ANYやALLといった演算子は、単体で利用してもあまりメリットはなく、**「式」や「副問い合わせ」などの道具と組み合わせて初めて、その真価を発揮**します。**まずはANYやALLの構文と仕組みをしっかりマスター**しておいてください。</details>


<details><summary>3.4 複数の条件式を組み合わせる</summary>

### 3.4.1 論理演算子
WHERE句に条件式を使用することは前節で解説した通りです。しかし1つの条件式ではうまく行を絞り込めない場合、論理演算子を用いて、複数の条件式を組み合わせることができます。

代表的な論理演算子には、AND演算子とOR演算子があります。
- AND演算子とOR演算子
    - 2つの条件式の両方が真の場合だけ、真となる(AかつB)。
    
    ```sql
    条件式1 AND 条件式2
    ```
    
    - 2つの条件式のどちらかが真ならば、真となる(AまたはB)。
    
    ```sql
    条件式1 OR 条件式2
    ```
    
    2つの条件式を組み合わせたWHERE句
    
    ```sql
    UPDATE 湊くんの買い物リスト
       SET 価格 = 6200
     WHERE 名称 = 'スッキリ勇者クエスト'
       AND 販売店 = 'B'
    ```
    
    ANDとORは、両辺に条件式を必要とする演算子です。一方、右辺しか必要としないNOT演算子も存在します。NOTを記述すると、右辺の条件式の結果は、真は偽に、偽は真に逆転します。
    
- NOT演算子による真偽値の逆転
    
    ```sql
    NOT 条件式
    ```
    
    たとえば、「WHERE NOT 販売店 = ‘B’」という記述で、「販売店がB以外の行」を取り出すことができます。


### 3.4.2 論理演算子の優先度
論理演算子で条件式を組み合わせる際は、演算子が評価される優先順位に注意を払う必要があります。複数の論理演算子が使われている場合では、(1)NOT、(2)AND、(3)ORの優先順位に従って処理されていきます。

特に、ANDとORの優先順位については注意が必要です。

たとえば、「販売店AかBで売っている、ゲームかDVD」を検索したいために、以下の内容を実行すると、意図に反して2行目以外のすべての行が返されてしまします。

複数の論理演算子を使ったSELECT文

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B'     /* 条件式2 */
   AND カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD'   /* 条件式4 */

SELECT * FROM 湊くんの買い物リスト  WHERE 販売店 = 'A' OR 販売店 = 'B' AND カテゴリ = 'ゲーム' OR カテゴリ = 'DVD' 
```

これはORよりもANDの優先順位が高いため、DBMSがまず条件式2と3を先に評価し、その結果と条件式1と4をORで評価してしまったからです。

このような場合は、条件式に括弧をつけることでその評価の優先順位を引き上げることができます。

複数の論理演算子を使ったSELECT文(条件式に括弧を付ける)

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE ( 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B' )    /* 条件式2 */
   AND ( カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD' )  /* 条件式4 */
```

DBMSは、括弧で括られた条件式1と2、3と4をそれぞれORで処理し、最後にその結果をANDで評価します。これで目的通り、上の結果表のように「販売店AかBで売っているゲームかDVD」の行を得ることができます。

- 括弧による優先順位の引き上げ
    
    条件式を括弧で括ると、評価の優先順位が引き上がる。</details>


<details><summary>3.5 主キーとその必要性</summary>


### 3.5.1 思いどおりに削除できない!?
| 日付 | 費目 | メモ | 入金額 | 出金額 |
| --- | --- | --- | --- | --- |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-06 | 教育娯楽費 | 月刊SQLを購入 | 0 | 1280 |
このテーブルの1行目だけを削除する方法を考えてみましょう。たとえば、「DELETE FROM 家計簿 WHERE 日付 = ‘2018-03-03’ AND 出金額 = 105」としても、1行目と2行目の両方が削除されてしまいます。

紙面では「上の行」「下の行」と記述できますが、データとしては1行目と2行目は全く同じものであり、区別する手段がありません。そして、行を区別できないということは、ある特定の行だけを指定して操作することができないことを意味します。

- 重複した行がもたらす問題
    
    完全に重複した行が存在すると、そのうちのある行だけを区別、識別することはできない。よって、ある行だけを操作することもできない。
    
    このような理由から、よほど特殊な状況を除いて、テーブルの中に重複した行が格納されるようなことは避けるべきとされています。今回の場合は、1日にまったく同じ内容の買い物を複数回するとどうしても重複した行を記録することになってしまうため、そもそもテーブルの構造自体に問題があるといえます。


### 3.5.2 特定の行を削除する方法
| 社員番号 | 年齢 | 性別 | 名前 |
| --- | --- | --- | --- |
| 2003031 | 45 | 1 | ヨシダ　シゲル |
| 2003032 | 45 | 1 | ヨシダ　シゲル |
| 2005011 | 31 | 1 | スガワラ　タクマ |
| 2012001 | 22 | 1 | ミナト　ユウスケ |
| 2012002 | 24 | 2 | アサカ　アユミ |
「ヨシダ　シゲル」さんという同姓同名で年齢も性別も同じ社員が2名在籍しています。しかし、次のようにして「上の行」のヨシダシゲルさんだけを削除することができます。

上のヨシダシゲルさんだけを削除する

```sql
DELETE FROM 社員
 WHERE 社員番号 = '2003031' /* 社員番号で対象行を特定 */
```

同姓同名にもかかわらず削除したい行を正しく識別することができたのはこのテーブルが「社員番号」という列を持っていたおかげです。加えて、この「社員番号」という情報が、次のような特殊な条件を満たすものであることも非常に重要です。

- 「社員番号」が備える特殊な性質
    - 社員番号を持たない社員は存在しない。
    - 同じ社員番号が、異なる社員に割り振られることはない。
    
    →「社員テーブルで行が重複することはあり得ない」
    
    社員テーブルにおける社員番号のように、「この値を指定することで、ある1行を完全に特定できる」という役割を担う列のことを、主キー(primary key)といいます。主キーとなる列は、次のような特性を持っています。
    
- 主キーとなる列が持つべき特性
    - 必ず何らかのデータが格納される(NULLではない)。
    - 他の行と値が重複しない。
    
    私たちがデータベースで情報を管理する場合、ある特定の行を削除したり更新したりすることは頻繁に発生します。従って、あらゆる行をいつでも自由にWHERE句で特定できるためにも、すべてのテーブルは主キーとなるような列を必ず持つべきなのです。


### 3.5.3 主キー列を作り出す
社員情報を管理するために社員テーブルを作ろうと考える過程で、「氏名」や「性別」などに加えて、「社員番号」という列を作ることも自然に思いつくでしょう。自然に登場し、主キーの役割を果たせるこの列は、自然キー(natural key)と呼ばれます。

一方、家計簿テーブルの場合、「日付」「出金額」「入金額」など思いつくままに列を作っていっても、主キーの役割を果たせる列が登場しません。このような場合は、特定の行を識別可能にするためだけに、主キーのための列を無理やり作ってしまうことが一般的です。家計簿テーブルの場合、「1回の入出金行為」それぞれに連番で番号を振り、「入出金ID」のような列として管理します。

それぞれの入出金行為ごとに番号を振って、管理する

- 朝チョコを買った行為
    - 入出金ID：102　出金￥105
- 夕方チョコを買った行為
    - 入出金ID：103　出金￥105
- 翌日給料をもらった行為
    - 入出金ID：104　入金￥250000

「入出金ID」列のように、管理目的のためだけに人為的に追加された列を、自然キーに対して人工キー(artificial key)や代替キー(surrogate key)といいます。


### 3.5.4 複数の列で行を意識する
これまで解説してきたように、「内容が重複する可能性がある列」は主キーとして利用することはできません。しかし、単独では重複の可能性がある列でも、複数を組み合わせれば重複する可能性が実質的になくなる場合があります。

図3-7の場合、氏名、住所、生年月日の3つの列を組み合わせれば主キーとして扱うことが可能です。このように、複数の列を1つの主キーとして扱うものを複合主キー(compound key)といいます。

※各列は、単独では重複する可能性があり「主キー」の役割を果たせない。そのため、複数の列で1つの主キーを構成する。
- 時刻情報を含む日付の判定
    
    DATE型を条件式に用いる場合は、時刻情報について注意が必要です。
    
    たとえば、2018年3月以前のデータを抽出するために、「日付 <= ‘2018-03-31’」とした場合、時刻を指定してないため、DBMS製品によっては「2018-03-31 00:00:00」と解釈する可能性があります。その結果、「2018-03-31 10:30:00」などのデータはこの条件には合致せず、正しい結果を得ることができません。そこで、このような落とし穴を回避するために、判定の基準となる日付の翌日より過去という条件(「日付 < ‘2018-04-01’」)を指定します。
    
    なお、本書ではDATE型には時刻情報が含まれないものとして記述しています。</details>


<details><summary>3.6 この章のまとめ</summary>

### 3.6.1 この章で学習した内容
- WHERE句
    - WHERE句に記述した条件式によって、対象データを絞り込むことができる。
    - WHERE句は、SELECT、UPDATE、DELETE文で使うことができる。
- 演算子
    - 条件式にはさまざまな演算子を記述できる。
        
        比較演算子：=,<,>,<=, >=,<>,IS NULL,LIKE,BETWEEN,IN,ANY,ALL
        
        論理演算子：AND,OR,NOT
        
    - 論理演算子は、NOT,AND,ORの順で優先度が高く、先に評価される。
- NULL
    - データが格納されておらず、未定義の状態を「NULLが格納されている」と表現する。
    - NULLを判定するための条件式では、IS NULLとIS NOT NULLを使用する。「＝NULL」では正しく判定できない。
- 主キー
    - 主キーによって、テーブル内の1つひとつのデータが識別可能になる。
    - 主キーとなる列には、重複しない値が必ず格納される必要がある。
    - 自然キーが存在しない場合は、人工キーを追加して識別可能にする。
    - 複数の列を組み合わせて複合主キーを構成し、行を識別するために用いることができる。


### 3.6.2 この章でできるようになったこと
3月1日に使った食費を知りたい。

```sql
SELECT * FROM 家計簿
 WHERE 日付 = '2018-03-01' AND = '食費'
```

支出に関係のない行を取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 出金額 IS NULL
```

メモに「購入」を含む支払いを調べたい。

```sql
SELECT * FROM 家計簿
 WHERE メモ LIKE '%購入%' AND 出金額 > 0
```

住居費(家賃、電気代、水道代の総称)に関わる支払いを調べたい

```sql
SELECT * FROM 家計簿
 WHERE 費目 IN ('家賃', '電気代', '水道代')
```

3月の行だけを取り出したい

```sql
SELECT * FROM 家計簿
 WHERE 日付 BETWEEN '2018-03-01' AND '2018-03-31'
```

</details>

# 第4章 検索結果の加工
SELECT文は基本的に、抽出の対象である選択列リスト、抽出元であるFROM句、抽出の条件であるWHERE句から成り立っています。

さらにSELECT文には、検索した結果を加工し、目的に合わせた形に整形する指示を加えることもできます。

この章ではSELECT文にスポットを当て、その多様な修飾方法を見ていきましょう。


<details><summary>4.1 検索結果の加工</summary>

### 4.1.1 SELECT文だけに可能な修飾
SQLの4大命令
| 命令 | 各命令で固有の部分 | 対象行の絞り込み | 検索結果の加工 |
| --- | --- | --- | --- |
| SELECT | 列名…FROM　テーブル名 | WHERE | その他修飾 |
| UPDATE | テーブル名　SET　列名　=　値… | WHERE |  |
| DELETE | FROM　テーブル名 | WHERE |  |
| INSERT | INTO　テーブル名(列名…)　VALUES(値…) |  |  |
前章では、INSERT文以外のSQLに共通して利用可能なWHERE句について学びました。そして第Ⅰ部最後のこの章では、さらにSELECT文にだけ付けることのできる修飾について紹介していきます。

SELECT文専用の修飾は、どれも「SELECT文によって得られた検索結果をさまざまな形に加工するためのもの」です。多くのDBMSでは、SELECTによる検索とともに加工も行われますが、2段階の処理を考えるとイメージしやすいでしょう。

- ステップ①：通常の検索実行
- ステップ②：検索結果を加工
    - 並び替えや、重複行の排除など

次節からは修飾の具体的な内容として、6つの修飾語を順に紹介していきます。

検索結果を加工する主なキーワード
| キーワード | 内容 | 解説 |
| --- | --- | --- |
| DISTINCT | 検索結果から重複行を除外する | 4.2 節 |
| ORDER BY | 検索結果の順序を並べ替える | 4.3 節 |
| OFFSET - FETCH | 検索結果から件数を限定して取得する | 4.4 節 |
| UNION | 検索結果に他の検索結果を足し合わせる | 4.5 節 |
| EXCEPT | 検索結果から他の検索結果を差し引く | 4.5 節 |
| INTERSECT | 検索結果と他の検索結果で重複する部分を取得する | 4.5 節 |
  </details>


<details><summary>4.2 DISTINCT — 重複行を除外する</summary>

### 4.2.1 値の一覧を得る
DISTINCTキーワードをSELECT分に付加すると、結果表の中で内容が重複している行があれば、その重複を取り除いてくれます。

重複行を除外する

```sql
SELECT DISTINCT 列名...
  FROM テーブル名
```

たとえば、家計簿テーブルから入金額の列のみを抽出する場合、DISTINCTを付けるか付けないかで検索結果が変わってきます。

リスト4-1 DISTINCTを使わないSELECT文

```sql
SELECT 入金額 FROM 家計簿
```

リスト4-2 DISTINCTを使ったSELECT文

```sql
SELECT DISTINCT 入金額
  FROM 家計簿
```

DISTINCTは、データの種類を取得したい場合に役立ちます。たとえば、家計簿テーブルの費目には、「食費」「水道光熱費」「給料」などの支出の記録が何度も登場することが考えられます。このとき、DISTINCTを使って重複を取り除くことで、どのような種類の支出があったかを、一覧で抽出することができます。

リスト4-3 費目一覧の取得

```sql
SELECT DISTINCT 費目 FROM 家計簿
```

- ステップ①：SELECT 費目
- ステップ②：DISTINCT

なお、このDISTINCT修飾は、他の修飾と異なり、SELECT文の最初に記述する必要がありますので注意してください。</details>


<details><summary>4.3 ORDER BY — 結果を並べ替える</summary>

### 4.3.1 並び替えの基本
SELECT文の最後にORDER BY 句を記述すると、指定した列の値を基準として検索結果を並べ替えて取得することができます。

検索結果を並べ替える

```sql
SELECT 列名... FROM テーブル名
 ORDER BY 列名 並び順

※並び順は、ASCまたはDESC(省略するとASCと同じ意味になる)。
```

ORDER BY句はSELECT文の最後に、並び替えの基準とする列名と並び順を指定します。並び順は、昇順にする場合はASC、降順にする場合はDESCを指定します。但し、ORDER BY句の初期値は昇順ですので、並び順の指定を省略すると、結果は昇順になります。

なお、ORDER BY句に文字列を指定すると、DBMSに設定された照合順序(文字コード順、アルファベット順など)を基準として並べ替えられます。

リスト4-4 出金額で昇順となるよう並べ替えて取得する

```sql
SELECT * FROM 家計簿
 ORDER BY 出金額
```

リスト4-5 日付で降順となるよう並べ替えて取得する

```sql
SELECT ※ FROM 家計簿
 ORDER BY 日付 DESC
```

お買い物サイトの「売れ筋ランキング」の表示も、内部ではORDER BYを使っている。

### 4.3.2 複数の列を基準にした並び替え
ORDER BY句による並び替えの際、複数の列をカンマで区切って指定することができます。このような指定を行うと、最初に指定された列で並べ替えて同じ値が複数行あれば、次に指定された列で並び替えが行われます。

たとえば、「原則として入金額の降順で並べ替える。入金額が等しい行については、さらに出金額の降順で並べ替える」という指定をするには、次のようなSQL文を記述します。

リスト 4-6 複数の列で並べ替える

```sql
SELECT * FROM 家計簿
 ORDER BY 入金額 DESC, 出金額 DESC
```

ORDER BY句では、並び替えの基準とする列を列名ではなく列番号で指定することも可能です。列番号とは、選択列リストにおける列の順番のことで、SELECT命令に記述した順に1から数えます。先程のリストを列番号で書き換えてみます。

リスト4-7 列番号を指定するORDER BY句

```sql
SELECT * FROM 家計簿
 ORDER BY 4 DESC, 5 DESC
# 結果表はリスト4-6と同じ
```

テーブルの前列を指定する「＊」を選択列リストに使った場合も、実際に取得の対象となる列に置き換えた列番号を指定します。

ORDER BY句における列指定に列番号を用いる場合、SELECT文の選択列リストの記述を修正すると並び替えの結果にも影響が及ぶ点には注意が必要です。

このような注意があることから、列番号指定を用いる機会はあまり多くはありません。</details>


<details><summary>4.4 OFFSET - FETCH —先頭から数行だけ取得する</summary>

### 4.4.1 OFFSET - FETCH句の利用
検索結果の全行ではなく、並べ替えた結果の一部だけを得られればよいケースもあります。そのような場合、ORDER BY句に続けてOFFSET - FETCH(オフセット-フェッチ)句を付けることによって簡単に実現できます。
- 先頭から数件だけを取得する
    
    ```sql
    SELECT 列名... FROM テーブル名
     ORDER BY 列名...
    OFFSET 先頭から除外する行数 ROWS
    (FETCH NEXT 取得行数 ROWS ONLY)
    # MySQL,MariaDB,SQLiteではサポートされない
    ```
    

OFFSET句には、先頭から除外したい行数を記述します。省略はできませんので、除外せずに1件目から取得したい場合には0を指定しましょう。

FETCH句には、取得したい行数を指定します。FETCH句を省略すると、該当するすべての行が抽出されます。

たとえば、結果の11〜15番目の行だけを取得したい場合は、OFFSET句に10、FETCH句に5を指定することになります。

リスト4-8 出金額の高い順に3件を取得する

```sql
SELECT 費目, 出金額 FROM 家計簿
 ORDER BY 出金額 DESC
OFFSET 0 ROWS
 FETCH NEXT 3 ROWS ONLY
```

リスト4-9 3番目に高い出金額だけを取得する

```sql
SELECT 費目, 出金額 FROM 家計簿
 ORDER BY 出金額 DESC
OFFSET 2 ROWS
 FETCH NEXT 1 ROWS ONLY
```

OFFSET - FETCH句はORDER BY句と併用されることが多い機能ですが、SQL Serverを除き、OFFSET - FETCH句だけでも使用することが可能です。但しその場合は、どのような並び順で帰ってくるかは実行してみるまでわかりません。

なお、OFFSET ~ FETCH句に対応していないDBMSも存在します。行を制限して取得する別の方法も紹介しておきます。これらはいずれもリスト4-8と同等の動きをします。

リスト4-10 取得行を限定するその他の方法

```sql
-- LIMITの利用
   (Db2,MySQL,MariaDB,PostgreSQL,SQLite,H2 Database)
SELECT 費目, 出金額 
  FROM 家計簿
 ORDER BY 出金額 DESC LIMIT 3 # 最後から3つ分の行を抽出
# OFFSETで読み飛ばす行数を指定することも可能
```

</details>


<details><summary>4.5 集合演算子</summary>

### 4.5.1 集合演算子とは
構造がよく似た複数のテーブルにSELECT分をそれぞれ送り、その結果を組み合わせたい場合は、集合演算子を活用することにより、1つのSQL文で目的を達成することができます。

集合演算とは、SELECT命令によって抽出した結果表を1つのデータの集合と捉え、その結果同士を足し合わせたり、共通部分を探したりといったさまざまな演算を行ってくれる仕組みです。SQLでは、3つの集合演算を利用することができます。
1. UNION - 和集合：2つの検索結果を足し合わせたもの
2. EXCEPT(MINUS) - 差集合：最初の検索結果から次の検索結果と重複する部分を取り除いたもの
3. INTERSECT - 積集合：2つの検索結果で重複するもの

**※Oracle DBではEXCEPTの代わりにMINUSを利用。MySQLではUNIONのみ使用可。**


### 4.5.2 UNION — 和集合を求める
UNION演算子は、最も代表的な集合演算子です。2つのSELECT文をUNIONで繋いで記述すると、それぞれの検索結果を足し合わせた結果(和集合)が返されます。
- 2つのSELECT文の結果を足し合わせる
    
    ```sql
    SELECT 文1
     UNION (ALL)
    SELECT 文2
    ```
    

また、UNIONにALLというキーワードを付加すると、和集合の結果に重複行があった場合に動作が違ってきます。UNIONでは重複行を1行にまとめるのに対し、UNION ALLでは重複行をすべてそのまま返します。

リスト4-11 和集合を取得する

```sql
SELECT 費目, 入金額, 出金額 FROM 家計簿
 UNION
SELECT 費目, 入金額, 出金額 FROM 家計簿アーカイブ
 ORDER BY 2, 3, 1
```

集合演算は、選択列リストに記述した列の組み合わせで計算されます。リスト4-11の例では、家計簿テーブルと家計簿アーカイブテーブルにあるすべての行が抽出され、1つの結果表として返ってきました。また、ALLキーワードがついていないため、重複した住居費などの行は、1行だけになっています。

- 集合演算子を使える条件
    
    SELECTの結果を集合演算子でまとめるときは、選択列リストの列数とそれぞれのデータ型が一致していなければならない。
    

つまり、列数とデータ型さえ一致していれば、まったく異なるテーブルや列でもひとまとめにして抽出することができます。

また、1つのテーブルに格納されたデータを複数の異なる条件で抽出したい場合にもUNIONは活用できます。それぞれのWHERE条件を記述したSELECT文を用意し、UNIONで1つのSQL文としてまとめることで、SQLの実行回数を抑えることが可能になります。

1つの集合演算子がまとめることのできる検索結果は2つだけですが、さらに別の集合演算子を記述することによって、3つ以上の検索結果について集合演算させることも可能です。その場合は、UNIONだけでなく、後述する他の種類の集合演算子を組み合わせることもできます。

なお、集合演算子を使ったSQL文でORDER BY句による並び替えをする場合には、次のことに注意してください。

- 集合演算子でORDER BY句を使う時の注意点
    - ORDER BY句は最後のSELECT文に記述する。
    - 列番号以外による指定(列名やASによる別名)の場合、1つめのSELECT文のものを指定する。
- 数が一致しないSELECT文を繋げるテクニック
    
    選択列リストの数が合わないSELECT文で、どうしても集合演算子を使いたい場合は、足りないほうの選択列リストにNULLを追加することで、数を一致させることができます。
    
- DBMSにとって並び替えは大仕事
    
    SELECT文の最後にくっつけるだけで検索結果を並べ替えてくれるORDER BY句はとても便利な機能です。しかし、この並び替えという処理は、DBMSにとってはかなり負荷のかかる作業であることをぜひ頭の片隅に置いておいてください。
    
    性能上のボトルネックになることを防ぐため、第Ⅲ部で紹介するインデックスの併用を推奨しますが、一時的に定量のメモリを消費する可能性もあります。
    
    また、DISTINCTやUNIONも内部的には並び替えを行っていることがあります。これも大量のメモリを消費する可能性があるため、乱用は控えましょう。</details>


<details><summary>4.6 この章のまとめ</summary>

### 4.6.1 この章で学習した内容
検索結果の加工
- SELECT文で取得したデータは、以下のようなさまざま形に加工できる。
- DBMSによって、使うことのできる機能やキーワードが異なる場合がある。

**集合演算子**

- 集合演算子は、複数のSELECT文の結果を使った演算ができる。
- UNIONは、和集合を求める。
- EXCEPT,MINUSは、差集合を求める。
- INTERSECTは、積集合を求める。


### 4.6.2 家計簿DBでできるようになったこと
- これまでに使った費目一覧を、重複を除外して作りたい。

```sql
SELECT DISTINCT 費目 FROM 家計簿
```

- 3月に使った金額を大きい順に取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 日付 >= '2018-03-01'
   AND 日付 <= '2018-03-31'
 ORDER BY 出金額 DESC
```

- これまでの給料を大きい順に5件だけ取り出したい。

```sql
SELECT * FROM 家計簿
 WHERE 費目 = '給料' ORDER BY 入金額 DESC
OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY # MySQLではOFFSET 0 ROWS LIMIT 5またはLIMIT 5
```

- 家計簿と、アーカイブにある2月のデータをまとめて日付順に取り出したい。

```sql
SELECT * FROM 家計簿
 UNION
SELECT * FROM 家計簿アーカイブ
 WHERE 日付 >= '2018-02-01'
   AND 日付 <= '2018-02-28'
 ORDER BY 1;
```

- 今月初めて発生した費目を知りたい。

```sql
SELECT 費目 FROM 家計簿
EXCEPT
SELECT 費目 FROM 家計簿アーカイブ
```

</details>

# 第5章 式と関数
SQLでできることは、単なるデータの出し入れだけではありません。式を用いることで、列の値やリテラルを使った四則演算を行うことができます。

また、渡された情報に基づき、あらかじめ準備されたさまざまな種類の処理を行ってくれる関数という仕組みもあります。

この章では、指揮や関数を用いてデータの計算や変換をするさまざまな方法について紹介します。

<details><summary>5.1 式と演算子</summary>

### 5.1.1 式の種類
第3章で「WHERE句には条件式を記述すること」を学びました。たとえば、WHEREに続けて記述する「**出金額 > 0**」のようなものが条件式であり、その結果は必ず真か偽になりました。

一方、「出金額 + 100」のような、結果が真や偽にならない式を本書では計算式と呼ぶことにします。計算式も、評価されると結果に「化ける」点では条件式と同じです。

最終的に具体的な値に化ける計算式は、「**出金額 + 50 > 100**」のように、条件式の一部として用いられることもあります。ほかにもSQL文の中のさまざまな場所で、値の代わりに自由に記述することができます。

### 5.1.2 選択列リストで計算式を使う
SELECT分において、SELECTのすぐ後ろに指定するのが選択列リストです。選択列リストは、結果表にどのような列を出力するかを指定する役割があります。列名のほかにも固定値や計算式を指定することも可能です。

- リスト5-1 選択列リストへのさまざまな指定

```sql
SELECT 出金額,               -- 列名での指定
       出金額 + 100,         -- 計算式での指定
       'SQL'                -- 固定値での指定
  FROM 家計簿
```

| 出金額 | 出金額 + 100 | ‘SQL’ |
| --- | --- | --- |
| 380 | 480 | SQL |
| 0 | 100 | SQL |
| 2800 | 2900 | SQL |
| 5000 | 5100 | SQL |
| 7560 | 7660 | SQL |

- 選択列リストへの指定と結果
    - 列名：列の内容がそのまま出力される
    - 計算式：計算式の評価結果が出力される
    - 固定値：固定値がそのまま出力される

選択列リストに計算式や固定値を使うと、その計算式などがそのまま結果表の列名になってしまいます。その場合は、第2章で紹介した列の別名(p055)を使うことで解決できます。

- リスト5-2 計算式に別名をつける

```sql
SELECT 出金額,
       出金額 + 100 AS 100円増しの出金額 # 列の別名を命名できる
  FROM 家計簿
```

**※選択列リストで計算式を使う場合は、必ずASを併用するようにするとわかりやすくて良い。**

### 5.1.3 データの代わりに計算式を使う
INSERTやUPDATEで具体的な値の代わりに式を指定する方法です。
- リスト5-3 INSERT文での計算式の利用

```sql
INSERT INTO 家計簿 (出金額)
     VALUES (1000 + 105) # 「1000 + 105」という計算式を指定している
# 直接「1105」を指定した場合と同じ結果になる
```

- リスト5-4 UPDATE文での計算式の利用(列を含む)

```sql
UPDATE 家計簿
   SET 出金額 = 出金額 + 100 # 現在の出金額を100円増加させる
```

### 5.1.4 式が評価される仕組み
- **混乱しやすい列指定の捉え方**
    - 式中の「出金額」とは、テーブル内の出金額の列を指している。
    - 出金額の列には、複数の値(0,7560,5000…)が入っている。
    - よって、「出金額 + 100」は、複数の値と100の足し算になる。
    - 複数の値と100を足すことなんてできないのでは？
    
    このように混乱しないために、次の原則をしっかり理解する必要があります。
    
- **DBMSによる処理の原則**
    
    DBMSは、テーブル内の各業を1つずつ順番に処理していく。式の評価なども、各行ごとに行われる。
    

たとえば、リスト5-4のUPDATE文も「1回の処理で出金額列がすべて書き換わる」と捉えるべきではありません。DBMSは、「1行に注目しては、出金額を計算して更新する」という処理を、行数分繰り返しているのです。

**※ある列の内容を一気に書き換えられるのではなく、1行ずつその列の値を計算している。**

つまり、DBMSが式を評価するときには、常にいずれか1行にだけ注目しているのです。今回の場合だと、DBMSは「注目している行の出金額 + 100」を何度も計算しているだけなのです。</details>


<details><summary>5.2 さまざまな演算子</summary>

### 5.2.1 基本的な算術演算子
「+」以外にも、SQLにはさまざまな演算子が用意されています。代表的なものをまとめました。
- 代表的な演算子

| 演算子 | 使い方 | 説明 |
| --- | --- | --- |
| + | 数値 + 数値 | 数値同士で足し算をする |
| + | 日付 + 数値 | 日付を指定日数だけ進める |
| - | 数値 - 数値 | 数値同士で引き算をする |
| - | 日付 - 数値 | 日付を指定日数だけ戻す |
| - | 日付 - 日付 | 日付の差の日数を得る |
| * | 数値 * 数値 | 数値同士で掛け算をする |
| / | 数値 / 数値 | 数値同士で割り算をする ※1 |
| || | 文字列 || 文字列 | 文字列を連結する ※2 |

※1：整数同士の場合は商が返される。

※2：DBMSによっては文字列連結の演算子として「||」ではなく「＋」が利用されることもある。

+演算子や-演算子は、数値の計算以外にも利用できます。日付の計算や、DBMSによっては文字列の連結ができることはぜひ覚えておきましょう。

### 5.2.2 CASE演算子 — 値を変換する
CASE演算子は、列の値や条件式を評価し、その結果に応じて好きな値に変換することができます。使い方は2通りあります。
- **CASE演算子の利用構文(1)**
    
    ```sql
    CASE 評価する列や式 WHEN 値1 THEN 値1のときに返す値
                     (WHEN 値2 THEN 値2のときに返す値)...
                     (ELSE デフォルト値)
     END
    ```
    
    リスト5-5では、CASEからENDまでの部分が1つの選択列であり、条件に応じた結果に化けることに注目してください。
    
    - リスト5-5 CASE演算子を使ったSELECT文(1)
    
    ```sql
    /* 費目の値に応じて変換する */
    SELECT 費目, 出金額,
           CASE 費目 WHEN '居住費' THEN '固定費'
                    WHEN '水道光熱費' THEN '固定費'
                    ELSE '変動費'
           END AS 出費の分類
      FROM 家計簿 WHERE 出金額 > 0
    ```
    
    | 費目 | 出金額 | 出費の分類 |
    | --- | --- | --- |
    | 食費 | 380 | 変動費 |
    | 教養娯楽費 | 2800 | 変動費 |
    | 交際費 | 5000 | 変動費 |
    | 水道光熱費 | 7560 | 固定費 |
    
    CASEには、もう1つ似た形の構文が用意されています。
    
- **CASE演算子の利用構文(2)**
    
    ```sql
    CASE WHEN 条件1　THEN 条件1のときに返す値
         (WHEN 条件2 THEN 条件2のときに返す値)...
         (ELSE デフォルト値)
     END
    ```
    
    CASEのすぐ後ろに列名や式を記述しません。その代わり、WHENの後ろには値ではなく条件式を記述します。
    
    - リスト5-6 CASE演算子を使ったSELECT文(2)
    
    ```sql
    /* 条件に応じた値に変換する */
    SELECT 費目, 入金額,
           CASE WHEN 入金額 < 5000 THEN 'お小遣い'
                WHEN 入金額 < 100000 THEN '一時収入'
                WHEN 入金額 < 300000 THEN '給料出たー！'
                ELSE '想定外の収入です！'
           END AS 収入の分類
      FROM 家計簿
     WHERE 入金額 > 0
    ```
    
    | 費目 | 入金額 | 収入の分類 |
    | --- | --- | --- |
    | 給料 | 280000 | 給料出たー！ |

</details>


<details><summary>5.3 さまざまな関数</summary>
 
### 5.3.1 関数とは
    
関数を使えば、四則演算だけでなくもっと高度で複雑なことができます。

多くのデータベースには、より高度な処理を行いやすくするために関数と総称される命令がたくさん準備されています。

すべての関数は「呼び出し時に指定した情報(引数)に対して、定められた処理を行い、結果(戻り値)に変換する」という動作をします。たとえば、LENGTHという命令は、ある文字列をその文字列の長さ(文字数など)に変換する機能を持っています。
    
### 5.3.2 関数の使い方
    
すべての関数には、次の3つのことが定められています。

- **関数について定められていること**

 名前：その関数の名前

 引数：その関数を呼び出す際に引き渡す情報(関数によっては2つ以上の場合もある)

 戻り値：その関数の呼び出し結果として得られる情報


使いたいと思う関数を見つけたら、これら3つの事柄を確認することが重要です。たとえば、既に紹介したLENGTH関数については、次にように定められています。

- **LENGTH関数の仕様**
        
 名前：LENGTH

 引数：文字列が格納された列(または式)

 戻り値：文字列の長さを表す数値


関数を呼び出すには、SQL文の中で次のような構文に従って記述します。
    
- **関数の呼び出し**

 ```sql
 関数の名前(引数...)
 ```

- リスト5-7 メモとメモの長さを併せて表示させる

 ```sql
 SELECT メモ, LENGTH(メモ) AS メモの長さ
   FROM 家計簿
 ```
        
 | メモ | メモの長さ |
 | --- | --- |
 | コーヒーを購入 | 7 |
 | 1月の給料 | 5 |
 | 書籍を購入 | 5 |
 | 同期会の会費 | 6 |
 | 1月の電気代 | 6 |

 この例で使用している関数LENGTHは、受け取った引数の文字数を戻り値としてかえしています。本書では、以後、関数の機能を次のように表記します。

 - **本書における関数の表記(凡例)**

     ```sql
     関数名(引数) => 戻り値
     ```
            
        
 尚、リスト5-7は選択列リストにおける関数を利用した例ですが、ほかにもWHERE句の条件式の一部など、関数はさまざまな場所で利用することができます。
        
### 5.3.3 関数が動作する流れ

関数を自由自在に使いこなすためには、関数の呼び出しがどのように処理されていくかをしっかりと理解しておく必要があります。

まず重要なのが、式の評価と同様に、関数の呼び出しも各行ごとに繰り返し行われているという点です。「LENGTH(メモ)」という呼び出しは、複数の値を一度に処理するのではなく、1行ずつ繰り返し調べます。

次に重要なのが、関数の呼び出しの記述は、呼び出し完了後に戻り値に「化ける」ことです。この特性を利用して、関数の呼び出しを入れ子にすることもできます。
    
### 5.3.4 関数にまつわる注意点
    
関数はDBMS製品ごとの違いが大きく互換性が少ない分野です。

そこで次節からは、多くのDBMSで共通して利用できる代表的な関数を紹介します。本書で紹介する以外にどのような関数が利用できるか、より厳密な文法はどのようになっているかなどは、本書の付録Aや、各DBMS製品のマニュアルを確認するようにしてください。

- **関数はDBMSによって大きく異なる**

 関数については、DBMS製品によって構文が大きく異なるため、詳細は製品マニュアルを参照する必要がある。

- **ユーザー定義関数とストアドプロシージャ**

 あらかじめ用意された関数だけでなく、必要とする処理を自分で記述して作成した関数をSQL文から利用することができます。これをユーザー定義関数と呼びます。また、実行する複数のSQL文をまとめ、プログラムのようなものとしてDBMS内に保存し、データベースの外部から呼び出すものをストアドプロシージャといいます。

 ユーザー定義関数やストアドプロシージャは、DBMS製品ごとに定められたプログラミング言語を使って記述します。たとえば、Oracle DBではPL/SQL、SQL ServerではTransact-SQLという専用言語を用います。また、CやJavaのような一般的なプログラミング言語による記述をサポートしているDBMS製品も存在します。

 多数のSQL文からなる処理を1つのストアドプロシージャにまとめることで、データベースとアプリケーション間のやり取りを少なくし、ネットワークの負荷を軽減できるといったメリットがあります。</details>


<details><summary>5.4 文字列にまつわる関数</summary>

### 5.4.1 LENGTH/LEN — 長さを得る
LENGTH関数は、文字列の長さを調べてくれる関数です。SQL Serverでは、LENGTHの代わりにLEN関数を利用します。テーブルの列に格納されている文字列の長さを取得したり、文字列の長さで絞り込み検索を行いたい場合に利用します。
- **文字列の長さを得る関数**
    
    ```sql
    LENGTH(文字列の表す列) → 文字列の長さを表す数値
    LEN(文字列の表す列) → 文字列の長さを表す数値
    # DBMS製品によって、結果は文字数かバイト数になる
    ```
    
    たとえば、10文字または10バイト以下のメモだけを取得するSQL文は次のリストのようになります。
    
    - リスト5-8 10文字(10バイト)以下のメモだけを取得する
        
        ```sql
        SELECT メモ, LENGTH(メモ)　AS　メモの長さ FROM 家計簿 # 家計簿テーブルから列メモを抽出、さらにLENGTH関数で抽出した列メモの列の名前を「メモの長さ」とする
         WHERE LINGTH(メモ) <= 10 # 列メモから10文字以下のメモを抽出する
        ```
        
### 5.4.2 TRIM — 空白を除去する
ある文字列の前後についている、余計な空白を除去したい場合に便利な関数がTRIM関数です。類似する機能を持つLTRIM関数やRTRIM関数と合わせて覚えておきましょう。
- **空白を除去する関数**
    
    ```sql
    TRIM(文字列を表す列) → 左右から空白を除去した文字列
    LTRIM(文字列を表す列) → 左側の空白を除去した文字列
    RTRIM(文字列を表す列) → 右側の空白を除去した文字列
    ```
    
    たとえばCHAR(10)型の列に対して'abc’という文字列を格納すると、7文字文の空白が右側に自動的に追加され’abc       ‘という文字列として格納されることは第2章で学びました(p049)。そのような文字列をSELECT文でそのまま抽出すると、abcの後ろに空白がついた状態で取得してしまいます。
    
    このような場合に、TRIM関数を使うことで、余計な空白を簡単に削除することができます。
    
    - リスト5-9 空白を除去したメモを取得する
    
    ```sql
    SELECT メモ, TRIM(メモ) AS 空白除去したメモ # 列メモを抽出、さらにTRIM関数でメモを取得し、「空白除去したメモ」と列名を命名
      FROM 家計簿 # 家計簿テーブルから
    ```
    
### 5.4.3 REPLACE — 指定文字を置換する
REPLACE関数は、文字列の一部を別の文字列に置換する関数です。たとえば、文字列「axxle」の「x」を「p」に置換し、「apple」とすることができます。
- **文字列を置換する関数**
    
    ```sql
    REPLACE(置換対象の文字列, 置換前の部分文字列, 置換後の部分文字列) → 置換処理された後の文字列
    ```
    
    次のリストは、メモ列に入っている「購入」という文字列をすべて「買った」に置き換えるUPDATE文です。
    
    - リスト5-10 メモの一部を置換する
    
    ```sql
    UPDATE 家計簿 # 家計簿テーブルをアップデート
       SET メモ = REPLACE(メモ, '購入', '買った') # メモ列を選択、メモ列内にある文字列「購入」を文字列「買った」に置換する
    ```
    
### 5.4.4 SUMSTRING/SUBSTR — 一部を抽出する
文字列の一部分だけを取り出したい場合には、SUBSTRING関数またはSUBSTR関数を利用します。どちらを利用できるかは、DBMS製品によって異なりますが、「何文字目から何文字分」という指定をして文字列の一部文を抽出できる点では違いはありません。
- **文字列の一部を抽出する関数**
    
    ```sql
    SUBSTRING(文字列を表す列, 抽出を開始する位置, 抽出する文字の数) → 抽出された部分文字列
    SUBSTR(文字列を表す列, 抽出を開始する位置, 抽出する文字の数) → 抽出された部分文字列
    # 抽出する文字の数を省略し、文字列の最後までを抽出対象とする場合もある
    # DBMS製品によって、文字数指定かバイト数指定かは異なる。
    ```
    
    - リスト5-11 費目列の1~3文字目に「費」があるものだけを抽出する
    
    ```sql
    SELECT * FROM 家計簿 # 家計簿テーブルから全ての列を選択
     WHERE SUBSTRING(費目, 1, 3) LIKE '%費%' # 費目列の1~3文字目に「費」があるものだけを抽出する
    ```
    
### 5.4.5 CONCAT — 文字列を連結する
文字列を連結するには、通常、||演算子や+演算子を使いますが、環境によってはCONCAT関数を利用できます。連結できる文字列の数やNULLの扱いがDBMS製品によって異なりますので注意してください。
- **文字列を連結する関数**
    
    ```sql
    CONCAT(文字列, 文字列[, 文字列...]) → 連結後の文字列
    # SQL ServerやMySQLなどでは3つ以上の文字列を指定することが可能
    # 1つでもNULLの文字列があるとNULLを返すDBMS製品もある
    ```
    
    - リスト5-12 費目とメモを繋げて抽出する
    
    ```sql
    SELECT CONCAT(費目, ':' || メモ)　FROM　家計簿 # 家計簿テーブルから「費目」と「メモ」を繋げて、その間には「:」コロンを挿入する
    ```
</details>


<details><summary>5.5 数値にまつわる関数</summary>
                
### 5.5.1 ROUND — 指定桁で四捨五入
小数の取り扱いや金額計算などでよく見られる数値の丸め処理(四捨五入や切り上げ、切り捨て)も、関数で用意されています。ROUND関数は、指定した位置で四捨五入した結果を返す関数です。
- **指定桁で四捨五入する関数**
    
    ```sql
    ROUND(数値を表す列, 有効とする桁数) → 四捨五入した値
    # 「有効とする桁数」に指定する値が正の場合は小数部の桁数、負の場合は整数部の桁数を表す。
    ```
    
    - リスト5-13 百円単位の出金額を取得する
    
    ```sql
    SELECT 出金額, ROUND(出金額, -2) AS 百円単位の出金額 # 出金額列を選択、出金額の下2桁目が四捨五入され、「百円単位の出金額」という列名で表示される
      FROM 家計簿 # 家計簿テーブルから
    ```
    
### 5.5.2 TRUNC — 指定桁で切り捨てる
切り捨てをしたい場合は、TRUNC関数を使います。使い方はROUND関数と同じです。
- **指定桁で切り捨てる関数**
    
    ```sql
    TRUNC(数値を表す列, 有効とする桁数) → 切り捨てた値
    # 「有効とする桁数」に指定する値が正の場合は小数部の桁数、負の場合は整数部の桁数を表す
    ```
    
### 5.5.3 POWER — べき乗を計算する
ある値のべき乗(2乗や3乗など)を計算したい場合、*演算子でも実現可能ですが、POWER関数を用いると便利です。
- **べき乗を計算する関数**
    
    ```sql
    POWER(数値を表す列, 何乗するかを指定する数値) → 数値を指定した回数だけ乗じた結果
    ```
    
たとえば、「**POWER(出金額, 3)**」で、出金額を3乗した値(＝**出金額 * 出金額 * 出金額**)を得ることができます。</details>


<details><summary>5.6 日付にまつわる関数</summary>

### 5.6.1 CURRENT_DATE — 現在の日付を得る
プログラムからデータベースを書き換える際、更新した日付や時刻を列に記録しておくことがよくあります。

SQLで現在の日付を得るにはCURRENT_DATE関数、現在の時刻を得るにはCURRENT_TIME関数を用います。
- **現在の日時を得る関数**
    
    ```sql
    CURRENT_DATE → 現在の日付(YYYY-MM-DD)
    CURRENT_TIME → 現在の時刻(HH:MM:SS)
    # 引数が不要なため、関数名の後ろに()は付記しない
    ```
    
    - リスト5-14 日付を自動的に取得して登録する
    
    ```sql
    INSERT INTO 家計簿
    VALUES (CURRENT_DATE, '食費', 'ドーナツを買った', 0, 260)
    ```
    
CURRENT_DATEのほかにもDBMS製品ごとにさまざまな日付関数が用意されているので、利用する製品に応じて用途に合うものを選択してください。</details>


<details><summary>5.7 変換にまつわる関数</summary>

### 5.7.1 CAST — データ型を変換する
列やリテラルにはデータ型があることを第2章で紹介しました(p048)。INTEGER型の列に格納されている1000と、VARCHAR型の列に格納されている’1000’は、明確に異なるものでした。

しかし実際にデータベースを活用するようになると、ある型のデータを別の型として扱いたくなる場合があります。そのような場合に利用するのがCAST関数です。
- データ型を変換する関数
    
    ```sql
    CAST(変換する値 AS 変換する型) → 変換後の値
    ```
    

たとえば、出金額の列はINTEGER型ですが、末尾に「円」という文字列を連結して表示したい場合を考えましょう。「出金額 + ‘円’」としたいところですが、数値と文字列という型の異なる値を||演算子で連結するのは、定義されていない演算であり、DBMS製品によっては動作が異なる可能性があるため少し不安です。

そこで、「CAST(出金額 AS VARCGAR(20)) + ‘円’」のように、文字列型に型を揃えてから連結する方法が確実です。

※数値として解釈できない文字列をINTEGERに変換しようとするとエラーになるから注意。

### 5.7.2 COALESCE — 最初に登場するNULLでない値を返す
COALESCE関数は少し面白い動作をする関数です。
- **最初に登場するNULLでない値を返す関数**
    
    ```sql
    COALESCE(列や式1, 列や式2, 列や式3...) → 引数のうち、最初に現れたNULLでない引数
    # 引数は任意の数を指定可。但し、全ての引数は方が一致している必要がある
    # もしすべての引数がNULLの場合、戻り値はNULL
    ```
    
    COALESCE関数は、「複数の引数を受け取り、受け取った引数を左から順番にチェックし、その中から最初に見つかったNULLでない引数を返す」という動作をする関数です。たとえば、次の動作になります。
    
    - リスト5-15 COALESCE関数の基本動作
    
    ```sql
    SELECT COALESCE('A', 'B', 'C');      /* 結果は 'A' */
    SELECT COALESCE(NULL, 'B', 'C');     /* 結果は 'B' */
    SELECT COALESCE(NULL, 'B', NULL);    /* 結果は 'B' */
    SELECT COALESCE(NULL, NULL, 'C');    /* 結果は 'C' */
    SELECT COALESCE(数値型の列, 0);        /* 数値型の列が出力される。ただし、NULLが格納されている場合は0になる */
    ```
    
    これを使うと「NULLの場合の代替値」を簡単に決められる。
    
    たとえば、家計簿テーブルを単純にSELECTして、次のような結果を得られたとしましょう。
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-03 | 食費 | 自分へのご褒美 | 0 | 380 |
    | 2018-02-11 | 教養娯楽費 |  | 0 | 2800 |
    | 2018-02-14 | 交際費 |  | 0 | 5000 |
    
    2月11日と2月14日については、メモ列にNULLが格納されているため何も表示されません。少しわかりにくいですね。このような場合、COALESCE関数を用いた次のような検索を行えば結果表が見やすくなります。
    
    - リスト5-16 NULLを明示的に表示する
    
    ```sql
    SELECT 日付, 費目,
           COALESCE (メモ, '(メモはNULLです)') AS メモ, # 「AS メモ」にしないと列名が「coalesce」になる
           入金額, 出金額
      FROM 家計簿
    ```
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-03 | 食費 | 自分へのご褒美 | 0 | 380 |
    | 2018-02-11 | 教養娯楽費 | (メモはNULLです) | 0 | 2800 |
    | 2018-02-14 | 交際費 | (メモはNULLです) | 0 | 5000 |
    
    「もし、NULLの場合はこの値で代用してね」という使い方ができる。
    
- **SELECT文にFROM句がない!?**
    
    実は、FROM句を書かないことが許されている特別なSELECT文があるのです。
    
    SELECT文には必ずFROM句でどのテーブルからデータを持ってくるのかを指定する必要がありました。しかし、この第5章で紹介している計算式や関数は、リテラルなどの具体的な値を材料にすれば、テーブルの列を1つも記述していなくてもSELECT文として成り立ってしまうのです。
    
    これを利用して、まずは式や関数の動作確認だけをしたい場合、次のようなSELECT文を実行することができます。
    
    ```sql
    SELECT 式や関数
    ```

</details>


<details><summary>5.8 この章のまとめ</summary>

### 5.8.1 この章で学習した内容
- **計算式**
    - 列やリテラルを使った式で、結果が真または偽にならないものを計算式という。
    - 計算式を評価すると計算結果に化ける。
    - 計算式は、SELECT文の選択列リスト、INSERT文やUPDATE文での列に格納する値、その他の修飾句など、さまざまな場所で使用することができる。
- **計算式に用いる演算子**
    - 四則演算を行う演算子を算術演算子という。
    - ||や+で文字列の連結ができる。
    - CASE演算子は、列の値や条件式を評価して、任意の値に変換することができる。
- **関数**
    - 関数は、引数に対して決められた処理を行い、戻り値に変換する。
    - 処理の内容や戻り値に応じて、文字列関数、算術関数、日付関数、変換関数などに分類できる。
    - 関数は、DBMS製品位よる違いが大きい機能であるため、処理内容の確認が不可欠である。

### 5.8.2 この章でできるようになったこと
- 家計簿で入出金の差額も表示したい。

```sql
SELECT 日付, 費目, メモ, 入金額, 出金額,
       入金額 - 出金額 AS 入出金差額
  FROM 家計簿
```

- 8文字以上のメモは、「...」で末尾を省略したい。

```sql
SELECT 日付, 費目,
       CASE WHEN LENGTH(メモ) >= 8 THEN SUBSTRING(メモ,1,8) || '…'
            ELSE メモ
       END AS メモ, 入金額, 出金額
  FROM 家計簿
```

- 「1ドル=110円」と仮定して、入出金をドル表記(小数点以下切り捨て)したい。

```sql
SELECT 日付, TRUNC(入金額/110.0, 0) AS 入金ドル,
       TRUNC(出金額/110.0, 0) AS 出金ドル
  FROM 家計簿;
```

- 過って未来の日付で登録されている不正な行を探したい。

```sql
SELECT * FROM 家計簿
WHERE 日付 > CURRENT_DATE;
```

- 家計簿のメモを一覧表示したい。メモが未登録の行では代わりに費目を、費目も未登録の場合は'不明’と表示したい。

```sql
SELECT 日付, COALESCE(メモ, 費目, '不明') AS 備考 FROM 家計簿;
```

</details>


<details><summary>関数の多用で負荷増大？</summary>

関数はDBMSに複雑な処理をさせることができる便利な道具ですが、処理による負荷の増大には注意が必要です。複数の関数を複雑に組み合わせた場合はもちろん、関数を使うことによりインデックス検索が無効化された場合などは、レスポンスが悪化することもありますので、使用の前には十分な検証を行ってください。</details>
        
# 第6章 集計とグループ化
第5章では、検索結果のそれぞれの行に対して同じ計算や処理を行える仕組みとして、関数を紹介しました。

この第6章では、検索結果をひとまとめにして集計する方法を学びます。

集計を上手に活用できれば、単にデータを蓄積するだけでなく、蓄積したデータの分析や活用も可能になることを実感してください。

<details><summary>6.1 データを集計する</summary>

### 6.1.1 集計関数とは
集計処理は、次のようなSQL文で簡単に実現できます。
- リスト 6-1 出金額を集計する

```sql
SELECT SUM(出金額) AS 出金額の合計
  FROM 家計簿
```

| 出金額の合計 |
| --- |
| 15740 |

このSQL文で利用されている「SUM」は、検索結果のデータを集計する**集計関数**の1つです。ほかにも、最大値や平均値などを算出する集計関数も存在します。集計関数を使うと、SELECT文による検索結果が集計された形で出力されるようになります。

### 6.1.2 集計関数の特徴
集計関数は、集計の対象となったすべての行に対して1回だけ計算を行い、1つの答えを出します。必然的に、結果表は必ず1行になります。
- **集計関数の特徴**
    - 検索対象の全行をひとまとめに扱い、1回だけ集計処理を行う。
    - 集計関数の結果は、必ず1行になる。</details>


<details><summary>6.2 集計関数の使い方</summary>

### 6.2.1 代表的な集計関数
通常の関数と同様に、DBMS製品によって利用できる集計関数は異なります。しかしほとんどの製品に共通して利用可能なものが、5つの集計関数です。
- 代表的な集計関数

| 分類 | 関数名 | 説明 |
| --- | --- | --- |
| 集計 | SUM | 各行の値の合計を求める |
| 集計 | MAX | 各行の値の最大値を求める |
| 集計 | MIN | 各行の値の最小値を求める |
| 集計 | AVG | 各行の値の平均値を求める |
| 計数 | COUNT | 行数をカウントする |

5つの関数のうち、COUNT関数だけは他の4つと少し特性が異なります。

### 6.2.2 合計、最大、最小、平均を求める
検索結果のある列に対して、合計、最大値、最小値、平均値を求めたい場合、SUM(サム),MAX(マックス),MIN(ミニマム),AVG(アベレージ)関数を利用します。
- 合計、最大値、最小値、平均値を求める集計関数
    
    ```sql
    SUM(列) → 合計
    MAX(列) → 最大値
    MIN(列) → 最小値
    AVG(列) → 平均値
    ```
    
    これらの関数には引数として1つの列名を渡します。また、列名だけではなく「SUM(出金額 * 1.08)」のように、列名を含む式を指定することも可能です。
    
- リスト 6-2 さまざま集計をする
    
    ```sql
    SELECT
        SUM(出金額) AS 合計出金額,
        AVG(出金額) AS 平均出金額,
        MAX(出金額) AS 最も大きな散財,
        MIN(出金額) AS 最も少額の支払い
      FROM 家計簿
    ```
    
    | 合計出金額 | 平均出金額 | 最も大きな散財 | 最も少額の支払い |
    | --- | --- | --- | --- |
    | 15740 | 3148 | 7560 | 0 |

### 6.2.3 検索結果の行数を求める
COUNT関数は、検索結果の行数を教えてくれる集計関数です。この関数には2つの記述方法があります。
- 行数を数える集計関数
    
    ```sql
    COUNT(*)　→ 検索結果の行数
    COUNT(列) → 検索結果の指定列に関する行数
    ```
    
    単純に検索結果の行数を得るには、COUNT(*)という記述が便利です。COUNT関数はあくまでも該当した行数を取得する関数であり、検索結果の値自体が何であるかは問いません。
    
- リスト 6-3 食費の行数を数える
    
    ```sql
    SELECT COUNT(*) AS 食費の行数
      FROM 家計簿
     WHERE 費目 = '食費'
    ```
    
    | 食費の行数 |
    | --- |
    | 1 |
    
    COUNT(*)とCOUNT(列)は、ほぼ同様の動きをしますが、NULLの取り扱いが異なります。
- COUNT(*)とCOUNT(列)の違い
    - COUNT(*)は、単純に行数をカウントする(NULLの行も含める)。
    - COUNT(列)は、指定列の値がNULLである行を無視してカウントする。
- 重複した値を除いた集計
    
    AVG,SUM,COUNTの各関数では、「DISTINCT」を指定することによって、その列で重複している値を除いた状態で集計が行われます。
    
    ```sql
    SELECT COUNT(DISTINCT 費目) FROM 家計簿
    ```
    
    上記のSQL文では、家計簿テーブルに登録されている費目の種類数をカウントすることができます。</details>


<details><summary>6.3 集計に関する4つの注意点</summary>

### 6.3.1 SELECT文でしか利用できない
    
集計関数は、「SELECT文の選択列リスト部分」やORDER BY 句、HAVING 句の中で利用します。WHERE 句の中では利用できません。
    
| SELECT | 列名… ○(記述可能) | FROM テーブル名 × | WHERE ~ × | その他、修飾 △(ORDER BY句またはHAVING句でのみ記述可能) |
| --- | --- | --- | --- | --- |
    
また、「検索結果」に対して集計を行うための道具である集計関数は、UPDATE文、INSERT文、DELETE文で利用することはできません。
    
- 集計関数が記述できる場所
        
集計関数は、SELECT文の選択列リストかORDER BY句、HAVING句にのみ記述できる。
        
### 6.3.2 結果表がデコボコになってはならない
- リスト 6-4 日付と出金額合計を取得するつもりのSELECT文

    ```sql
    SELECT 日付, SUM(出金額) AS 出金額計 FROM 家計簿
    ```

    このSELECT文の結果表が、「日付」と「出金額計」という2つの列を持つことは明らかでしょう。しかし、行数については困ったことになります。

    - 日付の列　　　　→　通常の検索なので、複数行になるはず。
    - 出金額計の列　　→　集計関数の結果なので、1行になるはず。

    列ごとに行数が異なるため、表の形がデコボコになる。しかしデータベースでは、「デコボコ型」の結果表はそもそも認められていません。結果表は、常に列ごとの行数が一致するn行m列の長方形型でなければならないのです。もし結果表がデコボコ型になるようなSQL文を実行すると、実際にはエラーになります。
        
- SQLの結果表
    - 結果表は必ず長方形型になる。
    - 結果表がデコボコになるようなSQL文は実行できない(一部のDBMS製品ではNULLを補うなどして動作するものもあるが、非推奨)。

### 6.3.3 引数に許される型が異なる
    
紹介した5つの集計関数は、いずれも1つの列を引数として受け取り、集計を行います。しかし、引数にどのような方の列を指定できるかは、関数によって異なります。

- 集計関数に渡す引数の型と戻り値

| 関数名 | 数値型 | 文字列型 | 日付型 |
| --- | --- | --- | --- |
| SUM | 各数値の合計 | × | × |
| MAX | 各数値の最大 | 並び替えて最後の文字列 | 最も新しい日付 |
| MIN | 各数値の最小 | 並び替えて最初の文字列 | 最も古い日付 |
| AVG | 各数値の平均 | × | × |
| COUNT | 行数 | 行数 | 行数 |

文字列に対してMAX関数やMIN関数を用いた場合、DBMSが定める照合順序(文字コード順、アルファベット順など)で並べ替え、その最初や最後となる文字列が結果として得られます。
    
### 6.3.4 NULLの取り扱い
    
NULLを含む計算や比較は、基本的に結果もNULLとなることは第3章で紹介しました。しかし、集計関数の場合はそれぞれ取り扱いが異なります。

- 集計関数におけるNULLの取り扱い

| 集計関数 | 集計時のNULLの扱い | 全行がNULLの場合の集計結果 |
| --- | --- | --- |
| SUM | 無視(NULLは集計に影響を与えない) | NULL |
| MAX | 無視(NULLは集計に影響を与えない) | NULL |
| MIN | 無視(NULLは集計に影響を与えない) | NULL |
| AVG | 無視(NULLは集計に影響を与えない) | NULL |
| COUNT 列名指定 | 無視(NULLは集計に影響を与えない) | 0 |
| COUNT * 指定 | NULLを含んでカウントする | 該当行数 |

尚、NULLを0に読み替えて集計をしたい場合は、第5章で紹介したCOALESCE関数を使うと良いでしょう。

- リスト6-5 NULLをゼロとして平均を求める

```sql
/* NULLをゼロに変換した上で平均するサンプル */
SELECT AVG(COALESCE(出金額, 0)) AS 出金額の平均
  FROM 家計簿
```

| 出金額の平均 |
| --- |
| 3148.000000000000000000 |

</details>


<details><summary>6.4 データをグループに分ける</summary>

### 6.4.1 グループ別の集計
集計関数を用いると、検索結果をひとまとまりとして集計し、1つの結果を得ることができました。特に、どんなに多くの行を持つテーブルに対しても、集計を行って得られる結果表は1行になるのが特徴でした。

たとえば、「SELECT SUM(出金額) AS 出金額の合計 FROM 家計簿」というSQL文を使えば、次のような結果が簡単に得られました。

| 出金額の合計 |
| --- |
| 15740 |

しかし、これでは家計簿テーブルのすべての行を合計してしまいます。家計の見直しのためには、次のような「費目別の出金額集計表」を得られれば便利です。どうすればよいのでしょうか？

| 費目 | 費目別の出金額合計 |
| --- | --- |
| 食費 | 380 |
| 給料 | 0 |
| 教養娯楽費 | 2800 |
| 交際費 | 5000 |
| 水道光熱費 | 7560 |

「食費」や「給料」などのここの費目についてWHERE句で絞り込んで集計を繰り返す方法もあります。
- リスト6-6 SQL文をいくつも実行して、各費目の集計結果を得る方法

```sql
SELECT '食費' AS 費目, SUM(出金額) AS 費目別の出金額の合計
  FROM 家計簿
 WHERE 費目 = '食費';   /* ⇒ 「食費」「380」 */

SELECT '給料' AS 費目, SUM(出金額) AS 費目別の出金額の合計
  FROM 家計簿
 WHERE 費目 = '給料';   /* ⇒ 「給料」「0」 */

SELECT '教養娯楽費' AS 費目, SUM(出金額) AS 費目別の出金額の合計
  FROM 家計簿
 WHERE 費目 = '教養娯楽費';   /* ⇒ 「教養娯楽費」「2800」 */
```

### 6.4.2 グループ化
SQLには集計に先立って、指定した基準で検索結果をいくつかのまとまりに分けるグループ化と呼ばれる機能が備わっています。集計はグループごとに行われ、グループごとの集計結果が結果表の形で得られます。

たとえば、「費目別の出金額集計表(p183)」を得るには、家計簿テーブルの各行を「費目」列の内容で分類し、分類した費目ごとに出金額の合計を求めれば良いのです。
- リスト6-7 費目でグループ化してそれぞれの合計を求める

```sql
SELECT 費目, SUM(出金額) AS 費目別の出金額合計
  FROM 家計簿
 GROUP BY 費目 --費目列でグループ化する
```

- グループ化して集計する基本構文

```sql
SELECT グループ化の基準列名..., 集計関数
  FROM テーブル名
(WHERE 絞り込み条件)
 GROUP BY グループ化の基準列名...
```

### 6.4.3 グループ集計の流れ
グループ集計は3つのステップで実行されます。

1. もとの表に対してWHERE句による通常の検索処理が行われ、行が絞り込まれます。
2. 検索結果はGROUP BY句で指定された列に同じ値を持つ行ごとに分類されます。
3. 各グループに対して集計関数の処理が行われた後、SELECT句の選択列リストによって列が絞り込まれ、結果行となります。

最終的な結果表の行数は、グループの数(=GROUP BY句で指定した列に格納されている値の種類の数)と等しくなります。
- グループ化した集計関数のポイント
    - グループ化するには、GROUP BY句に基準となる列を指定する。
    - 集計関数は、データの値をグループごとにまとめて計算する。
    - 集計関数の結果表の行数は、必ずグループの数と一致する。

### 複数の列によるグループ化
本文では1つの列を基準にしてグループ化を行う例を紹介しました。しかし、GROUP BY句に複数の列をカンマで区切って指定することで、複数の列を基準にしたグループ化をすることもできます。

複数の列によるグループ化は、それらの列を組み合わせて、値が同じになるものを収集してグループが作られます。

### 6.4.4 グループ集計後の絞り込み
「費目別の出金額集計表」をもう一度確認してみます。出金額合計が0円の費目が含まれています。「給料」は出金額は発生する費目でなないので、本来、集計表に表示する必要のない費目です。

| 費目 | 費目別の出金額合計 |
| --- | --- |
| 食費 | 380 |
| 給料 | 0 |
| 教養娯楽費 | 2800 |
| 交際費 | 5000 |
| 水道光熱費 | 7560 |

- リスト6-8 集計結果から行を取り除くSQL文(エラーになる)
- 

```sql
SELECT 費目, SUM(出金額) AS 費目別の出金額計
  FROM 家計簿
 WHERE SUM(出金額) > 0  --出金額の合計が0 より大きい行だけを
 GROUP BY 費目          --表示したい
```

エラーになる理由は、WHERE句が処理される「検索」の時点では、「集計」で初めて計算される「SUM(出金額)」の部分が未確定だからです。

- 集計関数はWHERE句に利用できない
    
    WHERE句を処理する段階では、まだ集計が終わっていないため、集計関数はWHERE句に利用できない。
    

集計処理を行なった後の結果表に対して絞り込みを行いたい場合は、**HAVING句**を用います。

- グループ化してから絞り込む基本構文
    
    ```sql
    SELECT グループ化の基準列名..., 集計関数
      FROM テーブル名
    (WHERE もとの表に対する絞り込み条件)
     GROUP BY グループ化の基準列名...
    HAVING 集計結果に対する絞り込み条件
    ```
    

HAVING句に記述する条件式は、WHERE句のものと非常によく似ています。WHERE句と同じように、ANDやORの論理演算子で複数の条件式を組み合わせることもできます。しかし、両者は絞り込みを実行するタイミングに違いがあります。

- HAVING句は集計結果が全て揃った最後の段階で実行される。
- リスト6-9 集計結果で絞り込む

```sql
SELECT 費目, SUM(出金額) AS 費目別の出金額合計
  FROM 家計簿
 GROUP BY 費目
HAVING SUM(出金額) > 0 
```

| 費目 | 費目別の出金額合計 |
| --- | --- |
| 食費 | 380 |
| 教養娯楽費 | 2800 |
| 交際費 | 5000 |
| 水道光熱費 | 7560 |

- グループ集計と選択列リスト
    
    グループ集計を行うSELECT文の選択列リストに指定する列は、次のどちらかに当てはまるものでなければなりません。
    
    1. GROUP BYでグループ化の基準列として指定されている。
    2. 集計関数による集計の対象となっている。
    
    なぜなら、これらに当てはまらない列を抽出しようとすると、「デコボコな結果表」になってしまうからです。</details>


<details><summary>6.5 集計テーブルの活用</summary>

### 6.5.1 大量のデータ集計
集計関数は非常に便利な道具ですが、集計結果をはじき出すためにDBMSはたくさんの計算処理を行うことになります。数万件程度のデータなら一瞬で処理してくれるでしょう。

しかし、大手金融機関が管理する全口座の入出金情報となると、その行数は膨大なものになります。たとえば、2017年に入ってきたお金と出て行ったお金を明らかにするためのSQL文を実行するにしても、長い時間が掛かる恐れがあります。
- リスト6-10 2017年の入出金の合計を算出

```sql
/* 数千万行が該当するかもしれないSQL文 */
SELECT SUM(入金額) AS 入金額合計, SUM(出金額) AS 出金額合計
  FROM 口座入出金テーブル
 WHERE 日付 >= '2021-01-01' AND 日付 < '2022-01-01'
```

このような処理を、集計結果が必要となるたびに毎回実行して計算するのは非効率です。

### 6.5.2 集計テーブルの活用
非常に大量のデータを取り扱う場合、集計テーブルと呼ばれるテーブルを用いて、次のような工夫がなされることがあります。
- 集計テーブルの利用
    - あるテーブルの集計結果を格納するための別テーブル(集計テーブル)を作成する。
    - 集計関数を用いて集計処理を1回行い、結果を集計テーブルにINSERTする。
    - 集計結果が必要な場合は、すでに作った集計テーブルに格納されている計算済みの集計結果を利用する。

### 6.5.3 集計テーブルを更新する
集計テーブルに登録された計算済みの集計情報は、時間が経つにつれて内容が古くなっていきます。
- 集計テーブルを用いるリスク
    
    集計テーブルに格納されている結果は、最新の集計より古くなってしまう可能性がある。
    

そこで、通常はデータの性質に応じて毎日や毎月、毎年などの一定のタイミングで集計処理を再実行し、集計テーブルの内容を最新の状態に更新するという処理が行われます。

- 集計テーブルに不可欠な更新作業
    
集計テーブルの内容が古くならないように、定期的に再集計を行って内容を更新する作業が不可欠である。</details>


<details><summary>6.6 この章のまとめ</summary>

### 6.6.1 この章で学習した内容
- **集計**
    - SQLでは、集計関数を用いてデータを集計することができる。
    - 集計関数は、まとめたグループごとに1つの結果を算出する。
    - 集計関数はSELECT文でのみ使用できる。
- **グループ化**
    - GROUP BY句にグループ分けの基準となる列を指定することで、グループ別に集計を行うことができる。
    - GROUP BY句を用いない集計では、検索結果の全件を1つのグループとして扱う。
    - 集計値をもとにして特定のグループのみを抽出するには、HAVING句を用いる。
- **集計関数**
    - 主な集計関数
    
    | 関数名 | 集計の内容 | 集計できるデータ型 |
    | --- | --- | --- |
    | SUM | データを合計する | 数値 |
    | MAX | 最も大きい値を求める | 数値、日付、文字列 |
    | MIN | 最も小さい値を求める | 数値、日付、文字列 |
    | AVG | データを平均する | 数値 |
    | COUNT | 行数をカウントする | 全てのデータ型 |

### 6.6.2 この章でできるようになったこと
- 今月の収入と支出の合計額を知りたい。

```sql
SELECT SUM(入金額), SUM(支出額) FROM 家計簿;
```

- 今月の食費を支払った回数を知りたい。

```sql
SELECT COUNT(費目) AS 食費を支払った回数 FROM 家計簿
 WHERE 費目 = '食費';
```

- 先月までの水道光熱費で、最も高かった額と低かった額を知りたい。

```sql
SELECT MAX(出金額) AS 最高額, MIN(出金額) AS 最低額,
  FROM 家計簿アーカイブ,
 WHERE 費目 = '水道光熱費';
```

- 先月までの給料の平均額を知りたい。

```sql
SELECT AVG(入金額) AS 平均額
  FROM 家計簿アーカイブ
 WHERE 費目 = '給料';
```

- 先月までの費目ごとの出費額を知りたい。

```sql
SELECT 費目, SUM(出金額) AS 出金額
  FROM 家計簿アーカイブ
GROUP BY 費目;
```

- 今月の出費のうち、平均が5,000円以上の費目とその最大額を知りたい。

```sql
SELECT 費目, MAX(出金額) AS 最大出金額 FROM 家計簿
 WHERE 出金額 > 0
GROUP BY 費目
HAVING AVG(出金額) >= 5000;
```

### SELECT文の全貌
    
第6章でSELECT文に記述可能な部品を全て紹介することができました。構文を整理しておきましょう。

```sql
SELECT 選択列リスト
  FROM テーブル名
[WHERE 条件式]
[GROUP BY グループ化列名]
[HAVING 集計結果に対する条件式]
[ORDER BY 並び替え列名]
```

括弧で括られた修飾は任意で記述するものですが、それぞれを書ける場所は決まっています。特に、ORDER BY 句は他にどのような修飾を書いたとしても、必ず最後に記述する必要がありますので、注意してください。</details>


<details><summary>無駄な集計にご用心</summary>

- 次の例は、出費回数が5回以上の費目について、合計額と回数を求めるSQL文です。

```sql
SELECT 費目,
       SUM(出金額) AS 合計額,
       COUNT(出金額) AS 回数,
  FROM 家計簿
 WHERE 出金額 > 0
GROUP BY 費目
HAVING COUNT(出金額) >= 5
   AND 費目 IN ('食費', '居住費')  -- データ絞り込み条件
```

このSQL文は正しく動作します。しかしよく見ると、最後のANDで指定している費目の名称による絞り込みは、WHERE句に書いても同じ結果票になることが理解できるでしょう。絞り込むタイミングが違うだけだからです。

HAVING句ではなくWHERE句でこの絞り込みを行えば、DBMSが処理する行数が減るためSQLのパフォーマンスは向上します。集計の前に処理行数を減らせる場合は、WHERE句で早めに絞り込んでしまいましょう。</details>

# 第7章 副問い合わせ
SQLには、SQL文の内部に別のSELECT文を記述する、副問い合わせという昨日が備わっています。

この機能を使うことで、1つのSQL文で2つ以上の処理を作成することができます。

また、副問い合わせの構造を理解することは、SQLの作りそのものを理解することにも繋がります。

<details><summary>7.1 検索結果に基づいて表を操作する</summary>

### 7.1.1 2回のSELECTが必要な状況
自分が何に一番お金を使ったのかがすぐにわかるように、「最も大きな出費をしたときの費目と金額」を取得するSQL文を準備しました。- リスト7-1 最も大きな出費の費目と金額を求める

```sql
/* 出金額の最大値を取得して値を書き留めておく */
SELECT MAX(出金額) FROM 家計簿;    -- (1)
/* (1) で得た金額を条件式に記述して費目と金額を取得する */
SELECT 費目, 出金額 FROM 家計簿
 WHERE 出金額 = 【書き留めた額】;    -- (2)
```

もし「最も大きな出費をしたときの費目と金額」を得るためのSQL文を考えるとしたら、どのように組み立てていくでしょうか。

最終的には費目と出金額を知りたいわけですから、まずは「SELECT 費目, 出金額 FROM 家計簿 WHERE…」のように書き始めることでしょう。

しかし、WHERE句の続きを書こうとして、手が止まってしまうはずです。「出金額 = ???」という条件式の右辺に書くべき具体的な値は、実際に家計簿テーブルを調べてみなければわからないからです。そこで仕方なく、その部分を調べるリスト7-1の(1)のSQL文を先に実行するという方法にたどり着くでしょう。

このように「ひとまずSELECT文で何らかの検索結果を得て、得られた具体的な値を用いてさらにSELECTやUPDATEなどを実行する」ことは、データベースを利用する上でよくあることなのです。

### 7.1.2 SELECTをネストする
ひとまずSELECT分で何らかの検索結果を得て、得られた具体的な値を用いてさらにSELECTやUPDATEなどを実行したい場合、それを1つのSQL文で記述することができます。たとえばリスト7-1は、次のように書き換えることができます。
- リスト7-2 1つのSQLで最大の出費に関する費目と金額を求める

```sql
SELECT 費目, 出金額 FROM 家計簿
 WHERE 出金額 = (SELECT MAX(出金額) FROM 家計簿)
```

一般的に、あるものがその内側に別のものを内包している状態を**ネスト構造**や**入れ子**と呼びますが、リスト7-2もSQL文がネスト構造になっています。そして、(1)のSQL文のように、ほかのSQL分の一部分として登場するSELECT文のことを、**副問い合わせ**や**副照会**、または**サブクエリ**と呼びます。

- **副問い合わせとは**
    
    **他のSQL文の一部として登場するSELECT文。丸括弧で括って記述する。**
    

尚、SQLは内部に複数の副問い合わせを持つことや、副問い合わせの中にさらに別の副問い合わせを記述することも可能です。

- **2つの副問い合わせ**

```sql
UPDATE... (SELECT... )
   WHERE... (SELECT... )
```

- **副問い合わせの中に副問い合わせ**

```sql
UPDATE... (SELECT... 
             (SELECT... ))
```

### 7.1.3 副問い合わせを習得するコツ
副問い合わせを使うことによって、複雑で高度なSQL文を書くことが可能になります。書くときは、個々のSQL文を1つずつ作り、あとから組み立ててあげれば良いのです。
- **副問い合わせを習得するコツ**
    - **副問い合わせが処理される仕組みを理解しておく。**
    - **副問い合わせの代表的な3つのパターンを学んでおく。**
これらのコツを意識しておけば、必要に応じて複雑なSQL文を自分の手で組むことが必ずできるようになっていきます。そのためにも、まずは基本をしっかりと押さえておきましょう。

### 7.1.4 コツその1：副問い合わせが処理される仕組み
p206の図7-1が処理されていく家庭を例に取ると、まず副問い合わせのSQL(1)がDBMSによって処理され、具体的な値「7560」に置き換わっています。

副問い合わせを含むSQL文では、まず副問い合わせのSELECT文が実行され、その結果である具体的な値に「化ける」ことになります。その後、化けた値を当てはめて組み立てられた外側のSQL文が実行されていきます。
- **副問い合わせの動作**
    
    まず、内側にあるSELECT文が実行され結果に化ける。そして、外側のSQLが実行される。

### 7.1.5 コツその2：副問い合わせのパターン
副問い合わせで得られる検索結果について、考えてみましょう。副問い合わせの中身はSELECT文なので、得られる結果の形としては、図7-4の3種類が考えられます。
- 単一の値に化ける副問い合わせ

```sql
SELECT... (SELECT... )
↓
SELECT... 15700
```

- 列挙された複数値に化ける副問い合わせ

```sql
SELECT... (SELECT... )
↓
SELECT... 10
          20
          30
```

- 表形式の複数値に化ける副問い合わせ

```sql
SELECT... (SELECT... )
↓
SELECT... X 12  8
          Y  7 12
          Z  4 11
```

### **副問い合わせの3つのパターン**
データベースに限らず、ITの世界では、複数のデータ(値)をある構造に従ってひとかたまりに取り扱うことがよくあります。たとえば、「太陽系の惑星の名前」は、次のように複数の値が並べられた構造になります。

**‘水',’金',’地',’火',’木',’土',’天',’海’**

このように、1つ以上のデータで形成されたものをデータ構造(data structure)といいます。なかでも基本的なデータ構造が次の3つです。
- **スカラー**(単一の値) 例：「昨日の京都の最高気温」、「自分の誕生日」
- **ベクター**(1次元に並んだ値/配列) 例：「過去12ヶ月の京都の最高気温」、「太陽系の惑星の名前」
- **マトリックス**(2次元に並んだ値/表) 例：「過去12ヶ月の各地の最高気温」、「九九の計算結果」

副問い合わせの3つのパターンとは、検索結果がそれぞれスカラー、ベクター、マトリックスになると考えると理解しやすいでしょう。</details>


<details><summary>7.2 単一の値の代わりに副問い合わせを用いる</summary>

### 7.2.1 単一行副問い合わせ
**単一行副問い合わせ**とは、検索結果が1行1列の値となる副問い合わせを指します。この副問い合わせを実行した結果は、1つの値に化けると考えることもできます。

単一行副問い合わせは、単一の値を記述するような場所であれば、基本的にどこでも記述することができます。代表的な場所としては、SELECT文の選択列リストやUPDATEのSET句などが挙げられます。

- 単一行副問い合わせのイメージ

```sql
SELECT... (SELECT...) #結果が1行1列
↓
SELECT... 15700
```

- **単一行副問い合わせとは**
    - 検索結果が1行1列の1つの値となる副問い合わせを指す。
    - SELECT文の選択列リストやFROM句、UPDATEのSET句、また1つの値との判定を行うWHERE句の条件式などに記述することができる。

### 7.2.2 SET句で利用する
- リスト7-3 SET句で副問い合わせを利用する

```sql
UPDATE 家計簿集計
   SET 平均 = (SELECT AVG(出金額)
                FROM 家計簿アーカイブ
               WHERE 出金額 > 0
                 AND 費目 = '食費') # 副問い合わせの結果は5000
WHERE 費目 = '食費'
```

この例では、副問い合わせが「5000」という具体的な数値に変化します。そして最終的には家計簿集計テーブルの平均の列に「5000」をSETするUPDATE文になるというわけです。

副問い合わせを使えば集計と更新が一度にできてしまう。

### 7.2.3 選択列リストで利用する
- リスト7-4 選択リストで副問い合わせを利用する

```sql
SELECT 日付, メモ, 出金額,
       (SELECT 合計 FROM 家計簿集計
         WHERE 費目 = '食費') AS 過去の合計額 # 副問い合わせの結果は 10380
  FROM 家計簿アーカイブ
 WHERE 費目 = '食費'
```

このSQL文の副問い合わせは、家計簿集計テーブルの食費に関する合計学を取得する内容です。集計テーブルの食費に対応する行は1行ですから、検索結果は1つの値になります。

したがって、副問い合わせが10380という具体的な値に変化し、外側のSELECT文は、「食費の各明細と、これまでの食費の合計値を同時に表示する」という動作をします。

※最初から全体を読もうとしても複雑でよくわからないときは、括弧を探すこと。</details>


<details><summary>7.3 複数の値の代わりに副問い合わせを用いる</summary>

### 7.3.1 複数行副問い合わせ
複数行副問い合わせとは、検索結果が複数の行から成る単一列(n行1列)の値となる副問い合わせを指します。したがって、このパターンの副問い合わせを実行した結果は、複数の値に化けるとも考えることができます。

複数行副問い合わせは、SQL文中で「複数の値を列挙」するような場所に、その代わりとして記述することができます。具体的には、IN,ANY,ALL演算子を用いた条件式が代表的な事例です。
- 列挙された複数値に化ける副問い合わせ

```sql
SELECT... (SELECT... ) # 結果がn行1列
↓
SELECT... 10
          20
          30
```

- **複数行副問い合わせとは**
    - 検索結果がn行1列の複数の値となる副問い合わせ(但しnは1以上)。
    - 複数の値との判定を行うWHERE句の条件式や、SELECT文のFROM句に記述することができる。

### 7.3.2 IN演算子で利用する
IN演算子の復習。
- リスト7-5 INを使った条件式の例

```sql
SELECT * FROM 家計簿集計
 WHERE 費目 IN ('食費', '水道光熱費', '教養娯楽費', '給料')
```

- リスト7-6 INで副問い合わせを利用する

```sql
SELECT * FROM 家計簿集計 # 家計簿集計テーブルの全ての列を選択
 WHERE 費目 IN (SELECT DISTINCT 費目 FROM 家計簿) # 副問い合わせの結果は費目のグループ # 
# DISTINCTは重複行を除外する
```

### 7.3.3 ANY/ALL演算子で利用する
- リスト7-7 ANYで副問い合わせを利用する

```sql
SELECT * FROM 家計簿 # 家計簿テーブルから全ての列を選択
 WHERE 費目 = '食費' # 列名費目から文字列「食費」を絞り込む
   AND 出金額 < ANY (SELECT 出金額 FROM 家計簿アーカイブ
                     WHERE 費目 = '食費') # 副問い合わせの結果は食費の金額グループ
```

| 日付 | 費目 | メモ | 入金額 | 出金額 |
| --- | --- | --- | --- | --- |
| 2018-02-03 | 食費 | コーヒーを購入 | 0 | 380 |

**※ANYはたくさんの値を一度に比較したいときに便利。**

ANY演算子は、左辺の値と右辺に列挙された値とを比較して、いずれかの値と併記した比較演算子が成立するかを判定するものでした。この例では「<」演算子をANYと組み合わせていますので、3〜4行目は「**副問い合わせの結果で得られる複数の値のいずれかより出金額が小さければ**」という意味の条件式になります。

もしこのSQL文のANYをALLに書き換えると、「**副問い合わせの結果で得られる複数の値のどれよりも出金額が小さければ**」という条件になります。

### 7.3.4 エラーとなる副問い合わせ
複数行副問い合わせの結果はn行1列、つまり「複数の値」です。よって、IN演算子やANY演算子の「カンマで区切った値の列挙」の代わりに記述することはできても、**単一の値の代わりに記述することはできません**。

たとえば、「SELECT ＊ FROM 家計簿 WHERE 出金額 < 30000」というSQL文の「30000」の部分に、複数行副問い合わせと記述するとエラーになります。副問い合わせの結果得られる複数の値のうち、どれと出金額を比較してよいかわからないからです。

些細な違いですが、不等号の右にANY演算子を加えた、「SELECT * FROM 家計簿 WHERE 出金額 < ANY (30000)」というSQL文であれば、30000の部分に複数行副問い合わせを記述できます。
- **複数行を比較したいときには**
    
    複数行副問い合わせは複数の値に化けるので、単なる等号や不等号では比較できない。等号や不等号にANY/ALL演算子を組み合わせることで、複数の値との比較を行うことができる。
NOT IN 演算子は、右辺に列挙された値のどれとも一致しない場合に真となります。<>ALLも、右辺の全ての値を対象に一致しないことを判定するため、同じく真となります。したがってこの2つは全く同じ働きをするのです。同様に、IN演算子と=ANYも同じ意味になります。
- **同じ意味になる演算子**
    - NOT INと<>ALLは全ての値と一致しないことを判定する演算子。
    - INと=ANYはいずれかの値と一致することを判定する演算子。

### 7.3.5 副問い合わせとNULL
未定義であることを意味するNULLを判定するには、IS NULL演算子かIS NOT NULL演算子を使わなければならないというルールがありました。もし普通の演算子で比較すると、結果は「不明」となり、正しい比較が行えないのです(p083)。

NOT IN 演算子は、右辺に列挙された値を不等号を使って1つひとつ比較し、全ての値と等しくしないことを判定する演算子です。よって、**右辺に1つでもNULLが含まれると、NOT IN演算子による比較結果は全てNULLとなります**。WHERE句は結果が真となる行だけを抽出するので(p078)、最終的にリスト7-8のSELECT文では1行も得られないことになります。
- **副問い合わせがNULLを含んでいた場合**
    
    NOT INまたは<>ALLで判定する副問い合わせの結果にNULLが含まれると、全体の結果もNULLとなる。
    

データにNULLが含まれてしまったために、取得できるはずのデータが取得できないというケースは、データベースを使ったシステムでも陥りやすい落とし穴です。原因を特定することが難しい場合も多いので、特に注意しましょう。

副問い合わせの結果から確実にNULLを除外するには、次ページに挙げた2つの方法があります。

- **副問い合わせの結果から確実にNULLを除外する方法**
    1. 副問い合わせの絞り込み条件に、IS NOT NULL条件を含める。
    2. COALESCE関数を使ってNULLを別の値に置き換える。
- **リスト7-9 副問い合わせからNULLを除外する(IN NOT NULL 版)**

```sql
SELECT * FROM 家計簿アーカイブ
 WHERE 費目 IN (SELECT 費目 FROM 家計簿
                WHERE 費目 IN NOT NULL) # NULLを場外する条件を付加した
```

- **リスト7-10 副問い合わせからNULLを除外する(COALESCE 版)**

```sql
SELECT * FROM 家計簿アーカイブ
 WHERE 費目 IN (SELECT COALESCE(費目, '不明') FROM 家計簿) # 費目がNULLなら代わりに'不明'にする
```

- **行値式と副問い合わせ**
ここではn行1列の検索結果が返る副問い合わせを複数行副問い合わせとしましたが、Oracle DBなどの一部のDBMSでは、結果が複数行複数列でも、複数行副問い合わせとしての利用が可能です。その場合は、複数の列を組み合わせて同時に比較することができます。このような複数の列の組み合わせによる条件式を**行値式**をいいます。

 例) WHERE (A, B) IN (SELECT C, D FROM 〜)</details>


<details><summary>7.4 表の代わりに副問い合わせを用いる</summary>

### 7.4.1 表の結果となる副問い合わせ
表副問い合わせは、副問い合わせの検索結果が複数の行と複数の列からなる表形式(n行m列)の値となる副問い合わせです。したがって、この副問い合わせを実行した結果は、表の形に化けるとも考えることができます。
- **表形式の結果となる副問い合わせとは**
    - 検索結果がn行m列の表となる副問い合わせ(但しn、mは1以上)。
    - SELECT文のFROM句やINSERT文などに記述することができる。

### 7.4.2 FROM句で利用する
- リスト7-11 FROM句で副問い合わせを利用する

```sql
SELECT SUM(SUB.出金額) AS 出金額合計
  FROM (SELECT 日付, 費目, 出金額
          FROM 家計簿
        UNION
        SELECT 日付, 費目, 出金額
          FROM 家計簿アーカイブ
         WHERE 日付 >= '2018-01-01'
           AND 日付 <= '2018-01-31') AS SUB # FROM句はすべて副問い合わせ
```

副問い合わせに「SUB」という別名が付けられています。その別名を利用して、外側のSELECTの選択列リストでは、抽出対象とする副問い合わせとその項目を明示しています。

**※別名を付けることでSQL文がわかりやすくなり、DBMSも解析がしやすくなって実行速度が上がることもある。**

### 副問い合わせに別名をつけるときの注意点
別名の表記方法も、DBMS製品によって異なるので、利用する環境に応じて対応してください。

### 7.4.3 INSERT文で利用する
そもそもINSERT文は、基本的に、1回の呼び出しで1行しか追加できません。つまり、単純に考えると100行分のデータを追加したい場合は、100回のINSERT文を実行する必要があります。

しかし、**副問い合わせを使えば1回のINSERT文で複数行のデータを登録することが可能**になります。
- リスト7-12 INSERT文で副問い合わせを利用する

```sql
INSERT INTO 家計簿集計(費目, 合計, 平均, 回数)
SELECT 費目, SUM(出金額), AVG(出金額), 0 # 集計結果を表形式で返す副問い合わせ
  FROM 家計簿
 WHERE 出金額 > 0
 GROUP BY 費目 
```

2行目以降、最後までが副問い合わせです。今までと異なり今回の副問い合わせは、括弧で括られていません。このパターンだけの特例なので慣れてしまいましょう(厳密にはINSERT文の特殊構文です)。

今回の副問い合わせは、INSERT文の**VALUES以降の記述に相当する内容に化けるもの**です。SELECTの検索結果がそのままテーブルに登録すべき値として処理されます。

### 単独で処理できない副問い合わせ
副問い合わせは自信を取り囲む外側のSQL文(主問い合わせ)から独立していることが一般的です。しかし、次のような少し特殊な副問い合わせが利用されることがあります。

```sql
/* 今月使った費目(家計簿テーブルに登場する費目)についてのみ、
   合計金額を家計簿集計テーブルから抽出したい */
SELECT 費目, 合計 FROM 家計簿集計
 WHERE EXISTS
(SELECT * FROM 家計簿 WHERE 家計簿.費目 = 家計簿集計.費目)
```

このように、副問い合わせの内部から主問い合わせの表や列を利用する副問い合わせを、相関副問い合わせといいます。

特に上記のように、「ほかのテーブルに値が登場する行のみ抽出したい」場合に、EXISTS演算子とともに使われます。この形態は典型的な活用例ですので、パターンとして覚えておくとよいでしょう。

```sql
SELECT 列 FROM テーブル1
 WHERE EXISTS
(SELECT * FROM テーブル2 WHERE テーブル1.列 = テーブル2.列)
```

相関副問い合わせは副問い合わせの一種ではありますが、その処理方法や動作原理は一般的な副問い合わせと根本的に異なるため、全くの別物として理解することをお勧めします。

通常の副問い合わせが「内側の副問い合わせを1回処理→主問い合わせを1回処理」という単純な手順であるのに対して、相関副問い合わせは「外側SQLでテーブルから行を絞り込む過程で、各行について抽出してよいかを判断するために、繰り返し副問い合わせを実行する」ため、DBMSの負荷は大幅に増加します。</details>


<details><summary>7.5 この章のまとめ</summary>

### 7.5.1 この章で学習した内容
- **SQLのネスト**
    - SQL文の中に別のSELECT文を記述することができ、これを副問い合わせや副照会、またはサブクエリという。
    - 副問い合わせは、実行すると何らかの値に置き換わる。
    - 副問い合わせは、より内側にあるものから外側に向かって順に評価されていく。
- **副問い合わせのパターン**
    - 副問い合わせの結果が1行1列になるものを単一行副問い合わせという。
    - 副問い合わせの結果がn行1列になるものを複数行副問い合わせという。
    - 結果がn行m列の表形式になる副問い合わせも利用される。
- **複数行副問い合わせと演算子**
    - 複数行副問い合わせは、IN、ANY、ALL演算子と併せてよく用いられる。
    - 複数行副問い合わせの結果にNULLが含まれると、NOT IN、<>ALL演算子の評価結果もNULLとなる。

### 7.5.2 この章でできるようになったこと
- 食費の合計額を集計して集計テーブルを更新したい！

```sql
UPDATE 家計簿集計
   SET 合計 = (SELECT SUM(出金額)
                 FROM 家計簿アーカイブ
                WHERE 出金額 > 0
                  AND 費目 = '食費')
 WHERE 費目 = '食費';
```

- 1月と12月の出金額の合計をそれぞれ知りたい。

```sql
SELECT SUMLIST.タイトル, SUMLIST.出金額計
  FROM (SELECT '合計01月' AS タイトル, SUM(出金額) AS 出金額計
          FROM 家計簿アーカイブ
         WHERE 日付 >= '2022-01-01'
           AND 日付 <= '2022-01-31'
         UNION
        SELECT '合計12月' AS タイトル, SUM(出金額) AS 出金額計
          FROM 家計簿アーカイブ
         WHERE 日付 >= '2021-12-01'
           AND 日付 <= '2021-12-31') AS SUMLIST;
```

- 今月初めて発生した費目を知りたい。

```sql
SELECT DISTINCT 費目 FROM 家計簿
 WHERE 費目 NOT IN (SELECT 費目 FROM 家計簿アーカイブ);
```

- 今月の給料で先月までよりも高い額があれば知りたい…。

```sql
SELECT * FROM 家計簿
 WHERE 費目 = '給料'
   AND 入金額 > ALL (SELECT 入金額 FROM 家計簿アーカイブ
                     WHERE 費目 = '給料');
```

- 今月の家計簿データをアーカイブしたい！

```sql
INSERT INTO 家計簿アーカイブ
SELECT * FROM 家計簿;
```

- **パターンにとらわれずに自由に副問い合わせを使おう**

### パターンにとらわれずに自由に副問い合わせを使おう
今回紹介したものだけが、副問い合わせを記述可能な場所の全てというわけではありません。

詳細はDBMS製品によって異なりますが、SQL文の中で単一の値を記述できる場所は、たいてい、単一行副問い合わせに置き換えることができます。複数の値の列挙が求められる場所には、複数行副問い合わせを書いてみれば動くこともあるでしょう。

「副問い合わせがどのような形に化けるか」についての意識さえできていれば、さまざまな場所で自由に副問い合わせを活用できるようになるはずです。</details>

# 第8章 複数テーブルの結合
SQLのさまざまな機能や構文について学んできましたが、その殆どは、単一のテーブルに対するものでした。

さらにデータベースの実力を最大限に引き出すためには、複数テーブルに分けて格納されたデータを同時に取り出す「結合」の活用が欠かせません。

本格的な家計簿データベースの実現に向け、複数テーブルの取り扱い方を学びましょう。

<details><summary>8.1 「リレーショナル」の意味</summary>

### 8.1.1 RDBMSの真の実力
- **これまで学んだこと**
    
    **第Ⅰ部 データの格納と取り出しについて**
    
    - 4代命令でテーブルにデータを出し入れできる(第2章)。
    - WHERE句で処理対象行を絞り込める(第3章)。
    - ORDER BYやDISTINCTで検索結果に追加の処理を施せる(第4章)。
    
    **第Ⅱ部 データの取得と同時に計算や処理をさせる方法**
    
    - 式や関数を用いて、計算や集計をさせることができる(第5、6章)。
    - 一度行った検索結果を用いて、データを操作できる(第7章)。
    
    これらは**データベースの機能のうち特に学びやすい一部だけを選んだ**ものです。つまり、データベースに真の実力を発揮させるための機能や構文は、まだ紹介していません。
    
- **データベースの優位性**
    
    データを安全、確実、高速に取り扱うために生まれたデータベースは、表計算ソフトにはないさまざまな機能を備えている。

### 8.1.2 複数テーブルへのデータ格納
新しい家計簿テーブルでは、費目列が費目ID列になり、その内容がただの数字になっています。この数字は「費目テーブル(テーブル8-3)におけるIDが2の行(つまり、食費の行)」を指し示しています。

### 8.1.3 外部キーとリレーションシップ
「ID」列は費目テーブルの主キーなので重複はありえません。そのためIDの値が決まればどの行を意味するかが確定します。つまり、家計簿テーブルの各行では、費目IDを指定してあげることで、費目テーブルのどの1行を指し示すかを明確に指定することができるのです。

家計簿テーブルからは費目の名前は消えてしまいましたが、費目テーブルのIDを辿ることで費目の名前がわかるようになっているのです。

「家計簿テーブル」と「費目テーブル」のように、ある2つのテーブルの行に情報としての関連がある場合、その関連を**リレーションシップ**(relationship)といいます。

また、家計簿テーブルの「費目ID」列のように、ほかのテーブルの関連行を指すための値を格納することでリレーションシップを結ぶ役割を担っている列のことを**外部キー**(foreign key)といいます。
- **外部キー列の役割**
    
    外部キー列は、他テーブルのある列(主キー列など)の値を格納することによって、「その行が他テーブルのどの行と関連しているか」を明らかにする。

### 8.1.4 複数テーブルに分けるメリット
コンピュータにとっては、テーブルが分割されていた方がデータを安全、確実、高速に取り扱いやすいのです。具体的にわかりやすい例をいくつか挙げてみましょう。
- **例1 費目の名前を変更する場合**
    
    家計簿テーブルに10万行のデータが既に格納された状態で、「給料」という名前だった費目を「給与手当」に変更することにしましょう。もしテーブル8-1にある古い家計簿テーブルだとしたら、リスト8-1のようなSQL文を実行することになります。
    
    - リスト8-1 古い家計簿テーブル(テーブル8-1)の場合
    
    ```sql
    UPDATE 家計簿
       SET 費目 = '給与手当'
     WHERE 費目 = '給料'
    ```
    
    このSQL文を実行すると、DBMSは家計簿テーブルに格納された10万行全てに対して、1行ずつ条件に合致するかを調べて書き換えることになります。
    
    一方、もしテーブルがp239のテーブル8-2と8-3のように分割されていた場合はリスト8-2のようなSQL文になります。
    
    - リスト8-2 新しい家計簿テーブル(テーブル8-2、テーブル8-3)の場合
    
    ```sql
    UPDATE 費目
       SET 名前 = '給与手当'
     WHERE 名前 = '給料'
    ```
    
    このSQL文はリスト8-1ととてもよく似ていますが、DBMSが処理対象とする行数には明らかな違いがあります。費目の種類は多く見積もっても100個程度と考えられるため、DBMSは100行程度しかない費目テーブルを調べ、条件に合致するたった1行を書き換えるだけの仕事で済むのです。
    
- **例2 費目に関する補足情報を管理したい場合**
    
    テーブル8-3の費目テーブルでは各費目についての解説文を「備考」列として管理しています。これにより、例えば将来、収支区分などの列を加えていくことも容易になります。
    
    もし家計簿テーブルだけを単独で使い、費目に関して名前以外の情報も同じ家計簿テーブルに格納しようとすると、次のテーブル8-4のように**内容に重複が多く、わかりにくい表になってしまうのです**。
    
- **例3 ある特定行の費目名を書き換える場合**
    - リスト8-3 矛盾した状態を生むテーブル更新
    
    ```sql
    UPDATE 家計簿
       SET 費目 = '雑収入', メモ = '宝くじに当たった'
     WHERE 日付 = '2018-02-10'
    ```
    
    リスト8-3を実行すると、テーブル8-4の費目列の内容は「雑収入」に更新されますが、「費目の備考」列の更新を忘れてしまっています。費目は「雑収入」なのに備考は「給与や賞与が入った」という、矛盾した状態になってしまうのです。
    
    同じような情報をいろいろな場所で数多く保存していると、そのうちの1つだけを更新したり参照したりしたい場合であっても、分散している同じ種類のデータ全てについて、漏らすことなく検索して拾い上げなければなりません。
    
    3つの例が示すように、1つのテーブルにさまざまな情報を詰め込むことは、データの管理を難しくします。複数のテーブルにわけてデータを管理する方が、管理には適しているのです。
    
- **複数のテーブルに分けるメリット**
    
    データを複数のテーブルにわけて格納したほうが、安全、確実にデータを管理しやすい。

### 8.1.5 デメリットの克服
複数のテーブルにわけてデータを格納したほうが、管理に適していることは事実です。一方で、費目を番号で管理する家計簿テーブルには「人間にとって理解しにくい」というデメリットがあることに変わりありません。

しかし、データベースの多くは、「**管理に適した形態の複数テーブルから、人間が理解しやすい形態の1つの結果票を得る**」ための**結合**(join)という機能を備えています。

結合の他にも、私たちが普段利用する多くのデータベース製品は、複数のテーブルにわけて格納されたデータを関連づけて管理、利用するためのさまざまな機能を有しています。このようなデータベースを**リレーショナルデータベース**(RDB:Relational Database)といい、その中枢を担うDBMSをRDBMSといいます。
- **リレーショナルデータベース(RDB)**
    
    RDBは、データを複数テーブルで安全、確実に管理しながら、必要に応じて「人間にわかりやすい表」に結合することができる。
    

※データは、管理しやすいように複数テーブルに格納して、人に見せるときだけ結合すれば良い。</details>


<details><summary>8.2 テーブルの結合</summary>

### 8.2.1 結合の基本的な使い方
結合を行うために、SELECT文には次のような構文が用意されています。
- **テーブルAとテーブルBの結合**
    
    ```sql
    SELECT 選択列リスト
      FROM テーブルA
      JOIN テーブルB
        ON 両テーブルの結合条件
    # 選択列リストには両テーブルの列を指定可能。
    ```
    
    たとえば、家計簿テーブルに費目テーブルの内容を結合するような処理を実現するには、リスト8-4のようなSELECT文を記述します。
    
    - リスト8-4 図8-3の結合を実現するためのSELECT文
    
    ```sql
    SELECT 日付, 名前 AS 費目, メモ 
      FROM 家計簿
      JOIN 費目 # 結合するほかの表を指定 # (家計簿テーブルに)費目テーブルを加えろ
        ON 家計簿.費目ID = 費目.ID # 結合条件を指定 # 家計簿テーブルの費目ID列と費目テーブルのID列を紐付けろ
    ```
    
    1行目と2行目で、家計簿テーブルを検索して「日付」「名前(列名は別名として費目と表示する)」「メモ」の3つの列からなる結果表を出力することを指示しています。注目してほしいのは、1行目で指定している列のうち「名前」という列だけは、家計簿テーブルには存在しないということです。通常、テーブルに存在しない列をSELECT文の選択列リストに記述するとエラーになってしまいます。
    
    今回のSQL文がエラーにならないのは、3行目の**JOIN句**によって家計簿テーブルに費目テーブルが結合され、「ID」「名前」という列も参照可能になるからです。DBMSは**まず2つのテーブルを結合した上で、列の絞り込み(選択列リストの指示による)や、行の絞り込み(WHERE句の指定による)を行っていきます**。
    
    また、家計簿テーブルの各行に、費目テーブルのどの行を繋ぐかは4行目のON句の結合条件で指定しています。今回の「家計簿.費目ID = 費目.ID」という条件式は、次の指示をしていることになります。
    
    - 家計簿テーブルの各行について、まず費目ID列のデータに注目しなさい。
    - それと等しいIDを持つ費目テーブルの行を取り出して繋ぎなさい。
- 8.2.2 結合の動作イメージ
    
    結合は、入門者が最も躓きやすいポイントです。初めのうちは、その動作を理解することが難しいかもしれません。**DBMSがどのように結合処理をしていくか、頭の中にしっかりイメージを描き、定着させることが上達の近道**です。
    
    そもそも結合とは、2つのテーブルを単純にくっつけるような処理ではありません。
    
    また、**結合に関係する2つのテーブルは対等な関係ではありません**。あくまでも**FROM句で指定したテーブルが主役**であり、それに**JOIN句で指定したテーブルの内容を必要に応じて繋いで**いきます。
    
    たとえばリスト8-4の場合、DBMSは家計簿テーブルを1行ずつ処理していきながら、「この行に繋ぐべき、費目テーブルの行はどれか？」と探しながら、行と行を繋いでいくのです。
    
    **※DBMSは1行ずつ「どの行を右に繋ぐべきか」を探しながら結合する。**
    
    より具体的には、DBMSは左表の各行について、相手となる行を探すために次のようなSQL文を繰り返し実行しています。
    
    - リスト8-5 結合の際にDBMSが内部で繰り返し実行している処理
    
    ```sql
    -- 次のSQLの結果得られた行を、現在注目している左表の行に繋ぐ
    SELECT * FROM 右表 WHERE 結合条件の式
    ```
    
    - **結合とは**
        
        結合とは、テーブルを丸ごと繋ぐことではなく、結合条件が満たされた行を1つひとつ繋ぐことである。</details>



<details><summary>8.3 結合条件の取り扱い</summary>

### 8.3.1 結合相手が複数行の場合
もし何らかの理由で費目テーブルのID列に重複する値が入っていた場合はどうなるでしょうか。

図8-9の場合、2月10日の給料の行についてDBMSは次のようなSQLを内部で発行します。

```sql
SELECT * FROM 費目 WHERE 1 = 費目.ID
```

この結果得られる繋ぐべき行として、「給料」「仕送り」の2つの行が見つかってしまいます。1つの行に2つの行を結合することは物理的に不可能です。そのような場合、DBMSは右表の行数に合わせて左表の行を複製して結合させます。**左表に対して重複がある列を相手とした結合を行うと、結合前より行数が増える**ことになります。
- **右表の結合条件列の重複**
    
    繋ぐべき右表の行が複数あるとき、DBMSは左表の行を複製して結合する。結果表の行数は、もとの左表の行数より増える。

### 8.3.2 結合相手の行がない場合
逆に、結合によって結果表の行数が減ってしまうケースを紹介します。

```sql
SELECT * FROM 費目 WHERE 4 = 費目.ID
```

左表の費目ID列の値「4」に相当する費目テーブルのIDが存在しないため、繋ぐべき右表の行を見つけることができません。このような場合、DBMSはこの行の結合自体を諦め、次の行の処理に進みます。そのため、もともと左表になった2月5日の行は結合結果からは消滅してしまいます。

**※結合相手がいない左表の行は、結果表に出力されない。**

NULLはほかのどのような値と比較しても等しくならない存在です。もちろん、NULLとNULLを等しいかを比較しても、真にはなりません。

そのため、結合の際にDBMSが内部で発行する次のようなSQLも、結果は常に0行です。

```sql
SELECT * FROM 費目 WHERE NULL = 費目.ID
```

このような場合も、もともと左表にあった行は結合結果から消滅し、結果表に現れることはありません。
- **結合相手のない結合**
    
    右表に結合相手の行がない場合や、左表の結合条件の列がNULLの場合、結合結果から消滅する。

### 8.3.3 左外部結合
DBMSに対して「左表については結合相手が見つからなくも、NULLであっても必ず出力せよ」という左外部結合(left outer join)指示をすることができます。具体的には、今までSQL文中で「JOIN」と記述していた部分を、「LEFT JOIN」とするだけです。
- **左外部結合**
    
    ```sql
    SELECT 〜 FROM 左表の名前
         LEFT JOIN 右表の名前
                ON 結合条件
    # LEFT JOINは、LEFT OUTER JOINと記述してもよい
    # 結合相手の行がない場合や左表の結合条件列がNULLの場合、選択列リストに抽出される右表の列はすべてNULLとなる
    ```
    
    左外部結合の指示があると、右表に結合相手の行が存在しない場合でも、あるいは左表の行がNULLであっても、DBMSは結合を諦めません。右表の中に結合すべき行がない場合、**全ての値がNULLである行を新たに生み出して結合して**くれます。結果的に、左表の行が結合によって失われることはなくなります。

### 8.3.4 RIGHT JOIN とFULL JOIN
右外部結合(right outer join)や完全外部結合(full outer join)も存在します。
- **その他の外部結合**
    - 右外部結合：右表の全行を必ず出力する
    
    ```sql
    SELECT ~ FROM 左表の名前
       RIGHT JOIN 右表の名前
               ON 結合条件
    ```
    
    - 完全外部結合：左右の表の全行を必ず出力する
    
    ```sql
    SELECT ~ FROM 左表の名前
        FULL JOIN 右表の名前
               ON 結合条件
    # RIGHT JOINやFULL JOINは、RIGHT OUTER JOINやFULL OUTER JOINと記述してもよい。
    ```
    
    たとえば、右外部結合を使えば右表の全ての行が必ず結果表に出力されます。もし左表で使われていない費目が右表にあった場合も、その行の情報が失われることはありません。
    
    左外部結合、右外部結合、完全外部結合は、いずれも本来結果表から消滅してしまう行も強制的に出力する効果があります。これらを総称して**外部結合**(outer join)といいます。対して、結合すべき相手の行が見つからない場合に行が消滅してしまう通常の結合は、**内部結合**(inner join)といいます。

### FULL JOINをUNIONで代用する
MySQLやMariaDBなど、FULL JOINを利用できないDBMSでは、集合演算子UNIONを使って同等の処理を実現することができます。

```sql
    SELECT 選択列リスト FROM 左表の名前
 LEFT JOIN 右表の名前
        ON 左表の結合条件列 = 右表の結合条件列
     UNION
    SELECT 選択列リスト FROM 左表の名前
RIGHT JOIN 右表の名前
        ON 左表の結合条件列 = 右表の結合条件列
```

LEFT JOINによって左表の全ての行を出力した結果と、RIGHT JOINによって右表の全ての行を出力した結果を、UNIONによって足し合わせるというSQL文です。これは、**FULL JOINによって左右の表の全行を取り出すことと同じ意味**となります。</details>


<details><summary>8.4 結合に関するさまざまな構文</summary>

### 8.4.1 テーブル名の指定
2つのテーブルを結合すると、同じ名称の列が複数登場する場合があります。

このような場合、列名指定の前に「テーブル名.」という表記を加え、どのテーブルに属する列であるかを明示的に指定することができます。
 - リスト8-6 2種類のメモを両方出力するSQL文

```sql
SELECT 日付, 家計簿.メモ, 費目.メモ # 属するテーブル名を明示 # 日付、家計簿テーブルのメモ列、費目テーブルのメモ列を選択
  FROM 家計簿 # 家計簿テーブルから
  JOIN 費目 # (家計簿テーブルに)費目テーブルを加える
    ON 家計簿.費目ID = 費目.ID # 家計簿テーブルの費目ID列に費目テーブルのID列を紐付けせよ
```

なお、テーブル名が長く複雑な場合、リスト8-7のようにASで別名をつけておくと列指定や結合条件の記述が簡潔になります。

- リスト8-7 別名を使ったSQL文

```sql
SELECT 日付, K.メモ, H.メモ
  FROM 家計簿 AS K -- 家計簿テーブルに別名Kを設定
  JOIN 費目 AS H -- 費目テーブルに別名Hを設定
    ON K.費目ID = H.ID
```

### 8.4.2 3テーブル以上の結合
「JOIN ~ ON ~」を繰り返すことで、3つ以上のテーブルを結合することもできます。この場合も一度に3つのテーブルが結合されるわけではなく、前から順に1つずつ結合処理が行われていきます。

- リスト8-8 3つのテーブルを結合するSQL文

```sql
SELECT 日付, 費目.名前, 経費区分.名称
  FROM 家計簿   -- 家計簿テーブルに対して…
  JOIN 費目     -- まず費目を結合して…
    ON 家計簿.費目ID = 費目.ID
  JOIN 経費区分  -- その結果にさらに経費区分を結合
    ON 費目.経費区分ID = 経費区分.ID
```

### 8.4.3 副問い合わせの結果との結合
JOIN句のすぐ後ろに記述できるのは、テーブルだけでなく、「表形式のデータに化ける副問い合わせ」も記述することができます。

副問い合わせの結果がテーブルの代わりとして利用されることを除けば、通常の結合と違いはありません。但し、選択列リストや結合条件の指定のために、副問い合わせに別名を指定することが必要になります。

- リスト8-9 副問い合わせの結果と結合するSQL文

```sql
SELECT 日付, 費目.名前, 費目.経費区分ID
  FROM 家計簿 -- 家計簿テーブルに対して……
  JOIN ( SELECT * FROM 費目
         WHERE 経費区分ID = 1
       ) AS 費目 -- 副問い合わせの結果を結合
    ON 家計簿.費目ID = 費目.ID
```

### 8.4.4 同じテーブル同士を結合結合は異なるテーブル間で行われることが一般的ですが、自分自身と結合させることも可能です。同一テーブル同士を結合することを**自己結合**(self join)や**再帰結合**(recursive join)といいます。

- リスト8-10 自分自身と結合するSQL文

```sql
   SELECT A.日付, A.メモ, A.関連日付, B.メモ
     FROM 家計簿 AS A
LEFT JOIN 家計簿 AS B
       ON A.関連日付 = B.日付
```

尚、自己結合を行う場合、選択列リストや条件式を記述するために、**同じテーブルに別の名前を付ける**ことになります。

### イコール以外の結合条件式
結合の条件には等価記号(=)を用いた結合条件を指定することがほとんどです。しかし原理的には、=以外の演算子を用いた条件式も記述することができます。

```sql
SELECT ~ FROM テーブルA
  JOIN テーブルB ON テーブルA.列名 < テーブルB.列名
```

このような結合を**非等価結合**(non-equi join)といいます。動作の仕組みは通常の結合と同じですが、DBMSにかかる負荷が大きなものとなる点には注意してください。</details>


<details><summary>8.5 この章のまとめ</summary>

### 8.5.1 この章で学習した内容
- **リレーションシップ**
    - 本格的にデータベースを活用する場合、データは複数のテーブルに分けて格納する。
    - 他のテーブルのある行と関連づけるために、外部キーを利用してリレーションシップを構成する。
    - 外部キーとは、関連する他テーブルのある列(主キー列など)の値を記述したものである。
- **結合**
    - 結合を用いることで、複数のテーブルに格納された関連するデータを1つの結果表として取り出すことができる。
    - 結合を行う相手テーブルを指定するためにJOIN句を、結合条件を指定するためにON句を記述する。
    - 外部結合を用いると、結合相手がない行も結果表に出力させることができる。
- **結合構文のバリエーション**
    - 3テーブル以上の結合も、順に1つずつ処理される。
    - 副問い合わせの結果表と結合することもできる。
    - 自分自身のテーブルと結合することができる。

### 8.5.2 この章でできるようになったこと
- 家計簿テーブルと費目テーブルを結合して、費目を日本語で表示したい！

```sql
SELECT 日付, 名前 AS 費目, メモ, 入金額, 出金額
  FROM 家計簿
  JOIN 費目
    ON 家計簿.費目ID = 費目.ID;
```

- 家計簿テーブルの費目IDが定義されていない行も結果表に出力されるように結合したい。

```sql
SELECT 日付, 名前 AS 費目, メモ, 入金額, 出金額
  FROM 家計簿
  LEFT JOIN 費目
         ON 家計簿.費目ID = 費目.ID;
```

- 「給料」という名前の費目に関する、家計簿テーブルの行を見たい。

```sql
SELECT 家計簿.* FROM 家計簿
  JOIN (SELECT * FROM 費目 WHERE 名前 = '給料') AS 費目
    ON 家計簿.費目ID = 費目.ID
```

</details>

# 第9章 トランザクション
第Ⅱ部までDBMSでデータを操作するためのさまざまなSQLの構文を学んできました。

しかし、DBMSにSQL文を送っても、常に正しくデータ操作が完了するとは限りません。

処理中に突然コンピュータの電源が落ちてしまうかもしれませんし、他の人が書き換え途中のデータを読み込んでしまうかもしれません。

この章では、そのような思いがけない事態に備え、安全で確実なデータ操作を実現するDBMSの機能について紹介します。

<details><summary>9.1 正確なデータ操作</summary>

### 9.1.1 正確なデータ操作を脅かすもの
**安全で確実なデータ操作とデータ管理ほど重要なことはありません。**

DBMSはSQL文の指示通りに正確な処理を実行してくれます。理論的には、データベースないに誤ったデータを格納することはできないと感じるかもしれません。しかし現実には、DBMSが正しく処理を完了できなかったり、テーブル内のデータがおかしな値になってしまったりする可能性があります。

たとえば、急にコンピュータの電源が落ちて、一連のSQLの処理が中途半端なところで中断してしまうかもしれません。また、読み書きしかけていたデータを他人が横から書き換えてしまう可能性もあります。

### 9.1.2 トランザクション
①予期しない処理中断、②同時操作の2つのケースは、金融機関の基幹システムのように極めて重要なシステムでも発生する可能性があります。しかし、「停電があったのでデータベースが壊れ、残高がおかしくなりました」という言い訳は許されません。

そこで、DBMSにはこのような問題が起きないようにするための仕組みが備わっています。

実は私たちがDBMSに対して複数のSQL文を送る際、1つ以上のSQL文をひとかたまりとして扱うよう指示することができます。このかたまりのことを**トランザクション**(transaction)といいます。

DBMSはトランザクションを次のように扱います。
- **DBMSによるトランザクションの制御**
    - トランザクションの途中で、処理が中断されないようにする。
    - トランザクションの途中に、他の人の処理が割り込めないようにする。

DBMSがこのようにひとかたまりのSQL文を扱うことをトランザクション制御(transaction control)といいます。

### SQLにおけるセミコロンの取り扱い
1つのSQL分の終了を表すためにセミコロンを用いる方法があることは触れました(p043)。「仮に単一のSQL文であっても、常にSQLの文末にはセミコロンを付ける」「末尾のセミコロンまで含めてSQLの文法」という理解をしても概ね差し支えありません。

但し、**現状では多くのDBMS製品がセミコロンを「SQLの構文規則」というよりは、文の区切りを判定するための「単なる記号」として扱っている点には注意が必要**です。たとえば、文の区切りをセミコロン以外の別の記号に設定できるDBMSは多数存在します。また、単一のSQL文であることが明らかな場合にセミコロンを付けると、エラーになってしまうこともあります(例：Oracle DBにおいてJavaから単一SQL文を直接送信する場合)。

この現状に鑑み、本書では、1つのリストで複数のSQL文を紹介する場合(リスト9-1など)にのみ、文末にセミコロンを記述しています。</details>


<details><summary>9.2 コミットとロールバック</summary>

### 9.2.1 トランザクションの中断
複数のSQL文を実行している最中に処理が中断してしまうと問題となるケースはたくさんあります。代表的なのが「金融機関における振り込み処理」です。

振り込み処理を実現するためには、「振込先口座の残高を減らす」「振込先口座の残高を増やす」という2つのUPDATE文の実行が必要です。しかし、最初のSQL文の実行が成功した直後にDBMSが異常停止して処理が中断してしまったら、「振込元口座からはお金が減らされたのに、振込先にはお金が増えない」事態となってしまいます。

この問題は、2つのUPDATE文を1つのトランザクションとして扱うようにDBMSに指示することで解決できます。なぜなら、DBMSはどんな非常時であっても、**トランザクションを「一部だけが実行されることはあってはならない、途中で分割不可能なもの」として取り扱う**からです。
- **DBMSによるトランザクション制御(1)**
    
    DBMSは、トランザクションに含まれるすべてのSQL文について、必ず「全ての実行が完了している」か「1つも実行されていない」のどちらかの状態になるように制御する。
トランザクションに含まれる複数のSQL文が、DBMSによって不可分なものとして扱われる性質のことをトランザクションの**原子性**(atomicity)といいます。

※原子性：「原子」のように、それ以上細かく分割できないことから。

### 9.2.2 原子性確保の仕組み
トランザクション中のSQL文によってテーブルのデータが書き換えられると、それは確定ではなく仮のものとして管理されます。そして、トランザクションが終了する際に、それら「仮の書き換え」を全て確定したことにするのです。この確定行為のことを**コミット**(commit)といいます。

もし、トランザクション中に異常が発生して中断した場合、DBMSはそれまで行った全ての仮の書き換えをキャンセルして、「なかったこと」にします。このDBMSによる「なかったこと」にする動作を**ロールバック**(rollback)といい、SQL文のエラーで失敗したり、明示的にキャンセルが指示された場合などに行われます。もちろん、電源が落ちて突然処理が中断した場合も、再びデータベースを起動した際に自動的にロールバックが行われます。

### 9.2.3 トランザクションの指定方法
私たちが「複数あるSQL文のうち、どの範囲が1つのトランザクションであるか」を伝えれば、DBMSは適切に制御してくれます。より具体的には、次の3つのSQL文を使って指示を行います。
- **トランザクションを使うための指示**
    - **BEGIN**
        - 開始の指示。この指示以降のSQL文を1つのトランザクションとする。
    - **COMMIT**
        - 終了の指示。この指示までを1つのトランザクションとし、変更を確定する。
    - **ROLLBACK**
        - 終了の指示。この指示までを1つのトランザクションとし、変更の取り消しをする。
たとえば、家計簿テーブルの2018年1月以前のデータを家計簿アーカイブテーブルに移動する場合は、リスト9-1のようなSQL文を記述します。

- リスト9-1 1月のデータをアーカイブテーブルに移動する

```sql
BEGIN;
-- 処理1: アーカイブテーブルへコピー
INSERT INTO 家計簿アーカイブ
SELECT * FROM 家計簿 WHERE 日付 <= '2018-01-31'
-- 処理2: 家計簿テーブルから削除
DELETE FROM 家計簿 WHERE 日付 <= '2018-01-31'
COMMIT;
# INSERT文~DELETE文までがトランザクション
```

このSQL文を実行すると、処理1と処理2を不可分なものとして扱います。もし処理1を実行した直後に障害が発生した場合、自動的にロールバックが行われ、処理1の実行は取り消されます。

尚、「**ROLLBACK**」というSQL文をDBMSに送ることで、明示的にロールバックを発生させることも可能です。

### 9.2.4 自動コミットモードの解除
トランザクションがまだコミットされていない状態であれば、DELETE文によるデータ削除でさえもキャンセルすることは可能です。しかし、dokoQLのほか、各DBMS付属のSQL実行ツールを使っていると、ロールバックができないことがあります。

これは、多くのツールがデフォルト状態では**自動コミットモード**(auto commit mode)と呼ばれるモードで動作するからです。このモードにある時、DBMSは**1つのSQL文が実行されるたびに、自動的に裏でコミットを実行**してしまいます。

DBMSによっては、自動コミットモード中であっても「**BEGIN**」を実行することで、コミットかロールバックまでの間、一時的に自動コミットを解除することができます。

明示的に自動コミットモードを解除するための方法はツールや環境によって異なります。たとえば、MySQLでは「**SET AUTOCOMMIT=0**」というSQL文を実行します。</details>


<details><summary>9.3 トランザクションの分離</summary>

### 9.3.1 同時実行の副作用
世の中で利用されている情報システムにおいては、**多くの利用者から1つのDBMSに対してたくさんのSQL文が送られます**。

DBMSはそれらの要求を同時に処理しようとしますので、同じ行を複数の利用者が同時に読み書きする可能性も大いにあります。しかし、そのような状態が発生すると、副作用が発生し、正しい処理が行えない場合があります。

たとえば、1つの口座に対して、10,000円の引き出しと電気代6,200円が引き落とされたとします。ほぼ同時に2つの処理が行われようとした時、この2つの処理要求はほぼ同時に行われているため、どのような順番で実行されるかはわかりません。仮に、次のような順番でDBMSが処理しようとしたとしましょう。

1. ATMからの引き落とし要求に従い、口座残高を10,000円減らし、20,000円にする(仮)。
2. 電力会社からの引き落とし要求に従い、口座残高をさらに6,200円減らし、13,800円にする(仮)。
3. ATMからの要求に従い、1.によるデータ変更を確定して現金10,000円を払い戻す。
4. 電力会社からの要求に従い、2.によるデータ変更を確定する。

かなりの確率で、このように正しく2つの出金が行われ、最終的な口座残高は13,800円となるでしょう。しかし万一、1.の処理が途中で止まってしまった場合はどうなるでしょうか。

1.の処理が中断されてロールバックが行われたなら、10,000円を引き出そうとしたアクションは「なかったこと」にされているはずです。しかし、1.2.の両方の金額が引かれてしまい、口座残高は13,800円になってしまいました。

### 9.3.2 3つの代表的な副作用
DBMSに対して複数の利用者が同時に処理を要求することで発生する副作用には、次の3つのものが知られています。
- **副作用1 ダーティーリード**
    - まだコミットされていない未確定の変更を、他の人が読めてしまうという副作用を**ダーティーリード**(dirty read)といいます。ATMからの出金がまだ確定していない状態で、電力会社がその仮の残高をダーティーリードしてしまい、さらに電気代を引いてしまったために発生しています。その後キャンセルされてしまうかもしれない未確定の情報をもとにして別の処理を行なってしまうため、ダーティーリードは非常に危険な副作用です。
- **副作用2 反復不能読み取り**
    - **反復不能読み取り**(non-repeatable read)とは、あるテーブルに対してSELECT文を実行した後、他の人がUPDATE文でデータを書き換えると、次回SELECTした際に検索結果が異なってしまうという副作用です。
テーブルの内容を複数回読み取る際、その間にデータの内容が変化してしまっては困る場合があります。たとえば、家計簿テーブルの統計を取るために「①出金額の合計を集計する」「②出金額の最大値を集計する」計算の処理を2つのSELECT文で順番に実行しているとしましょう。

常識的に考えれば、②の結果が①の結果より大きくなることはありません。しかし、①のSELECT文が実行された直後に、他の人によって一部のデータが書き換えられると、②の結果が①より大きくなり、データの整合性が崩れてしまうことがあり得ます。
- **副作用3 ファントムリード**
    - **ファントムリード**(phantom read)は、反復不能読み取りと似ています。2回のSELECT文の間に、他の人がINSERT文で行を追加すると、2回のSELECTで結果行数が変わってしまうという副作用です。1回目の検査結果の行数に依存するような処理を行う場合に、問題となることがあります。

### 9.3.3 トランザクションの分離
しかし、前項で紹介した副作用は、トランザクションによって解決することができます。なぜなら、DBMSは個々のトランザクションについて分離性(isolation)を維持するために次のような制御を行うからです。
- **DBMSによるトランザクション制御(2)**
    
    DBMSは、あるトランザクションを実行する際、ほかのトランザクションから影響を受けないよう、分離して実行する。つまり、仮にほかのトランザクションと同時に実行していたとしても、あたかも単独で実行しているのと同じ結果となるよう制御する。
DBMSはこの制御を行うために、内部で**ロック**(lock)と呼ばれる仕組みを使います。あるトランザクションが現在読み書きしている行に鍵をかけ、ほかの人のトランザクションからは読み書きできないようにしてしまうのです。

このように、あるトランザクションが特定の行などをロックすることを「ロックを取る」「ロックを取得する」と表現することもあります。

自分のトランザクションがコミットまたはロールバックで終了すると、かけた鍵は解除され、ほかの人のトランザクションがその行を読み書きできるようになります。

つまり、自分が読み書きしたい行を他人がロックしている間、その**相手のトランサクションが完了するまで自分は待たされます**。このロック待ち時間は通常数ミリ秒以下と大変短いものですが、ロックがたくさん発生すると、データベースの動作は非常に遅くなってしまう点には注意が必要です。

### 9.3.4 分離レベル
トランザクションを使うことでロックの仕組みが有効になり、副作用は発生しないようになる一方、DBMSのパフォーマンスは損なわれてしまいます。このように、正確なデータ操作とパフォーマンスは二律背反の関係にありますが、どちらか片方しか選べないというわけではありません。

多くのDBMSでは、どの程度厳密にトランザクションを分離するかを**トランザクション分離レベル**(transaction isolation level)として指定することができます。

| 分離レベル | ダーティーリード | 反復不能読み取り | ファントムリード |  |
| --- | --- | --- | --- | --- |
| READ UNCOMMITTED | 恐れあり | 恐れあり | 恐れあり | ↑高速危険 |
| READ COMMITTED | 発生しない | 恐れあり | 恐れあり |  |
| REPEATABLE READ | 発生しない | 発生しない | 恐れあり |  |
| SERIALIZABLE | 発生しない | 発生しない | 発生しない | ↓安全低速 |

多くのDBMSでは、デフォルトでREAD COMMITTEDという分離レベルで動作しています。このレベルは、さほど厳しいロックをかけないためダーティーリードしか防ぐことはできませんが、ある程度高速に動作するという特徴を持っています。

ほかの分離レベルを利用したい場合、多くのDBMSではSET TRANSACTION ISOLATION LEVEL命令を使用して任意の分離レベルを選択することができます。
- **トランザクション分離レベルの指定**
    
    ```sql
    SET TRANSACTION ISOLATION LEVEL 分離レベル名
    SET CURRENT ISOLATION 分離レベル名
    # どちらの構文を使うかは、DBMS製品によって異なる。
    ```

たとえば、最も安全だけれどデータベースの処理速度は落ちてしまうSERIALIZABLEという分離レベルを使う場合、リスト9-2のように指定します。

- リスト9-2 SERIALIZABLE 分離レベルを選択する

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
```

### READ UNCOMMITTEDが無効である理由
Oracle DBやPostgreSQLには、分離レベルとしてREAD UNCMMITTEDが存在しません。データベースの内部機構上、常に、コミットされていない情報は読めないようになっているからです。

これらのDBMSでは、あるトランザクションによってデータが書き換えられている最中も書き換え前の情報が残っており、ほかのトランザクションから利用可能になっています。つまり、わざわざロックをかけずともダーティーリードが起こらないのです。

あるデータについて、「書き換え済み(但し未確定)」と「書き換え前」の2つのバージョンを併存させることを**並列実行制御**(MVCC:multi-version concurrency control)といいます。</details>


<details><summary>9.4 ロックの活用</summary>

### 9.4.1 明示的なロック
前節で紹介したように、DBMSはトランザクションの分離性を確保するために自動的に行にロックをかけます。私たちは、具体的に「いつ」「どの行に対して」ロックをするかという指示をする必要はありません。その一方、私たちはSQL文を使って明示的に指定した対象をロックすることもできます。また、行以外にもテーブル全体やデータベース全体をロックすることも可能です。
- **明示的に取得できるロックの種類**
    
    行ロック：ある特定の1行だけをロックする。
    
    表ロック：ある特定のテーブル全体をロックする。
    
    データベースロック：データベース全体をロックする。
    
    ※DBMSによっては「ページ」や「表スペース」などもロック対象となる。
ロックをかける際には、その厳しさを指定することができます。**排他ロック**(exclusive lock)は、他からのロックを一切許可しないため、主にデータの更新時に利用されます。**共有ロック**(shared lock)は、他からの共有ロックを許す特性があるため、データの読みより時に多く利用されます。

**①行ロックの取得 - SELECT ~ FOR UPDATE**

通常、SELECT文で選択した行には自動的に共有ロックがかかります。しかしSELECT文の末尾に「FOR UPDATE」を追加すると、排他ロックがかかり、ほかのトランザクションからは該当行のデータを書き換えることができなくなります。
- **明示的な行ロックの取得**
    
    ```sql
    SELECT ~ FOR UPDATE (NOWAIT)
    ```

明示的なロックを取得しようとした時、すでに他のトランザクションによって同じ行がロックされている場合、通常はロックが解除されるまで自分のトランザクションは待機状態となります。

しかし、NOWAITオプションを指定した場合には、DBMSはロックの解除を待機せずにすぐさまロック失敗のエラーを返すため、トランザクションは即時終了します。これは、処理を待たせたくないアプリケーションなどに有効です。

かけたロックは、コミットまたはロールバックによってトランザクションが終了すると解除されます。たとえば、家計簿テーブルの2018年2月以降のデータについて、いくつも複雑な集計処理を行う場合、リスト9-3のように行ロックをかけておけば、他から更新されることがなくなるため安心でしょう。
- リスト9-3 2月以降の行をロックして集計する

```sql
BEGIN;
SELECT * FROM 家計簿
 WHERE 日付 >= '2018-02-01'
   FOR UPDATE;    -- 2月以降のデータを明示的にロック
-- 集計処理1
SELECT ～ ;
-- 集計処理2
SELECT ～ ;
-- 集計処理3
SELECT ～ ;
COMMIT;           -- ロックが解除される
# SELEC * からCOMMITの前のSELECTまでがトランザクション
```

**②表ロックの取得 - LOCK TABLE**

ある特定の表全体をロックするには、LOCK TABLE命令を利用します。
- **明示的な表ロックの取得**
    
    ```sql
    LOCK TABLE テーブル名 IN モード名 MODE (NOWAIT)
    # モード名はEXCLUSIVEで排他ロック、SHAREで共有ロックとなる。
    # DBMS製品による記述の違いについては付録Aを参照。
    ```

尚、取得された表ロックは、行ロック同様にトランザクションの終了に伴い解除されます。リスト9-3を表ロックの形に書き換えたものがリスト9-4です。

- リスト9-4 家計簿テーブルをロックして集計をする

```sql
BEGIN;
LOCK TABLE 家計簿 IN EXCLUSIVE MODE; -- 表を明示的にロック
-- 集計処理1
SELECT ～ ;
-- 集計処理2
SELECT ～ ;
-- 集計処理3
SELECT ～ ;
COMMIT;                             -- ロックが解除される
# LOCKからCOMMITの前のSELECTまでがトランザクション
```

### 9.4.2 デッドロック
データベースで同時にたくさんのトランザクションが実行されると、まれにデッドロック(dead lock)と呼ばれる状態に陥り、トランザクションの処理が途中で永久に止まってしまうことがあります。デッドロックは、次のような2つのトランザクションによって引き起こされます。
- **デッドロックの発生**
    
    「X」をロックしたトランザクションAが、次に「Y」もロックしようとしている一方で、
    
    「Y」をロックした別のトランザクションBが、次に「X」をロックしようとする時、デッドロックが発生する。
    
    ※お互いに自分は譲らず、相手が譲るのを待つ状態のことを指す。
    

デッドロックが発生して処理が完全に停止してしまうことを防ぐため、多くのDBMSにはデッドロックを自動的に解決する仕組みが備わっています。DBMSは、実行中のトランザクションの中にデッドロックに陥ってしまっているものがないかを定期的に調べ、もしそのようなものを発見したら、片方のトランザクションを強制的に失敗させることによって、デッドロック状態から抜け出せるようにします。

このように片方のトランザクションに強制的に道を譲らせることより、デッドロック状態は解決されます。しかし、少なくとも1つのトランザクションが失敗してしまうことや、処理が停止してしまう時間が存在することを考えると、**可能な限りデッドロックは避ける**べきです。

勿論、デッドロックを100％防ぐことは難しいですが、次のような対策を取ることで、発生する確率を減らすことは可能です。
- **デッドロックを予防する方法**
    
    対策①トランザクションの時間を短くする。
    
    対策②同じ順番でロックするようにする。
    

対策①は、直感的に理解しやすいでしょう。ロックしている時間が短いほど、他のトランザクションと競合してしまう確率は低くなります。

また、対策②も、ロックを行うときの基本的な心構えです。

そもそもデッドロックは、2つのトランザクションが互いに**相手と違う順番でロックを行おうとするために発生する**現象です。例えば、図9-9の例では、2つのトランザクションがそれぞれ「X→Y」「Y→X」の順番にロックを試みています。しかし、もし両者が「X→Y」の順にロックするトランザクションであれば、デッドロックは決して発生しないのです。

行やテーブルをロックする際には、すべてのトランザクションにおいて、同じ順番でロックがかかるようにSQLを工夫することで、デッドロックを未然に防ぐことが可能になるのです。
- **同じ順番でロックする**
    
    SQL文を組み立てる際には、可能な限り同じ順番で行やテーブルにロックがかかるよう意識する。

### ロックエスカレーション
DBMSにとって、膨大な数の行をロックするのは大変なことです。ロックによって、負荷も上がり、メモリも逼迫してしまいます。

そこでDb2やSQL Serverなどの一部のDBMSは、あるテーブルについて多数の行ロックがかけられると自動的に表ロックなどに切り替わる**ロックエスカレーション**(lock escalation)という機構を持っています。

ロックエスカレーションによってDBMSの負荷が下がり、性能が向上することもありますが、同時に実行できるトランザクション数が減って逆に遅くなったり、デッドロックの原因になったりすることもあります。

ロックエスカレーションは、発生条件を細かく設定したり明示的に禁止することも可能です。必要に応じて上手に活用していきましょう。

### 2フェーズコミット
2つ以上のデータベースに分けて情報を格納している場合、通常のトランザクションではデータの整合性を確保できないことがあります。例えば、データベースAに入出金情報を、データベースBに入出金の更新日時を記録している場合、データベースAのトランザクションをコミットした直後にデータベースBがダウンしてしまうケースです。

このような場合、**2フェーズコミット**(two phase commit)と呼ばれる手法が利用されることがあります。2フェーズコミットでは、各データベースに対してトランザクションの「確定準備」と「確定」の2段階の指示を出すことによって、複数のデータベースに跨ったトランザクションの整合性を維持します。</details>


<details><summary>9.5 この章のまとめ</summary>

### 9.5.1 この章で学習した内容
- **トランザクション**
    - 複数のSQL文を分けることのできない1つの命令として扱うことができる。
    - DBMSは、トランザクションの原子性や分離性を保つよう制御を行う。
- **原子性**
    - トランザクションに含まれる複数のSQL文は、すべて実行されたか、1つも実行されていないかの状態になることが、DBMSにより保証される。
    - コミットを行うことで、トランザクション中のすべての処理が確定する。
    - ロールバックを行うことで、トランザクション中のすべての処理はキャンセルされる。
    - DBMSに付属する多くのSQL汎用ツールは、デフォルトで自動コミットモードになっている。
- **分離性**
    - トランザクションは、同時実行中のほかのトランザクションからの影響を受けないよう、分離して実行される。
    - 代表的な副作用には「ダーティーリード」「反復不能読み取り」「ファントムリード」がある。
    - トランザクション分離レベルを選ぶことで、性能と分離の度合いのバランスを選ぶことができる。
- **ロック**
    - 行や表、データベース全体に、明示的にロックをかけることができる。
    - 複数の対象に異なる順番でロックをかけようとする複数のトランザクションは、デッドロックに陥ることがあるため注意を要する。

### 9.5.2 この章でできるようになったこと
- 家賃60,000円を振り込むと同時に、420円の手数料も支払ったことを記録したい。

```sql
BEGIN;
INSERT INTO 家計簿
VALUES('2018-03-20', '住居費', '4月の家賃', 0, 60000);
INSERT INTO 家計簿
VALUES('2018-03-20', '手数料', '4月の家賃の振り込み', 0, 420);
COMMIT;
# INSETR~COMMITの前のVALUESまでがトランザクション
```

- 3月20日のデータを削除したけど、やっぱりなかったことにしたい。

```sql
BEGIN;
DELETE FROM 家計簿 WHERE 日付 =  '2018-03-20'
ROLLBACK
# DELETEがトランザクション
```

- 処理中に他の人によって家計簿テーブルの内容が変化しないようにしながら、各種統計を記録したい。

```sql
BEGIN;
LOCK TABLE 家計簿 IN EXCLUSIVE NODE;
INSERT INTO 統計結果
SELECT 'データ件数', COUNT(*) FROM 家計簿;
INSERT INTO 統計結果
SELECT '出金額平均', AVG(出金額) FROM 家計簿;
COMMIT;
# LOCK~COMMIT前のSELECTまでがトランザクション
```

</details>

# 第10章 テーブルの作成
これまでは、既存のテーブルに対するデータの格納や取り出しの命令を学んできました。

この章では、新しいテーブルを作成する命令を学びます。

しかし、単にテーブルの作成方法だけを学ぶわけではありません。

テーブル作成に伴う様々なオプションについての知識を身につけ、データベースが提供してくれる機能や高い信頼性を実現するための仕組みも理解していきましょう。

<details><summary>10.1 SQL命令の種類</summary>

### 10.1.1 データベースを使う2つの立場
これまで、SELECT、INSERT、UPDATE、DELETEなどの命令を使って、既存のテーブルに対してデータを操作する方法を学びました。今回の学習では、入力したSQL文を直接DBMSに送っていますが、一般的な情報システムの内部では、Javaなどで開発したプログラムが生成したSQL文をDBMSに送ってデータ操作を指示することが大半です。

つまり、これまでの私たちや情報システムにおけるプログラムは、「**データの操作を支持する立場**(立場①)」としてDBMSを利用しています。

しかし、立場①の人がSELECT文やINSERT文でデータの出し入れを行うには、そもそもデータベース内部にテーブルが存在していることを前提としています。そこで必要になるのが、テーブルの作成や各種の設定など、「**データベース自体の操作を指示する立場**(立場②)」の存在です。

- **データベースを利用する2つの立場**
    
    立場①：データベースにデータの出し入れを指示する立場
    
    立場②：立場①の人が、効率良く、安全にデータの出し入れができるよう必要なテーブル準備や各種設定を指示する立場
この章からは立場②として**データベースの設定や構築についての方法**を学んでいきます。

### 10.1.2  4種類の命令
立場②としてテーブル作成を指示する場合にも、SQLを使います。但し、SELECTやINSERTではなく、CREATE TABLEという命令を使います。立場②として使う命令は他にもたくさん準備されていますが、すべてのSQL文は、最終的に4種類の命令に分類することができます。

### 10.1.3 DCLとは
DCLは、誰に、どのようなデータ操作やテーブル操作を許すかといった権限を設定するためのSQL命令の総称です。権限を付与するGRANT文と剥奪するREVOKE文があります。
- **GRANT文とREVOKE文**
    
    ```sql
    GRANT 権限名 TO ユーザー名
    REVOKE 権限名 FROM ユーザー名
    # 権限名やユーザー名の記述の詳細は、DBMS製品によって異なる。
    ```

これらは、立場②の中でも特にデータベースの全権を管理する、**データベース管理者**(DBA:Database Administrator)の立場の人だけが使う命令です。また、DBMS製品によって構文や位置付けが大きく異なるため、詳細は各製品のマニュアルに譲ることにします。

### SQL文の分類方法
あるSQL文が、DML、TCL、DDL、DCLのいずれに分類されるかは、DBMS製品や資料によって異なることがあります。

例えば、BEGIN、COMMIT、ROLLBACKは、DCLに分類される場合もあります。</details>


<details><summary>10.2 テーブルの作成</summary>

### 10.2.1 テーブル作成の基本
テーブルを作成するには、CREATE TABLE文を使います。作成したいテーブルの名前、テーブルを構成する列と型の一覧を指定し、テーブルを定義します。
- **テーブルの作成(基本形)**
    
    ```sql
    CREATE TABLE テーブル名 (
      列名1 列1の型名,
      列名2 列2の型名,
      ：
      列名X 列Xの型名
    )
    ```
    

例えば、これまで利用してきた家計簿テーブルを作成するには、リスト10-1のようなSQL文を実行します。

- リスト10-1 家計簿テーブルを作成する

```sql
CREATE TABLE 家計簿 (
  日付        DATE,
  費目ID      INTEGER,
  メモ        VARCHAR(100),
  入金額      INTEGER,
  出金額      INTEGER
)
```

### 10.2.2 デフォルト値の指定
テーブルに対してINSERT文によって行が追加される際、一部の列の値が指定されないことがあります。例えば、家計簿テーブルに行を追加する次のリスト10-2のように、「費目ID」や「入金額」が省略されるかもしれません。
- リスト10-2 家計簿テーブルに対する行の追加

```sql
INSERT INTO 家計簿 (日付, メモ, 出金額）
     VALUES ('2018-04-12', '詳細は後で', 60000)
```

このSQL文が実行されると、テーブルに追加された行の「費目ID」と「入金額」の列の内容は、次の結果表にあるようにNULLとなります。

| 日付 | 費目ID | メモ | 入金額 | 出金額 |
| --- | --- | --- | --- | --- |
| 2018-04-12 | NULL | 詳細は後で | NULL | 60000 |

**INSERT文で具体的な値を指定しなかった場合に、NULLではなく特定のデフォルト値(初期値)を格納**できたら便利だと思いませんか。テーブルを作成する際に、デフォルト値を決めておくことで、「特に指定しなければ入金額には0が格納される」というような設定を行うことが可能です。

そのためには、CREATE TABLE文にDEFAULTキーワードを指定します。
- **デフォルト値の指定を含むテーブルの作成**
    
    ```sql
    CREATE TABLE テーブル名 (
      列名  型名 DEFAULT デフォルト値,
      :
    )
    ```
    

この仕組みを活用して家計簿テーブルを作成するには、次のSQL文を実行します。4〜6行目で、デフォルト値として0や「不明」を指定しています。

- リスト10-3 家計簿テーブルを作成する(デフォルト値を活用)

```sql
CREATE TABLE 家計簿 (
  日付        DATE,
  費目ID      INTEGER,
  メモ        VARCHAR(100) DEFAULT '不明',
  入金額      INTEGER      DEFAULT 0,
  出金額      INTEGER      DEFAULT 0
)
```

### 10.2.3 DROP TABLE文
リスト10-1を実行したまま、リスト10-3の内容を実行するとエラーになります。何故なら、すでに家計簿テーブルが作成されているためです。**データベース内に、同じ名前のテーブルを複数作ることはできません**。つまり、家計簿テーブルを作り直すには、家計簿テーブルをいったん削除しなければなりません。

DELETE文は、DML(Data Manipulation Language)に属する命令です。テーブルのデータの削除はできますが、テーブル自体を削除することはできません。

テーブル自体を削除するにはDDLに属するDROP TABLE文を利用します。
- **テーブルの削除**
    
    ```sql
    DROP TABLE テーブル名
    ```
    
- **DROP TABLEはキャンセルできない？**
    
    DMLに属するDELETE文などは、ロールバック命令によりキャンセルできることが一般的です。しかし、DDLについてロールバックができるか否かはDBMS製品によって異なります。
    
    例えば、Oracle DBでは基本的にDDLはロールバックできず、一度実行すると取り消しすることができません。重要な操作を行う場合には、念の為バックアップしておくなど安全への配慮も大切です。

つまり、この場合は「**DROP TABLE** 家計簿」を実行すればテーブルを削除することが可能です。

### 10.2.4 ALTER TABLE文
テーブル定義の内容を変更するには、ALTER TABLE文を使います。この文では、具体的にテーブルの「何を」「とう」変えるかを指定する必要があります。今回は代表的な2つの変更について紹介しておきます。
- **テーブル定義の変更**
    
    ```sql
    ・列の追加
    ALTER TABLE テーブル名 ADD 列名 型 制約
    
    ・列の削除
    ALTER TABLE テーブル名 DROP 列名 型 制約
    ```
    

既存のテーブルに列を追加する場合、挿入される位置は、原則として一番最後になります。DBMSによっては、挿入位置を任意に指定できるものもあります。

例えば、家計簿テーブルにDATE型の「関連日」列を追加してすぐ削除するには、リスト10-4のようなSQL文を実行します。

- リスト10-4 列の追加と削除

```sql
-- 追加するとき
ALTER TABLE 家計簿 ADD 関連日 DATE;

-- 削除するとき
ALTER TABLE 家計簿 DROP 関連日;
```

### 全件のデータを高速に削除する
テーブルの全行を削除する場合、**TRUNCATE TABLE文**が利用されることがあります。

```sql
TRUNCATE TABLE 家計簿      -- 家計簿テーブルの全行を削除
```

実行結果は「DELETE FROM 家計簿」とほぼ同じですが、その動作には次のような違いがあります。

- DELETEはWHERE句で指定した行だけ削除できるが、TRUNCATEは必ず全行を削除する。
- DELETEはDMLだが、TRUNCATEはDDLに属する命令である。
- DELETEはロールバックに備えて記録を残しながら仮削除していくが、TRUNCATEは記録を残さずに行を削除する(よってロールバックできない)。

TRUNCATE TABLEは、厳密にはデータ削除ではなくテーブル初期化の命令です。「テーブルを一度DROPして同じものをCREATEする」というような動作イメージを持つとわかりやすいでしょう。</details>


<details><summary>10.3 制約</summary>

### 10.3.1 人為的ミスに備える
**データベース本来の役割を考えると、テーブルに異常な値が格納されてしまうことは絶対に避けなければなりません**。第9章では、**予期しない中断や同時実行など、システム的な理由でデータが異常な状態になってしまうことを避けるため**に**トランザクション**を使うことを学びました。

しかしデータベースの利用者が、文法としては正しいものの、システムの意図としては誤ったSQL文をDBMSに送ってしまうような**人為的ミスに対してトランザクション制御は全くの無力**です。

DBMSは、人為的ミスによる意図しないデータの格納が行われないための仕組みをいくつも備えています。例えば、「型」もそんな安全機構の1つです。

テーブルの各列に型を指定することで、その列に格納できるデータの種類は制限されるようになります。型など指定せず、文字列でも数値でも格納できたほうが便利と感じる人もいるかもしれません。しかし、例えば「出金額」の列がINTEGER型で定義されているからこそ、万が一にも誤って文字列を格納してしまう人為的ミスを回避できるのです。
- **あえて制限することで安全性を高める**
    
    予期しない値を格納できないように制限をかけることで、人為的ミスによるデータ破壊の可能性を減らすことができる。

加えて、多くのDBMSは**制約**(constraint)という仕組みを備えており、型よりもさらに強力な制限をかけることができます。制約を使えば、「日付の列は絶対にNULLになってはならない」や「入金額や出金額の列は0以上の数値しか格納してはならない」のようなきめ細かい制限をかけることができます。

現在、広く用いられているDBMSでは5種類の制約をサポートしています。先ずはその中から、比較的シンプルな3つについて紹介していきましょう。

### 10.3.2 基本的な3つの制約
制約は、CREATE TABLE文でテーブルを定義する際に、列定義の末尾に指定することが可能です。
- **CREATE TABLE文中における制約の指定**
    
    ```sql
    CREATE TABLE テーブル名 (
      列名  型 制約の指定,
    	:
    )
    ```

尚、制約を複数指定することもできますが、カンマで区切らずにそのまま並べて記述します。

例えば、図10-4のようなデータを格納するために2つのテーブルを作成したい場合を考えます。この例の場合、制約の指定を伴う次のようなCREATE TABLE文を実行します。
- リスト10-5 基本的な3つの制約を活用

```sql
CREATE TABLE 家計簿 (
  日付      DATE         NOT NULL, # NOT NULL 制約
  費目ID    INTEGER,
  メモ      VARCHAR(100) DEFAULT '不明' NOT NULL,　# NOT NULL 制約
  入金額    INTEGER      DEFAULT 0 CHECK(入金額 >= 0),　# CHECK 制約
  出金額    INTEGER      DEFAULT 0 CHECK(出金額 >= 0) # CHECK 制約
);
CREATE TABLE 費目 (
  ID       INTEGER,
  名前      VARCHAR(40)  UNIQUE # UNIQUE 制約
);
```

このリストでは、NOT NULL、CHECK、UNIQUEという基本的な3種類の制約が使われています。

- **[その1] NOT NULL制約**
    - **NOT NULL制約**が設定された列には、NULLの格納は許可されません。例えば、家計簿テーブルがリスト10-5のようにして作られた場合、この節の最初に日付を指定せずにINSERTを実行するとエラーが発生して行の追加が失敗します。**※制約のおかげで、意図しない処理を中断してくれる。**
    - 尚、リスト10-5の「メモ」列のように、**NOT NULL制約はDEFAULT指定と組み合わせて利用**されることがほとんどです。デフォルト値が設定されていれば、INSERT文で特に値を入力しなくても自動的にその値が設定されるため、エラーにならないからです(リスト10-6)。
- リスト10-6 デフォルト値が設定されていれば、エラーにならない

```sql
-- メモを明示的に指定して INSERT → '家賃' が入る
INSERT INTO 家計簿 (日付, 費目ID, メモ, 入金額, 出金額)
     VALUES ('2018-04-04', 2, '家賃', 0, 60000);

-- メモを省略してINSERT → '不明' が入る
INSERT INTO 家計簿 (日付, 費目ID, 入金額, 出金額)
     VALUES ('2018-04-05', 3, 0, 1350);
```

**※列にNOT NULL制約がついていれば、複数行副問い合わせの落とし穴についても心配が減る。**

- **[その2] UNIQUE制約**
    - ある列の内容が決して重複してはならない場合、**UNIQUE制約**を付けます。例えば、費目テーブルは家計簿で利用される費目の一覧が格納されるテーブルです。通常、同じ名前の費目が複数あってはならないため、リスト10-5ではこの列にUNIQUE制約が指定されています(図10-5)。

### 10.3.3 主キー制約
主キーの列とは、「その列の値を指定すれば、どの1行のことかを完全に予定できる」という役割を与えられた列のことでした(p097)。リスト10-5の費目テーブルでいえば、「ID」列が主キーの役割を期待されている列でしょう。

そして、主キーがその役割を果たすためには、「他の行と重複してはならない」「必ず値が格納されなければならない(NULLであってはならない)」という2つの性質を満たさなければならないことも学びました。

主キータの役割を担う列には、主キー制約(PRIMARY KEY制約)を付けましょう。この制約がついている列は、単なる「NULLも重複も許されない列」ではなく、主キーとしての役割が期待されているという意味(セマンティクス)を持ちます。

主キー制約をつける方法は2つあります。ある単独の列に指定したい場合は、他の制約と同様、列名の末尾に記述します。
- リスト10-7 主キー制約の指定(1)

```sql
CREATE TABLE 費目 (
  ID   INTEGER        PRIMARY KEY, #PRIMARY KEYは主キー制約
  名前  VARCGAR(40)    UNIQUE
)
```

この記法を用いる場合、複数の列に主キー制約を指定することはできません。一方、リスト10-8のようにCREATE TABLE文の最後に記述する記法を用いれば複合主キーの指定も可能です。

- リスト10-8 主キー制約の指定(2)

```sql
CREATE TEBLE 費目 (
  ID   INTEGER,
  名前  VARCGAR(40)   UNIQUE,
  PRIMARY KEY(ID, 名前) # ID列と名前列で複合主キーを構成する
)
```

主キー列に関しては、万が一にもNULLや重複値が格納されると行が識別できないという致命的な状況に陥るため、**特別な理由がない限り、主キー制約を指定するようにしましょう**。</details>


<details><summary>10.4 外部キーと参照整合性</summary>

### 10.4.1 参照生合成の崩壊
外部キーが指し示す先にきちんと行が存在してリレーションシップが成立していることを参照整合性(referential integrity)といいます。逆に外部キーが指し示す先に行が存在しない状態になってしまうことを「参照整合性の崩壊」といわれ、データベース利用において絶対に避けなければならないことです。
- **参照整合性の崩壊**
    
    外部キーで別テーブルの行を参照しているのに、その行が存在しない状態をいう。このような状態になることは、絶対に避けなければならない。

### 10.4.2 崩壊の原因
どのようなSQLを実行すると参照整合性が崩壊してしまうのか、4つのパターンがあります。
- **参照整合性の崩壊を引き起こすデータ操作**
    1. 「他の行から参照されている」行を削除してしまう。
    2. 「他の行から参照されている」行の主キーを変更してしまう。
    3. 「存在しない行を参照する」行を追加してしまう。
    4. 「存在しない行を参照する」行に更新してしまう。

具体的に、図10-7の例で参照整合性を崩す4つのSQL文を次に表します。リストのコメントの丸数字は、左ページ下の4つのパターンを示します。
- リスト10-9 参照整合性制約を崩す例

```sql
-- 1.家計簿テーブルで利用中の費目について、費目テーブルから削除
DELETE FROM 費目 WHERE ID = 2;

-- 2.家計簿テーブルで利用中の費目について、費目テーブルのIDを変更
RPDATE 費目 SET ID = 5 WHERE ID = 1;

-- 3.家計簿テーブルに行を追加する際、費目テーブルに存在しない費目を指定
INSERT INTO 家計簿 (日付, 費目ID, 入金額, 出金額)
     VALUES ('2018-04-06', 99, 0, 800);

-- 4.家計簿テーブルの行を更新する際、費目テーブルに存在しない費目を指定
UPDATE 家計簿 SET 費目ID = 99
 WHERE 日付 = '2018-04-10';
```

### 10.4.3 外部キー制約
※人によるミスを防ぐには、「制約」。

参照整合性が崩れるようなデータ操作をしようとした場合にエラーを発生させ、強制的に処理を中断させる制約が外部キー制約(FOREIGN KEY制約)です。この制約は、参照元のテーブルの外部キー列に設定します。
- **外部キー制約の指定(1)**
    
    ```sql
    CREATE TABLE テーブル名 (
        列名  型   REFERENCES 参照先テーブル名(参照先列名)
        :
    )
    ```
    

家計簿テーブルに外部キー制約をかけるには、次のように記述します。

- リスト10-10 外部キー制約の指定

```sql
CREATE TABLE 家計簿 )
  日付   DATE           NOT NULL,
  費目ID INTEGER        REFERENCES 費目(ID), # 外部キー制約
  メモ   VARCHAR(100)   DEFAULT '不明' NOT NULL,
  入金額 INTEGER        DEFAULT 0 CHECK(入金額 >= 0),
  出金額 INTEGER        DEFAULT 0 CHECK(出金額 >= 0)
)
```

主キーの場合と同様に、CREATE TABLE文の最後にまとめて定義することも可能です。この場合は、「FOREIGN KEY」で制約を付ける列を指定します。
- 外部キー制約の指定(2)
    
    ```sql
    CREATE TABLE テーブル名 (
      :
       FOREIGN KEY(参照元列名) REFERENCES 参照先テーブル名(参照先列名)
    )
    ```
    
    こちらの構文を用いる場合の家計簿テーブルの例では、費目IDの列定義には制約を記述しない代わりに、最後に「FREIGN KEY(費目ID) REFERENCES 費目(ID)」という記述を加えることになるでしょう。

### 制約がついていなくても「主キー」
主キー制約がついている列は、主キーの列です。しかし、**この制約が付いていないからといって、主キーの列ではないとは言い切れません**。

主キー制約は、あくまでもその列に「主キーであれば果たすべき2つの責任(非NULL、および重複なし)を確実に果たさせるための安全装置」に過ぎません。制約が設定されていなくても、利用者が「行を識別するための列」として利用する列があれば、それは主キー列です。</details>


<details><summary>10.5 この章のまとめ</summary>

### 10.5.1 この章で学習した内容
- **4種類のSQL命令**
    - データを格納したり取り出したりする場合は、DMLに属する命令を使う。
    - データを格納するテーブル自体を作成したり削除したりする場合は、DDLに属する命令を使う。
    - トランザクションの開始や終了を指示する場合は、TCLに属する命令を使う。
    - DMLやDDLに関する許可や禁止を設定する場合は、DCLに属する命令を使う。
- **テーブルの作成と削除**
    - CREATE TABLE文を用いて、新規のテーブルを作成できる。
    - テーブル作成時に、列にデフォルト値を指定できる。
    - DROP TABLE文でテーブルを削除できる。
- **制約**
    - テーブル作成時に各列に制約を設定し、予期しない値が格納されないようにすることができる。
    - NOT NULL制約は、NULLの格納を防ぐことができる。
    - UNIQUE制約は、重複した値の格納を防ぐことができる。
    - CHECK制約は、格納しようとする値が妥当かどうかをチェックできる。
    - 主キーとして取り扱いたい列には、主キー制約を設定する。
    - データの更新や削除によって外部キーによる参照整合性が崩れることがないように、外部キー制約を設定する。

### 10.5.2 この章でできるようになったこと
- 「ID」列を主キーとする費目テーブルを作りたい。

```sql
CREATE TABLE 費目 (
    ID  INTEGER     PRIMARY KEY,
    名前 VARCHAR(40) UNIQUE
)
```

- 適切な制約を設定した家計簿テーブルを作りたい。

```sql
CREATE TABLE 家計簿 (
  日付    DATE         NOT NULL,
  費目ID  INTEGER      REFERENCES 費目(ID),
  メモ    VARCHAR(100) DEFAULT '不明' NOT NULL,
  入金額  INTEGER      DEFAULT 0 CHECK(入金額 >= 0),
  出金額  INTEGER      DEFAULT 0 CHECK(出金額 >= 0)
)
```

- 費目テーブルに「備考」列を追加したい。

```sql
ALTER TABLE 費目 ADD 備考 VARCHAR(50)
```

- 家計簿テーブルを削除したい。

```sql
DROP TABLE 家計簿
```

</details>

# 第11章 さまざまな支援機能
DBMSには、データベースを「より速く」「より便利に」「より安全に」使うための様々な機能が存在します。

この章では、それらの中から代表的なものを紹介していきましょう。

データベースを使うための命令をひととおり学び、データを格納するテーブルの作成もできるようになった今、もう1段階、歩みを進めてみたいと思います。

<details><summary>11.1 テータベースをより速くする</summary>

### 11.1.1 検索を早くする方法
本書の中から必要な箇所を探し出すために最も効率が良いのは巻末の「索引」を使って検索することではないでしょうか。データベース内のテーブルに対しても、書籍の索引と似たものを作ることができます。

### 11.1.2 インデックスの作成と削除
データベースで作成することのできる索引情報はインデックス(index)と呼ばれ、次のような特徴があります。
- **インデックスの特徴**
    - インデックスは、指定した列に対して作られる。
    - インデックスが存在する列に対して検索が行われた場合、DBMSは自動的にインデックスの使用を試みるため、高速になることが多い(検索の内容によってはインデックスの利用はできず性能も向上しないことがある)。
    - インデックスには名前を付けなければならない。

特に重要なのは、インデックスが「列ごとに」作られるという点です。例えば、家計簿テーブルの「費目ID」列に関するインデックスを作ると、検索条件に費目IDを指定した検索は高速になります。もし「メモ」列でも検索することが多ければ、メモ列にもインデックスを作成すべきでしょう。

インデックスを作成するには、DDLに属する命令であるCREATE INDEX文を使います。
- **インデックスの作成**
    
    ```sql
    CREATE INDEX インデックス名 ON テーブル名(列名)
    ```
    
- リスト11-1 家計簿テーブルにインデックスを2つ作る

```sql
CREATE INDEX 費目 ID インデックス ON 家計簿(費目ID);
CREATE INDEX メモインデックス ON 家計簿(メモ);
```

リスト11-1は、図11-1のように2つの列にインデックスを作る例です。費目IDやメモのそれぞれの値が家計簿テーブルのどの行に格納されているのかを記録したインデックスを、データベースないに作成することができます。

インデックス名は他と重複しない範囲で好きな名前を付けることができます。この名前は、**DROP INDEX文**でインデックスを削除するときにも使います。

- **インデックスの削除**
    
    ```sql
    DROP INDEX インデックス名
    # MySQLでは、「ON テーブル名」を付ける
    ```

尚、複数の列を1つのインデックスとする**複合インデックス**も作成可能です。

### 11.1.3 高速化のパターン
- **[ケース1] WHERE句による絞り込み**
    - 最もわかりやすいのは、WHERE句の絞り込み条件でインデックスを作成した列を利用する場合です。
    - リスト11-2 インデックスのある列をWHERE句に指定する(完全一致検索)
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ = '不明'
    ```
    

完全一致検索(全く同じ値であることを条件とした検索)では、インデックスが使用され、高速に検索結果を得ることができます。

DBMSの種類やインデックスの内部構造にもよりますが、文字列比較の場合、完全一致ではなく前方一致検索(最初の部分が一致することを条件とした検索)の場合でもインデックスを利用した高速な検索が行われることがあります。但し、部分一致検索(位置に関係なく任意の部分が一致すること条件とした検索)や、後方一致検索(末尾の部分が一致することを条件とした検索)では、インデックスを利用できませんので注意が必要です。

- リスト11-3 インデックスのある列をWHERE句に指定する(前方一致)

```sql
SELECT * FROM 家計簿
 WHERE メモ LIKE '1月の%'
```

- **[ケース2] ORDER BYによる並び替え**
    
    インデックスには並び替えを高速に行えるようにする効果もあるため、ORDER BYの処理が速くなります。
    
    - リスト11-4 インデックスのある列をORDER BY句に指定する
    
    ```sql
    SELECT * FROM 家計簿
     ORDER BY 費目 ID
    ```
    
- **[ケース3] JOINによる結合の条件**
    
    結合処理は内部で並び替えを行なっているため、インデックスのある列を使うと高速になります。
    
    - リスト11-5 インデックスのある列をJOINの結合条件に指定する
    
    ```sql
    SELECT * FROM 家計簿
      JOIN 費目
        ON 家計簿.費目ID = 費目.ID
    ```

これらのパターンからわかるように、次のような列にインデックスを設定すると高い効果が得られるでしょう。
- **一般的にインデックス設定の効果が高い列**
    - WHERE句に頻繁に登場する列。
    - ORDER BY句に頻繁に登場する列。
    - JOINの結合条件に頻繁に登場する列(外部キーの列)。
    
    ※実際にどのような検索にインデックスが利用されるかは、DBMS製品やDBMSが採用するインデックスのアルゴリズムに依存する。
    
    ※これらのパターンを理解した上で、どの列にインデックスを作成するかを考えることが重要。

### 11.1.4 インデックスの注意点
インデックスはただ作ればよいというものではありません。なぜなら、作成することにより、次のようなデメリットも生じるからです。

- **インデックスを作成することによるデメリット**
    - 索引情報を保持するために、ディスク容量を消費する。
    - テーブルのデータが変更されるとインデックスも書き換える必要があるため、INSERT文、UPDATE文、DELETE文のオーバーヘッドが増える。
        
        オーバーヘッド：コンピューターで，利用しているプログラムの作業に直接は関係のない処理。ハードウエア制御やプログラム管理などに要する処理。
        

特に重要なのが2つ目のデメリットです。例えば、「GROUP BYを紹介するページを3ページ後ろに変更する」場合、併せて索引の内容も書き換えなければなくなります。

同じ理由から、**インデックスが作成されている列のデータを変更する場合、DBMSはそのたびにインデックス情報を更新する必要があり、更新処理に時間がかかるようになってしまう**のです。

- **インデックスは濫用しない**
    
    検索性能は向上するが、書き換え時のオーバーヘッドは増加する。

※メリットとデメリットを検討して、インデックスを効果的に使うこと。</details>


<details><summary>11.2 データベースをより便利にする</summary>

### 11.2.1 ビュー
データベースを利用していると、同じようなSQL文を頻繁に実行していることに気付く場合があります。例えば、「4月のすべての入出金を表示する」および「4月に使った費目を一覧表示する」には、リスト11-6のようなSQL文を実行します。

- リスト11-6 4月の家計簿に関する様々なSQL文の実行

```sql
SELECT * FROM 家計簿
 WHERE 日付 >= '2018-04-01'
   AND 日付 <= '2018-04-30';
SELECT DISTINCT 費目ID FROM 家計簿
 WHERE 日付 >= '2018-04-01'
   AND 日付 <= '2018-04-30';
```

2つのSELECT文に同一のWHERE句が記述されています。4月についての検索を行うたび同じSQL文を書くのは面倒です。このような場合に便利なのが、結果表をテーブルのように扱える**ビュー**(view)という機能です。例えば私たちは、「SELECT文を使って家計簿テーブルから4月の分だけを抽出したもの」を「家計簿4月」ビューとして作成し、それをテーブルのように利用することができます。

ビューの作成に**はCREATE VIEW文を**、削除には**DROP VIEW文**を使います。

- **ビューの作成と削除**
    
    ```sql
    CREATE VIEW ビュー名 AS SELECT文
    
    DROP VIEW ビュー名
    ```
    
    4月のデータだけを抽出した「家計簿4月」のビューは、リスト11-7のようなSQL文によって作成することができます。
    
    - リスト11-7 4月に関する家計簿データのみを持つビューを定義
    
    ```sql
    CREATE VIEW 家計簿4月 AS
    SELECT * FROM 家計簿
     WHERE 日付 >= '2018-04-01'
       AND 日付 <= '2018-04-30'
    ```
    

このビューを使うことによって、リスト11-6は、次のリスト11-8のようにとてもシンプルに記述することができます。

- リスト11-8 家計簿4月ビューを使ったSQL文の実行

```sql
SELECT * FROM 家計簿4月;
SELECT DISTINCT 費目ID FROM 家計簿4月;
```

- **ビューのメリット**
    
    ビューを使うことで、SQL文がシンプルになる。

ビューにはもう1つメリットがあります。仮に、テーブルAのある列に機密情報が含まれており、一般の利用者にはその列を見せたくない状況であるとします。そのような場合、テーブルAから機密情報の列だけを除いたビューBを定義しておきます。DCL(データ制御言語)として簡単に紹介したGRANT文を使って、一般の利用者に対して「テーブルAはアクセス禁止、ビューBは許可」という設定をすることにより、データ参照を許可する範囲を利用者の立場に応じて適切に定めることができます。

### 11.2.2 ビュー制約とデメリット
**※結合して使うことの多いテーブルは、結合済みのものをビューとして定義しておくと便利。**

ビューは、テーブルとよく似ていますが、テーブルと全く同じというわけではありません。例えば、テーブルに対しては自由にINSERTやUPDATEを行うことができますが、ビューに対してはいくつかの条件(DBMSによって異なります)が揃わなければSELECTしか行うことができません。

これは、ビューがあくまでも仮想的なテーブルに過ぎず、データを内部に持っているわけではないからです。**ビューの実体は単なる「名前を付けたSELECT文」**でしかありません。

実際、リスト11-8のSQL文の実行指示を受け取ると、DBMSはビューを展開し、リスト11-6のSQL文に変換して実行しています。つまり、DBMSに対して私たちが送信しているSQL文は非常にシンプルであるのに対し、実際に実行されるSQL文は非常に複雑なものになってしまいます。そのため、想像以上に負荷の高い処理をDBMSに課すことになることもあるので注意が必要です。
- **ビューのデメリット**
    
    実行されるSQL文は、一見するよりも負荷の高い処理になる可能性がある。

### 11.2.3 採番の方法
あるテーブルに行を追加する場合、主キーの値を何にすべきか迷うことがあります。主キーである以上、既に使われている値と重複することは許されませんので、連番を振るという方法がよく用いられます。追加する行に独自の番号を振るために、適切な番号を取得することを**採番**ともいいます。

例えば、次ページ図11-5の費目テーブルの場合、主キーであるIDには連番を利用しています。しかし、この「連番を振る」ということは思いのほか面倒な作業です。行を追加する際には必ず「次にどの番号を使うべきか」と決める必要があり、「最後に使った番号は何番か？」を調べなければなりません。したがって、「最後に使った番号」をどこかに記録しておく必要があります。

実際の開発現場では、既に採番した番号や最後に採番した番号を、専用のテーブルに記録しておくなどの手法がよく使われます。この記録用のテーブルは**採番テーブル**と呼ばれ、工夫次第では記号や数字が混じった独自の番号も重複することなく採番することが可能です。管理するのは少し大変ですが、すべてのDBMSにおいて共通に利用できる、最も汎用的な方法です。

もし、単純な連番で良い場合、一部のDBMSでは連番を管理する機能が提供されています。但し、DBMS製品によって具体的な利用方法が異なるため、今回は代表的な種類についてのみ紹介していきましょう。

- **(1)連番が自動的に振られる特殊な列を定義できる**
    
    SQL ServerやMySQLなどの場合、CREATE TABLE文で列を定義する際に「連番を振る列である」ことを指定するだけで、データが追加されるタイミングで自動的に連番が振られるようになります。
    
    それぞれのDBMSにおいて列定義に指定すべき属性は、表のとおりです。

|  | SQL Server | MySQL | MariaDB | PostgreSQL | SQLite |
| --- | --- | --- | --- | --- | --- |
| 宣言に修飾 | IDENTITY | AUTO_INCREMENT | AUTO_INCREMENT | なし | IDENTITY   AUTOINCREMENT |
| 独自型を利用 | なし | SERIAL型 | SERIAL型 | SERIAL型 | SERIAL型 |

- リスト11-9 各DBMSにおける連番の指定

```sql
/* SQL Server の場合 */
CREATE TABLE 費目 (
  ID INTEGER IDENTITY PRIMARY KEY,
  名前 VARCHAR(40)
)

/* MySQL、MariaDBの場合*/
CREATE TABLE 費目 (
  ID INTEGER PRIMARY KEY AUTO_INCREMENT,
  名前 VARCHAR(40)
)

/* PostgreSQL の場合 */
CREATE TABLE 費目 (
  ID SERIAL PRIMARY KEY,
  名前 VARCHAR(40)
)

/* SQLite（AUTOINCREMENT利用）の場合 */
CREATE TABLE 費目 (
  ID INTEGER PRIMARY KEY AUTOINCREMENT,
  名前 VARCHAR(40)
)
```

あとは、INSERT文を実行すれば、指定した列には自動的に連番が振られていきます。尚、INSERT文で、ID列に明示的な値を指定してしまわないように注意してください。

- **(2)連番を管理してくれる専用の道具が提供されている**
    
    Oracle DB、Db2、SQL Server、PostgreSQLでは、専用の道具として**シーケンス**(sequence_が利用できます。シーケンスは常に採番した最新の値を記憶しており、シーケンスに指示をすることで「現在の値(=最後に採番した値)」や「次の値(=次に採番すべき値)」を取り出すことができます。
    
    但し、シーケンスから値を取り出すと、その操作はすぐに確定し、トランザクションをロールバックしてもシーケンスの値は戻りません。これは、1つのシーケンスが複数のトランザクションから利用されることを考慮しているためです。
    
    シーケンスは、CREATE SEQUENCE文で作成し、DROP SEQUENCE文で削除することができます。
    
- **シーケンスの作成と削除**
    
    ```sql
    CREATE SEQUENCE シーケンス名
    
    DROP EQUENCE シーケンス名
    ```
    
    シーケンスから値を取り出す方法はDBMS製品によって大きく異なります(各リストは省略)。
    
- (3)その他の方法
    
    DBMSによっては、独自の採番機構を提供しているものもあります。例えばSQLiteの場合、INTEGER型かつ主キー制約がついた列にNULLを意図的に格納することで、自動的に連番を生成し、その列に格納してくれます。</details>


<details><summary>11.3 データベースをより安全に使う</summary>

### - 11.3.1 信頼性のために備えるべき4つの特性
    
    第9章や第10章でも、DBMSに備わる様々な安全のための仕組みについて学んできました。あらためて振り返ると、**データベースによって「データを正確かつ安全に管理すること」がいかに大切か**がわかります。
    
    - **これまでに学んだ安全機構**
        - **コミットやロールバック**
            
            →途中で処理が中断しても、データが中途半端な状態にならない。
            
        - **型や制約**
            
            →あらかじめ指定した種類や条件に従った値だけを格納する。
            
        - **分離レベルやロック**
            
            →同時に実行している他の人の処理から副作用を受けない。
            
    
    ITの世界では、「データを正確かつ安全に取り扱うためにシステムが備えるべき4つの特性」として、**ACID特性**というものが広く知られています。これまで学んだ上記の3つの安全機構は、それぞれ、このACID特性の中の原子性、慣性、分離性の3つをカバーするためのものです。
    
    - **ACID特性**
        1. **原子性(Atomicity)**：処理が中断しても中途半端な状態にならない。
        2. **一貫性(Consistency)**：データの内容が矛盾した状態にならない。
        3. **分離性(Isolation)**：複数の処理を同時実行しても副作用がない。
        4. **永続性(Durability)**：記録した情報は消滅せず保持され続ける。
    
    データベースに格納されたデータは、勝手に消えたり壊れたりすることがあってはなりません。情報はメモリなどの一時的な保存領域ではなく**ハードディスクなどの磁気記憶媒体に記録**されます。しかし、ある日突然データを読み書きできなくなってしまう可能性もゼロではありません。情報の永続性を確保するための仕組みがDBMSには備わっているのです。

### 11.3.2 バックアップの仕組み
多くのDBMSは、万が一のデータ消失に備えて**バックアップ**(backup)の仕組みを備えています。それは、**データベースの全内容(テーブル構成や格納されたデータなど)をファイルに出力することができる**、というものです。具体的に使われるツールやコマンドはDBMS製品ごとに異なりますが、通常の業務システムの場合、**バックアップは毎日や毎週などの定期的な間隔で自動的に行われるように設定**されます。

出力されたバックアップファイルは、データベースから独立した別の記憶媒体(磁気記憶装置やテープ装置など)にコピーし、大切に保管しなければなりません。**万が一にも失われることが許されない極めて重要なデータの場合、地震などで建物ごと破壊されることも想定**し、**災害復旧対策**(DR:Disaster Recovery)の一環としてバックアップ媒体をいくつかの遠隔地に輸送して保管することもあります。

**※「もしも」を何重にも想定しておく対策が必要。**

### 11.3.3 バックアップの整合性
もし、INSERTやCREATE TABLEなどでデータベースの内容を書き換えている間にバックアップが行われると、作成したバックアップファイルは中途半端な状態となり、バックアップデータとして整合性がとれなくなる恐れがありあます。

整合性を保ちつつバックアップを行う最も簡単な方法は、データベースを停止してからバックアップを行う**オフラインバックアップ**です。

しかし、オフラインバックアップ中は一切のデータ処理が行えなくなります。データベースのバックアップには、データ量によって短くても数分、長いと数時間掛かることもあります。この間、データベースやそれを使ったシステムが停止してしまうことは状況によっては許されないかもしれません。

そのため、多くのDBMSは、稼働しながら整合性のあるバックアップデータを取得できる**オンラインバックアップ**機能も備えています。この機能は便利な反面、制約を伴うこともあるので、製品マニュアルをよく確認して利用してください。

- **2つのバックアップ方式**
    - オフラインバックアップ：DBMSを停止して行うバックアップ
    - オンラインバックアップ：DBMSを稼働させながら行うバックアップ

### 11.3.4 ログファイルのバックアップ
通常のバックアップは1日ごとなどの低い頻度で行う代わりに、データベースが出力する**ログファイルを10分周期や1時間周期といった高頻度でバックアップ**するのです。

- **2つのファイルをバックアップ**
    - データベースの内容……低頻度(日次、週次、月次など)で
    - ログファイルの内容……高頻度(数分ごと〜数時間ごとなど)で

DBMSが出力するログファイルは、そもそも人間が読むためのものではありません。データベースのログは、**REDOログ**(アーカイブログ)または**トランザクションログ**などとも呼ばれ、その**内容は「それまでに実行したすべてのSQL文」**にほかなりません。このログファイルを高い頻度でバックアップしておくと、データ消失時にも次のような手順を踏むことで、消失直前の時点までデータを復元することができます。

- **バックアップからのデータ復元方法**
    - 最後に取得したデータベースのバックアップを復元する。
    - ログに記録されているSQL文のうち、「最後のデータベースバックアップ以降に実行されたもの」を再実行する。

尚、ログに記録されているSQL文を再実行して、障害が発生する直前の状態までデータを更新する処理のことを**ロールフォワード**(roll forward)といいます。ロールバックと名前が似ており、処理内容としても両者は対照的な関係にありますが、混同しないようにしましょう。

- **ロールバックとロールフォワード**
    - ロールバック(実行した処理を取り消す)：データベースの利用中に、SQLの実行失敗やデッドロックなどでたびたび発生する。
    - ロールフォワード(まだ実行されていない処理を実行する)：障害復旧時に行われる処理であるため、滅多に発生しない。</details>


<details><summary>11.4 この章のまとめ</summary>

### 11.4.1 この章で学習した内容
- **インデックス**
    - テーブルの列に対して、索引情報を生成することができる。
    - インデックスが存在する列に対する検索は、多くの場合、高速になる。
    - すべての検索でインデックスが使われるわけではない。
    - インデックスは書き込み性能の低下を招くこともあるため濫用は禁物。
- **ビュー**
    - SELECT文の結果表を仮想的なテーブルとして扱うことができる。
    - ビューを使うことでSQL文はシンプルになるが、その実体は単なるSELECT文のため、DBMSの負荷は変わらない。
- **採番とシーケンス**
    - 連番を生成する列定義やシーケンスを使って、連番を簡単に生成できる。
    - 数字と記号を組み合わせたような複雑な採番を行う場合は、採番テーブルを作るなどして自力で実装する必要がある。
- **バックアップ**
    - 正確なデータ処理には、原子性、一貫性、分離性に永続性を加えた4特性(ACID特性)が求められる。
    - 記録媒体が障害を起こした場合に備え、バックアップを取得する。
    - データベースの内容だけでなく、ログファイルもバックアップし、ロールフォワードを行うことで、障害発生直前の状態までデータを復元することができる。

### 11.4.2 この章でできるようになったこと
- 日付での並び替えや費目IDによる結合を行う家計簿テーブルの検索を高速に行いたい。

```sql
CREATE INDEX 日付インデックス ON 家計簿(日付);
CREATE INDEX 費目IDインデックス ON 家計簿(費目ID);
```

- 費目テーブルと結合済みの家計簿をビューを利用して手軽に使えるようにしたい。

```sql
CREATE VIEW 費目名付き家計簿 AS
SELECT * FROM 家計簿
  JOIN 費目
    ON 家計簿.費目ID = 費目.ID
```

</details>


<details><summary>高速化の効果を測ろう</summary>

DBMSは指示されたSQL文をただ闇雲に実行するわけではありません。DBMSの環境に応じて、どの表に、どの順番で、どのような方法でアクセスすれば最も高速であるかを分析し、プラン(plan)と呼ばれる作戦を立ててから実行に移ります。プランでは、インデックスを使って検索を行うか、1行ずつ地道に調べていくかなどの決定も含まれています。

詳細な構文はDBMSごとに異なりますが、EXPLAIN PLAN文またはEXPLAIN文を使って指定したSQL文を実行するプランを調べることができます。インデックスを作成することにより処理がどのくらい速くなるか、目安を得たい場合にも有効です。

(例：MySQLの場合)

```sql
EXPLAIN SELECT * FROM 家計簿 WHERE メモ = '不明'
```

</details>


<details><summary>データベースオブジェクトとは</summary>

データの管理や操作のために、データベースないに作成するテーブルやビュー、インデックスやシーケンスなどを総称して、**データベースオブジェクト**といいます。DDLで作成できるものがこれにあたります。

DDL：Data Definition Language、データ定義言語のこと。テーブルなどの作成や削除、各種設定などの命令。</details>
