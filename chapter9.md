# 第9章 トランザクション
第Ⅱ部までDBMSでデータを操作するためのさまざまなSQLの構文を学んできました。

しかし、DBMSにSQL文を送っても、常に正しくデータ操作が完了するとは限りません。

処理中に突然コンピュータの電源が落ちてしまうかもしれませんし、他の人が書き換え途中のデータを読み込んでしまうかもしれません。

この章では、そのような思いがけない事態に備え、安全で確実なデータ操作を実現するDBMSの機能について紹介します。

<details><summary>9.1 正確なデータ操作</summary>

### 9.1.1 正確なデータ操作を脅かすもの
**安全で確実なデータ操作とデータ管理ほど重要なことはありません。**

DBMSはSQL文の指示通りに正確な処理を実行してくれます。理論的には、データベースないに誤ったデータを格納することはできないと感じるかもしれません。しかし現実には、DBMSが正しく処理を完了できなかったり、テーブル内のデータがおかしな値になってしまったりする可能性があります。

たとえば、急にコンピュータの電源が落ちて、一連のSQLの処理が中途半端なところで中断してしまうかもしれません。また、読み書きしかけていたデータを他人が横から書き換えてしまう可能性もあります。

### 9.1.2 トランザクション
①予期しない処理中断、②同時操作の2つのケースは、金融機関の基幹システムのように極めて重要なシステムでも発生する可能性があります。しかし、「停電があったのでデータベースが壊れ、残高がおかしくなりました」という言い訳は許されません。

そこで、DBMSにはこのような問題が起きないようにするための仕組みが備わっています。

実は私たちがDBMSに対して複数のSQL文を送る際、1つ以上のSQL文をひとかたまりとして扱うよう指示することができます。このかたまりのことを**トランザクション**(transaction)といいます。

DBMSはトランザクションを次のように扱います。
- **DBMSによるトランザクションの制御**
    - トランザクションの途中で、処理が中断されないようにする。
    - トランザクションの途中に、他の人の処理が割り込めないようにする。

DBMSがこのようにひとかたまりのSQL文を扱うことをトランザクション制御(transaction control)といいます。

### SQLにおけるセミコロンの取り扱い
1つのSQL分の終了を表すためにセミコロンを用いる方法があることは触れました(p043)。「仮に単一のSQL文であっても、常にSQLの文末にはセミコロンを付ける」「末尾のセミコロンまで含めてSQLの文法」という理解をしても概ね差し支えありません。

但し、**現状では多くのDBMS製品がセミコロンを「SQLの構文規則」というよりは、文の区切りを判定するための「単なる記号」として扱っている点には注意が必要**です。たとえば、文の区切りをセミコロン以外の別の記号に設定できるDBMSは多数存在します。また、単一のSQL文であることが明らかな場合にセミコロンを付けると、エラーになってしまうこともあります(例：Oracle DBにおいてJavaから単一SQL文を直接送信する場合)。

この現状に鑑み、本書では、1つのリストで複数のSQL文を紹介する場合(リスト9-1など)にのみ、文末にセミコロンを記述しています。</details>


<details><summary>9.2 コミットとロールバック</summary>

### 9.2.1 トランザクションの中断
複数のSQL文を実行している最中に処理が中断してしまうと問題となるケースはたくさんあります。代表的なのが「金融機関における振り込み処理」です。

振り込み処理を実現するためには、「振込先口座の残高を減らす」「振込先口座の残高を増やす」という2つのUPDATE文の実行が必要です。しかし、最初のSQL文の実行が成功した直後にDBMSが異常停止して処理が中断してしまったら、「振込元口座からはお金が減らされたのに、振込先にはお金が増えない」事態となってしまいます。

この問題は、2つのUPDATE文を1つのトランザクションとして扱うようにDBMSに指示することで解決できます。なぜなら、DBMSはどんな非常時であっても、**トランザクションを「一部だけが実行されることはあってはならない、途中で分割不可能なもの」として取り扱う**からです。
- **DBMSによるトランザクション制御(1)**
    
    DBMSは、トランザクションに含まれるすべてのSQL文について、必ず「全ての実行が完了している」か「1つも実行されていない」のどちらかの状態になるように制御する。
トランザクションに含まれる複数のSQL文が、DBMSによって不可分なものとして扱われる性質のことをトランザクションの**原子性**(atomicity)といいます。

※原子性：「原子」のように、それ以上細かく分割できないことから。

### 9.2.2 原子性確保の仕組み
トランザクション中のSQL文によってテーブルのデータが書き換えられると、それは確定ではなく仮のものとして管理されます。そして、トランザクションが終了する際に、それら「仮の書き換え」を全て確定したことにするのです。この確定行為のことを**コミット**(commit)といいます。

もし、トランザクション中に異常が発生して中断した場合、DBMSはそれまで行った全ての仮の書き換えをキャンセルして、「なかったこと」にします。このDBMSによる「なかったこと」にする動作を**ロールバック**(rollback)といい、SQL文のエラーで失敗したり、明示的にキャンセルが指示された場合などに行われます。もちろん、電源が落ちて突然処理が中断した場合も、再びデータベースを起動した際に自動的にロールバックが行われます。

### 9.2.3 トランザクションの指定方法
私たちが「複数あるSQL文のうち、どの範囲が1つのトランザクションであるか」を伝えれば、DBMSは適切に制御してくれます。より具体的には、次の3つのSQL文を使って指示を行います。
- **トランザクションを使うための指示**
    - **BEGIN**
        - 開始の指示。この指示以降のSQL文を1つのトランザクションとする。
    - **COMMIT**
        - 終了の指示。この指示までを1つのトランザクションとし、変更を確定する。
    - **ROLLBACK**
        - 終了の指示。この指示までを1つのトランザクションとし、変更の取り消しをする。
たとえば、家計簿テーブルの2018年1月以前のデータを家計簿アーカイブテーブルに移動する場合は、リスト9-1のようなSQL文を記述します。

- リスト9-1 1月のデータをアーカイブテーブルに移動する

```sql
BEGIN;
-- 処理1: アーカイブテーブルへコピー
INSERT INTO 家計簿アーカイブ
SELECT * FROM 家計簿 WHERE 日付 <= '2018-01-31'
-- 処理2: 家計簿テーブルから削除
DELETE FROM 家計簿 WHERE 日付 <= '2018-01-31'
COMMIT;
# INSERT文~DELETE文までがトランザクション
```

このSQL文を実行すると、処理1と処理2を不可分なものとして扱います。もし処理1を実行した直後に障害が発生した場合、自動的にロールバックが行われ、処理1の実行は取り消されます。

尚、「**ROLLBACK**」というSQL文をDBMSに送ることで、明示的にロールバックを発生させることも可能です。

### 9.2.4 自動コミットモードの解除
トランザクションがまだコミットされていない状態であれば、DELETE文によるデータ削除でさえもキャンセルすることは可能です。しかし、dokoQLのほか、各DBMS付属のSQL実行ツールを使っていると、ロールバックができないことがあります。

これは、多くのツールがデフォルト状態では**自動コミットモード**(auto commit mode)と呼ばれるモードで動作するからです。このモードにある時、DBMSは**1つのSQL文が実行されるたびに、自動的に裏でコミットを実行**してしまいます。

DBMSによっては、自動コミットモード中であっても「**BEGIN**」を実行することで、コミットかロールバックまでの間、一時的に自動コミットを解除することができます。

明示的に自動コミットモードを解除するための方法はツールや環境によって異なります。たとえば、MySQLでは「**SET AUTOCOMMIT=0**」というSQL文を実行します。</details>


<details><summary>9.3 トランザクションの分離</summary>

### 9.3.1 同時実行の副作用
世の中で利用されている情報システムにおいては、**多くの利用者から1つのDBMSに対してたくさんのSQL文が送られます**。

DBMSはそれらの要求を同時に処理しようとしますので、同じ行を複数の利用者が同時に読み書きする可能性も大いにあります。しかし、そのような状態が発生すると、副作用が発生し、正しい処理が行えない場合があります。

たとえば、1つの口座に対して、10,000円の引き出しと電気代6,200円が引き落とされたとします。ほぼ同時に2つの処理が行われようとした時、この2つの処理要求はほぼ同時に行われているため、どのような順番で実行されるかはわかりません。仮に、次のような順番でDBMSが処理しようとしたとしましょう。

1. ATMからの引き落とし要求に従い、口座残高を10,000円減らし、20,000円にする(仮)。
2. 電力会社からの引き落とし要求に従い、口座残高をさらに6,200円減らし、13,800円にする(仮)。
3. ATMからの要求に従い、1.によるデータ変更を確定して現金10,000円を払い戻す。
4. 電力会社からの要求に従い、2.によるデータ変更を確定する。

かなりの確率で、このように正しく2つの出金が行われ、最終的な口座残高は13,800円となるでしょう。しかし万一、1.の処理が途中で止まってしまった場合はどうなるでしょうか。

1.の処理が中断されてロールバックが行われたなら、10,000円を引き出そうとしたアクションは「なかったこと」にされているはずです。しかし、1.2.の両方の金額が引かれてしまい、口座残高は13,800円になってしまいました。

### 9.3.2 3つの代表的な副作用
DBMSに対して複数の利用者が同時に処理を要求することで発生する副作用には、次の3つのものが知られています。
- **副作用1 ダーティーリード**
    - まだコミットされていない未確定の変更を、他の人が読めてしまうという副作用を**ダーティーリード**(dirty read)といいます。ATMからの出金がまだ確定していない状態で、電力会社がその仮の残高をダーティーリードしてしまい、さらに電気代を引いてしまったために発生しています。その後キャンセルされてしまうかもしれない未確定の情報をもとにして別の処理を行なってしまうため、ダーティーリードは非常に危険な副作用です。
- **副作用2 反復不能読み取り**
    - **反復不能読み取り**(non-repeatable read)とは、あるテーブルに対してSELECT文を実行した後、他の人がUPDATE文でデータを書き換えると、次回SELECTした際に検索結果が異なってしまうという副作用です。
テーブルの内容を複数回読み取る際、その間にデータの内容が変化してしまっては困る場合があります。たとえば、家計簿テーブルの統計を取るために「①出金額の合計を集計する」「②出金額の最大値を集計する」計算の処理を2つのSELECT文で順番に実行しているとしましょう。

常識的に考えれば、②の結果が①の結果より大きくなることはありません。しかし、①のSELECT文が実行された直後に、他の人によって一部のデータが書き換えられると、②の結果が①より大きくなり、データの整合性が崩れてしまうことがあり得ます。
- **副作用3 ファントムリード**
    - **ファントムリード**(phantom read)は、反復不能読み取りと似ています。2回のSELECT文の間に、他の人がINSERT文で行を追加すると、2回のSELECTで結果行数が変わってしまうという副作用です。1回目の検査結果の行数に依存するような処理を行う場合に、問題となることがあります。

### 9.3.3 トランザクションの分離
しかし、前項で紹介した副作用は、トランザクションによって解決することができます。なぜなら、DBMSは個々のトランザクションについて分離性(isolation)を維持するために次のような制御を行うからです。
- **DBMSによるトランザクション制御(2)**
    
    DBMSは、あるトランザクションを実行する際、ほかのトランザクションから影響を受けないよう、分離して実行する。つまり、仮にほかのトランザクションと同時に実行していたとしても、あたかも単独で実行しているのと同じ結果となるよう制御する。
DBMSはこの制御を行うために、内部で**ロック**(lock)と呼ばれる仕組みを使います。あるトランザクションが現在読み書きしている行に鍵をかけ、ほかの人のトランザクションからは読み書きできないようにしてしまうのです。

このように、あるトランザクションが特定の行などをロックすることを「ロックを取る」「ロックを取得する」と表現することもあります。

自分のトランザクションがコミットまたはロールバックで終了すると、かけた鍵は解除され、ほかの人のトランザクションがその行を読み書きできるようになります。

つまり、自分が読み書きしたい行を他人がロックしている間、その**相手のトランサクションが完了するまで自分は待たされます**。このロック待ち時間は通常数ミリ秒以下と大変短いものですが、ロックがたくさん発生すると、データベースの動作は非常に遅くなってしまう点には注意が必要です。

### 9.3.4 分離レベル
トランザクションを使うことでロックの仕組みが有効になり、副作用は発生しないようになる一方、DBMSのパフォーマンスは損なわれてしまいます。このように、正確なデータ操作とパフォーマンスは二律背反の関係にありますが、どちらか片方しか選べないというわけではありません。

多くのDBMSでは、どの程度厳密にトランザクションを分離するかを**トランザクション分離レベル**(transaction isolation level)として指定することができます。

| 分離レベル | ダーティーリード | 反復不能読み取り | ファントムリード |  |
| --- | --- | --- | --- | --- |
| READ UNCOMMITTED | 恐れあり | 恐れあり | 恐れあり | ↑高速危険 |
| READ COMMITTED | 発生しない | 恐れあり | 恐れあり |  |
| REPEATABLE READ | 発生しない | 発生しない | 恐れあり |  |
| SERIALIZABLE | 発生しない | 発生しない | 発生しない | ↓安全低速 |

多くのDBMSでは、デフォルトでREAD COMMITTEDという分離レベルで動作しています。このレベルは、さほど厳しいロックをかけないためダーティーリードしか防ぐことはできませんが、ある程度高速に動作するという特徴を持っています。

ほかの分離レベルを利用したい場合、多くのDBMSではSET TRANSACTION ISOLATION LEVEL命令を使用して任意の分離レベルを選択することができます。
- **トランザクション分離レベルの指定**
    
    ```sql
    SET TRANSACTION ISOLATION LEVEL 分離レベル名
    SET CURRENT ISOLATION 分離レベル名
    # どちらの構文を使うかは、DBMS製品によって異なる。
    ```
    

たとえば、最も安全だけれどデータベースの処理速度は落ちてしまうSERIALIZABLEという分離レベルを使う場合、リスト9-2のように指定します。

- リスト9-2 SERIALIZABLE 分離レベルを選択する

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
```

- **READ UNCOMMITTEDが無効である理由**
