# 第11章 さまざまな支援機能
DBMSには、データベースを「より速く」「より便利に」「より安全に」使うための様々な機能が存在します。

この章では、それらの中から代表的なものを紹介していきましょう。

データベースを使うための命令をひととおり学び、データを格納するテーブルの作成もできるようになった今、もう1段階、歩みを進めてみたいと思います。

<details><summary>11.1 テータベースをより速くする</summary>

### 11.1.1 検索を早くする方法
本書の中から必要な箇所を探し出すために最も効率が良いのは巻末の「索引」を使って検索することではないでしょうか。データベース内のテーブルに対しても、書籍の索引と似たものを作ることができます。

### 11.1.2 インデックスの作成と削除
データベースで作成することのできる索引情報はインデックス(index)と呼ばれ、次のような特徴があります。
- **インデックスの特徴**
    - インデックスは、指定した列に対して作られる。
    - インデックスが存在する列に対して検索が行われた場合、DBMSは自動的にインデックスの使用を試みるため、高速になることが多い(検索の内容によってはインデックスの利用はできず性能も向上しないことがある)。
    - インデックスには名前を付けなければならない。

特に重要なのは、インデックスが「列ごとに」作られるという点です。例えば、家計簿テーブルの「費目ID」列に関するインデックスを作ると、検索条件に費目IDを指定した検索は高速になります。もし「メモ」列でも検索することが多ければ、メモ列にもインデックスを作成すべきでしょう。

インデックスを作成するには、DDLに属する命令であるCREATE INDEX文を使います。
- **インデックスの作成**
    
    ```sql
    CREATE INDEX インデックス名 ON テーブル名(列名)
    ```
    
- リスト11-1 家計簿テーブルにインデックスを2つ作る

```sql
CREATE INDEX 費目 ID インデックス ON 家計簿(費目ID);
CREATE INDEX メモインデックス ON 家計簿(メモ);
```

リスト11-1は、図11-1のように2つの列にインデックスを作る例です。費目IDやメモのそれぞれの値が家計簿テーブルのどの行に格納されているのかを記録したインデックスを、データベースないに作成することができます。

インデックス名は他と重複しない範囲で好きな名前を付けることができます。この名前は、**DROP INDEX文**でインデックスを削除するときにも使います。

- **インデックスの削除**
    
    ```sql
    DROP INDEX インデックス名
    # MySQLでは、「ON テーブル名」を付ける
    ```

尚、複数の列を1つのインデックスとする**複合インデックス**も作成可能です。

### 11.1.3 高速化のパターン
- **[ケース1] WHERE句による絞り込み**
    - 最もわかりやすいのは、WHERE句の絞り込み条件でインデックスを作成した列を利用する場合です。
    - リスト11-2 インデックスのある列をWHERE句に指定する(完全一致検索)
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ = '不明'
    ```
    

完全一致検索(全く同じ値であることを条件とした検索)では、インデックスが使用され、高速に検索結果を得ることができます。

DBMSの種類やインデックスの内部構造にもよりますが、文字列比較の場合、完全一致ではなく前方一致検索(最初の部分が一致することを条件とした検索)の場合でもインデックスを利用した高速な検索が行われることがあります。但し、部分一致検索(位置に関係なく任意の部分が一致すること条件とした検索)や、後方一致検索(末尾の部分が一致することを条件とした検索)では、インデックスを利用できませんので注意が必要です。

- リスト11-3 インデックスのある列をWHERE句に指定する(前方一致)

```sql
SELECT * FROM 家計簿
 WHERE メモ LIKE '1月の%'
```

- **[ケース2] ORDER BYによる並び替え**
    
    インデックスには並び替えを高速に行えるようにする効果もあるため、ORDER BYの処理が速くなります。
    
    - リスト11-4 インデックスのある列をORDER BY句に指定する
    
    ```sql
    SELECT * FROM 家計簿
     ORDER BY 費目 ID
    ```
    
- **[ケース3] JOINによる結合の条件**
    
    結合処理は内部で並び替えを行なっているため、インデックスのある列を使うと高速になります。
    
    - リスト11-5 インデックスのある列をJOINの結合条件に指定する
    
    ```sql
    SELECT * FROM 家計簿
      JOIN 費目
        ON 家計簿.費目ID = 費目.ID
    ```

これらのパターンからわかるように、次のような列にインデックスを設定すると高い効果が得られるでしょう。
- **一般的にインデックス設定の効果が高い列**
    - WHERE句に頻繁に登場する列。
    - ORDER BY句に頻繁に登場する列。
    - JOINの結合条件に頻繁に登場する列(外部キーの列)。
    
    ※実際にどのような検索にインデックスが利用されるかは、DBMS製品やDBMSが採用するインデックスのアルゴリズムに依存する。
    
    ※これらのパターンを理解した上で、どの列にインデックスを作成するかを考えることが重要。

### 11.1.4 インデックスの注意点
インデックスはただ作ればよいというものではありません。なぜなら、作成することにより、次のようなデメリットも生じるからです。

- **インデックスを作成することによるデメリット**
    - 索引情報を保持するために、ディスク容量を消費する。
    - テーブルのデータが変更されるとインデックスも書き換える必要があるため、INSERT文、UPDATE文、DELETE文のオーバーヘッドが増える。
        
        オーバーヘッド：コンピューターで，利用しているプログラムの作業に直接は関係のない処理。ハードウエア制御やプログラム管理などに要する処理。
        

特に重要なのが2つ目のデメリットです。例えば、「GROUP BYを紹介するページを3ページ後ろに変更する」場合、併せて索引の内容も書き換えなければなくなります。

同じ理由から、**インデックスが作成されている列のデータを変更する場合、DBMSはそのたびにインデックス情報を更新する必要があり、更新処理に時間がかかるようになってしまう**のです。

- **インデックスは濫用しない**
    
    検索性能は向上するが、書き換え時のオーバーヘッドは増加する。

※メリットとデメリットを検討して、インデックスを効果的に使うこと。</details>


<details><summary>11.2 データベースをより便利にする</summary>

### 
