# 第11章 さまざまな支援機能
DBMSには、データベースを「より速く」「より便利に」「より安全に」使うための様々な機能が存在します。

この章では、それらの中から代表的なものを紹介していきましょう。

データベースを使うための命令をひととおり学び、データを格納するテーブルの作成もできるようになった今、もう1段階、歩みを進めてみたいと思います。

<details><summary>11.1 テータベースをより速くする</summary>

### 11.1.1 検索を早くする方法
本書の中から必要な箇所を探し出すために最も効率が良いのは巻末の「索引」を使って検索することではないでしょうか。データベース内のテーブルに対しても、書籍の索引と似たものを作ることができます。

### 11.1.2 インデックスの作成と削除
データベースで作成することのできる索引情報はインデックス(index)と呼ばれ、次のような特徴があります。
- **インデックスの特徴**
    - インデックスは、指定した列に対して作られる。
    - インデックスが存在する列に対して検索が行われた場合、DBMSは自動的にインデックスの使用を試みるため、高速になることが多い(検索の内容によってはインデックスの利用はできず性能も向上しないことがある)。
    - インデックスには名前を付けなければならない。

特に重要なのは、インデックスが「列ごとに」作られるという点です。例えば、家計簿テーブルの「費目ID」列に関するインデックスを作ると、検索条件に費目IDを指定した検索は高速になります。もし「メモ」列でも検索することが多ければ、メモ列にもインデックスを作成すべきでしょう。

インデックスを作成するには、DDLに属する命令であるCREATE INDEX文を使います。
- **インデックスの作成**
    
    ```sql
    CREATE INDEX インデックス名 ON テーブル名(列名)
    ```
    
- リスト11-1 家計簿テーブルにインデックスを2つ作る

```sql
CREATE INDEX 費目 ID インデックス ON 家計簿(費目ID);
CREATE INDEX メモインデックス ON 家計簿(メモ);
```

リスト11-1は、図11-1のように2つの列にインデックスを作る例です。費目IDやメモのそれぞれの値が家計簿テーブルのどの行に格納されているのかを記録したインデックスを、データベースないに作成することができます。

インデックス名は他と重複しない範囲で好きな名前を付けることができます。この名前は、**DROP INDEX文**でインデックスを削除するときにも使います。

- **インデックスの削除**
    
    ```sql
    DROP INDEX インデックス名
    # MySQLでは、「ON テーブル名」を付ける
    ```

尚、複数の列を1つのインデックスとする**複合インデックス**も作成可能です。

### 11.1.3 高速化のパターン
- **[ケース1] WHERE句による絞り込み**
    - 最もわかりやすいのは、WHERE句の絞り込み条件でインデックスを作成した列を利用する場合です。
    - リスト11-2 インデックスのある列をWHERE句に指定する(完全一致検索)
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ = '不明'
    ```
    

完全一致検索(全く同じ値であることを条件とした検索)では、インデックスが使用され、高速に検索結果を得ることができます。

DBMSの種類やインデックスの内部構造にもよりますが、文字列比較の場合、完全一致ではなく前方一致検索(最初の部分が一致することを条件とした検索)の場合でもインデックスを利用した高速な検索が行われることがあります。但し、部分一致検索(位置に関係なく任意の部分が一致すること条件とした検索)や、後方一致検索(末尾の部分が一致することを条件とした検索)では、インデックスを利用できませんので注意が必要です。

- リスト11-3 インデックスのある列をWHERE句に指定する(前方一致)

```sql
SELECT * FROM 家計簿
 WHERE メモ LIKE '1月の%'
```

- **[ケース2] ORDER BYによる並び替え**
    
    インデックスには並び替えを高速に行えるようにする効果もあるため、ORDER BYの処理が速くなります。
    
    - リスト11-4 インデックスのある列をORDER BY句に指定する
    
    ```sql
    SELECT * FROM 家計簿
     ORDER BY 費目 ID
    ```
    
- **[ケース3] JOINによる結合の条件**
    
    結合処理は内部で並び替えを行なっているため、インデックスのある列を使うと高速になります。
    
    - リスト11-5 インデックスのある列をJOINの結合条件に指定する
    
    ```sql
    SELECT * FROM 家計簿
      JOIN 費目
        ON 家計簿.費目ID = 費目.ID
    ```

これらのパターンからわかるように、次のような列にインデックスを設定すると高い効果が得られるでしょう。
- **一般的にインデックス設定の効果が高い列**
    - WHERE句に頻繁に登場する列。
    - ORDER BY句に頻繁に登場する列。
    - JOINの結合条件に頻繁に登場する列(外部キーの列)。
    
    ※実際にどのような検索にインデックスが利用されるかは、DBMS製品やDBMSが採用するインデックスのアルゴリズムに依存する。
    
    ※これらのパターンを理解した上で、どの列にインデックスを作成するかを考えることが重要。

### 11.1.4 インデックスの注意点
インデックスはただ作ればよいというものではありません。なぜなら、作成することにより、次のようなデメリットも生じるからです。

- **インデックスを作成することによるデメリット**
    - 索引情報を保持するために、ディスク容量を消費する。
    - テーブルのデータが変更されるとインデックスも書き換える必要があるため、INSERT文、UPDATE文、DELETE文のオーバーヘッドが増える。
        
        オーバーヘッド：コンピューターで，利用しているプログラムの作業に直接は関係のない処理。ハードウエア制御やプログラム管理などに要する処理。
        

特に重要なのが2つ目のデメリットです。例えば、「GROUP BYを紹介するページを3ページ後ろに変更する」場合、併せて索引の内容も書き換えなければなくなります。

同じ理由から、**インデックスが作成されている列のデータを変更する場合、DBMSはそのたびにインデックス情報を更新する必要があり、更新処理に時間がかかるようになってしまう**のです。

- **インデックスは濫用しない**
    
    検索性能は向上するが、書き換え時のオーバーヘッドは増加する。

※メリットとデメリットを検討して、インデックスを効果的に使うこと。</details>


<details><summary>11.2 データベースをより便利にする</summary>

### 11.2.1 ビュー
データベースを利用していると、同じようなSQL文を頻繁に実行していることに気付く場合があります。例えば、「4月のすべての入出金を表示する」および「4月に使った費目を一覧表示する」には、リスト11-6のようなSQL文を実行します。

- リスト11-6 4月の家計簿に関する様々なSQL文の実行

```sql
SELECT * FROM 家計簿
 WHERE 日付 >= '2018-04-01'
   AND 日付 <= '2018-04-30';
SELECT DISTINCT 費目ID FROM 家計簿
 WHERE 日付 >= '2018-04-01'
   AND 日付 <= '2018-04-30';
```

2つのSELECT文に同一のWHERE句が記述されています。4月についての検索を行うたび同じSQL文を書くのは面倒です。このような場合に便利なのが、結果表をテーブルのように扱える**ビュー**(view)という機能です。例えば私たちは、「SELECT文を使って家計簿テーブルから4月の分だけを抽出したもの」を「家計簿4月」ビューとして作成し、それをテーブルのように利用することができます。

ビューの作成に**はCREATE VIEW文を**、削除には**DROP VIEW文**を使います。

- **ビューの作成と削除**
    
    ```sql
    CREATE VIEW ビュー名 AS SELECT文
    
    DROP VIEW ビュー名
    ```
    
    4月のデータだけを抽出した「家計簿4月」のビューは、リスト11-7のようなSQL文によって作成することができます。
    
    - リスト11-7 4月に関する家計簿データのみを持つビューを定義
    
    ```sql
    CREATE VIEW 家計簿4月 AS
    SELECT * FROM 家計簿
     WHERE 日付 >= '2018-04-01'
       AND 日付 <= '2018-04-30'
    ```
    

このビューを使うことによって、リスト11-6は、次のリスト11-8のようにとてもシンプルに記述することができます。

- リスト11-8 家計簿4月ビューを使ったSQL文の実行

```sql
SELECT * FROM 家計簿4月;
SELECT DISTINCT 費目ID FROM 家計簿4月;
```

- **ビューのメリット**
    
    ビューを使うことで、SQL文がシンプルになる。

ビューにはもう1つメリットがあります。仮に、テーブルAのある列に機密情報が含まれており、一般の利用者にはその列を見せたくない状況であるとします。そのような場合、テーブルAから機密情報の列だけを除いたビューBを定義しておきます。DCL(データ制御言語)として簡単に紹介したGRANT文を使って、一般の利用者に対して「テーブルAはアクセス禁止、ビューBは許可」という設定をすることにより、データ参照を許可する範囲を利用者の立場に応じて適切に定めることができます。

### 11.2.2 ビュー制約とデメリット
**※結合して使うことの多いテーブルは、結合済みのものをビューとして定義しておくと便利。**

ビューは、テーブルとよく似ていますが、テーブルと全く同じというわけではありません。例えば、テーブルに対しては自由にINSERTやUPDATEを行うことができますが、ビューに対してはいくつかの条件(DBMSによって異なります)が揃わなければSELECTしか行うことができません。

これは、ビューがあくまでも仮想的なテーブルに過ぎず、データを内部に持っているわけではないからです。**ビューの実体は単なる「名前を付けたSELECT文」**でしかありません。

実際、リスト11-8のSQL文の実行指示を受け取ると、DBMSはビューを展開し、リスト11-6のSQL文に変換して実行しています。つまり、DBMSに対して私たちが送信しているSQL文は非常にシンプルであるのに対し、実際に実行されるSQL文は非常に複雑なものになってしまいます。そのため、想像以上に負荷の高い処理をDBMSに課すことになることもあるので注意が必要です。
- **ビューのデメリット**
    
    実行されるSQL文は、一見するよりも負荷の高い処理になる可能性がある。

### 11.2.3 採番の方法
あるテーブルに行を追加する場合、主キーの値を何にすべきか迷うことがあります。主キーである以上、既に使われている値と重複することは許されませんので、連番を振るという方法がよく用いられます。追加する行に独自の番号を振るために、適切な番号を取得することを**採番**ともいいます。

例えば、次ページ図11-5の費目テーブルの場合、主キーであるIDには連番を利用しています。しかし、この「連番を振る」ということは思いのほか面倒な作業です。行を追加する際には必ず「次にどの番号を使うべきか」と決める必要があり、「最後に使った番号は何番か？」を調べなければなりません。したがって、「最後に使った番号」をどこかに記録しておく必要があります。

実際の開発現場では、既に採番した番号や最後に採番した番号を、専用のテーブルに記録しておくなどの手法がよく使われます。この記録用のテーブルは**採番テーブル**と呼ばれ、工夫次第では記号や数字が混じった独自の番号も重複することなく採番することが可能です。管理するのは少し大変ですが、すべてのDBMSにおいて共通に利用できる、最も汎用的な方法です。

もし、単純な連番で良い場合、一部のDBMSでは連番を管理する機能が提供されています。但し、DBMS製品によって具体的な利用方法が異なるため、今回は代表的な種類についてのみ紹介していきましょう。

- **(1)連番が自動的に振られる特殊な列を定義できる**
    
    SQL ServerやMySQLなどの場合、CREATE TABLE文で列を定義する際に「連番を振る列である」ことを指定するだけで、データが追加されるタイミングで自動的に連番が振られるようになります。
    
    それぞれのDBMSにおいて列定義に指定すべき属性は、表のとおりです。

|  | SQL Server | MySQL | MariaDB | PostgreSQL | SQLite |
| --- | --- | --- | --- | --- | --- |
| 宣言に修飾 | IDENTITY | AUTO_INCREMENT | AUTO_INCREMENT | なし | IDENTITY   AUTOINCREMENT |
| 独自型を利用 | なし | SERIAL型 | SERIAL型 | SERIAL型 | SERIAL型 |

- リスト11-9 各DBMSにおける連番の指定

```sql
/* SQL Server の場合 */
CREATE TABLE 費目 (
  ID INTEGER IDENTITY PRIMARY KEY,
  名前 VARCHAR(40)
)

/* MySQL、MariaDBの場合*/
CREATE TABLE 費目 (
  ID INTEGER PRIMARY KEY AUTO_INCREMENT,
  名前 VARCHAR(40)
)

/* PostgreSQL の場合 */
CREATE TABLE 費目 (
  ID SERIAL PRIMARY KEY,
  名前 VARCHAR(40)
)

/* SQLite（AUTOINCREMENT利用）の場合 */
CREATE TABLE 費目 (
  ID INTEGER PRIMARY KEY AUTOINCREMENT,
  名前 VARCHAR(40)
)
```

あとは、INSERT文を実行すれば、指定した列には自動的に連番が振られていきます。尚、INSERT文で、ID列に明示的な値を指定してしまわないように注意してください。

- **(2)連番を管理してくれる専用の道具が提供されている**
    
    Oracle DB、Db2、SQL Server、PostgreSQLでは、専用の道具として**シーケンス**(sequence_が利用できます。シーケンスは常に採番した最新の値を記憶しており、シーケンスに指示をすることで「現在の値(=最後に採番した値)」や「次の値(=次に採番すべき値)」を取り出すことができます。
    
    但し、シーケンスから値を取り出すと、その操作はすぐに確定し、トランザクションをロールバックしてもシーケンスの値は戻りません。これは、1つのシーケンスが複数のトランザクションから利用されることを考慮しているためです。
    
    シーケンスは、CREATE SEQUENCE文で作成し、DROP SEQUENCE文で削除することができます。
    
- **シーケンスの作成と削除**
    
    ```sql
    CREATE SEQUENCE シーケンス名
    
    DROP EQUENCE シーケンス名
    ```
    
    シーケンスから値を取り出す方法はDBMS製品によって大きく異なります(各リストは省略)。
    
- (3)その他の方法
    
    DBMSによっては、独自の採番機構を提供しているものもあります。例えばSQLiteの場合、INTEGER型かつ主キー制約がついた列にNULLを意図的に格納することで、自動的に連番を生成し、その列に格納してくれます。</details>


<details><summary>11.3 データベースをより安全に使う</summary>

### - 11.3.1 信頼性のために備えるべき4つの特性
    
    第9章や第10章でも、DBMSに備わる様々な安全のための仕組みについて学んできました。あらためて振り返ると、**データベースによって「データを正確かつ安全に管理すること」がいかに大切か**がわかります。
    
    - **これまでに学んだ安全機構**
        - **コミットやロールバック**
            
            →途中で処理が中断しても、データが中途半端な状態にならない。
            
        - **型や制約**
            
            →あらかじめ指定した種類や条件に従った値だけを格納する。
            
        - **分離レベルやロック**
            
            →同時に実行している他の人の処理から副作用を受けない。
            
    
    ITの世界では、「データを正確かつ安全に取り扱うためにシステムが備えるべき4つの特性」として、**ACID特性**というものが広く知られています。これまで学んだ上記の3つの安全機構は、それぞれ、このACID特性の中の原子性、慣性、分離性の3つをカバーするためのものです。
    
    - **ACID特性**
        1. **原子性(Atomicity)**：処理が中断しても中途半端な状態にならない。
        2. **一貫性(Consistency)**：データの内容が矛盾した状態にならない。
        3. **分離性(Isolation)**：複数の処理を同時実行しても副作用がない。
        4. **永続性(Durability)**：記録した情報は消滅せず保持され続ける。
    
    データベースに格納されたデータは、勝手に消えたり壊れたりすることがあってはなりません。情報はメモリなどの一時的な保存領域ではなく**ハードディスクなどの磁気記憶媒体に記録**されます。しかし、ある日突然データを読み書きできなくなってしまう可能性もゼロではありません。情報の永続性を確保するための仕組みがDBMSには備わっているのです。

### 11.3.2 バックアップの仕組み
多くのDBMSは、万が一のデータ消失に備えて**バックアップ**(backup)の仕組みを備えています。それは、**データベースの全内容(テーブル構成や格納されたデータなど)をファイルに出力することができる**、というものです。具体的に使われるツールやコマンドはDBMS製品ごとに異なりますが、通常の業務システムの場合、**バックアップは毎日や毎週などの定期的な間隔で自動的に行われるように設定**されます。

出力されたバックアップファイルは、データベースから独立した別の記憶媒体(磁気記憶装置やテープ装置など)にコピーし、大切に保管しなければなりません。**万が一にも失われることが許されない極めて重要なデータの場合、地震などで建物ごと破壊されることも想定**し、**災害復旧対策**(DR:Disaster Recovery)の一環としてバックアップ媒体をいくつかの遠隔地に輸送して保管することもあります。

**※「もしも」を何重にも想定しておく対策が必要。**

### 11.3.3 バックアップの整合性
もし、INSERTやCREATE TABLEなどでデータベースの内容を書き換えている間にバックアップが行われると、作成したバックアップファイルは中途半端な状態となり、バックアップデータとして整合性がとれなくなる恐れがありあます。

整合性を保ちつつバックアップを行う最も簡単な方法は、データベースを停止してからバックアップを行う**オフラインバックアップ**です。

しかし、オフラインバックアップ中は一切のデータ処理が行えなくなります。データベースのバックアップには、データ量によって短くても数分、長いと数時間掛かることもあります。この間、データベースやそれを使ったシステムが停止してしまうことは状況によっては許されないかもしれません。

そのため、多くのDBMSは、稼働しながら整合性のあるバックアップデータを取得できる**オンラインバックアップ**機能も備えています。この機能は便利な反面、制約を伴うこともあるので、製品マニュアルをよく確認して利用してください。

- **2つのバックアップ方式**
    - オフラインバックアップ：DBMSを停止して行うバックアップ
    - オンラインバックアップ：DBMSを稼働させながら行うバックアップ

### 
