# 第12章 テーブルの設計
データ操作やテーブルの作成など、さまざまなSQL文を記述できるようになりました。

しかし、「家計を管理したい」というような具体的な要件を満たすには、どのような構造のテーブルをどのくらい作ればよいのか、頭を悩ませてしまうのではないでしょうか。

この最終章では、要件に応じて適切なテーブル設計を行う手順と方法を学び、SQLとデータベース入門の学習を締めくくりましょう。

<details><summary>12.1 システムとデータベース</summary>

### 12.1.1 システム化と要件
現代の社会生活の至る所で、情報システムは欠かせない存在になっています。システム化によって、かつては人力で行っていた処理をプログラムが行うようになり、紙の帳簿などに記録していたものはコンピュータ上のデータベースに保存するようになりました。

しかし、昔と現代で「まったく変わっていないもの」があります。それは、「お金の入出金を管理したい」という両替商(銀行)の要件(requirements)です。現代社会では、要件の実現手段が「人と紙」から「ATMプログラムとデータベース」に置き換わったにすぎません。

いざ、家計管理データベースを作ろうとしたものの、すぐに壁にぶつかってしまいます。「具体的になにをしたらいいのかわからない」。この段階でデータベースをうまく作れない理由は2つあります。
- **理由1 家計管理の要件を知らない**
    - そもそもどのような家計管理をしたいのか、現在どのように管理しているのかをよく知りません。家計に関するどんな情報を管理すれば要件を満たせるかがわからないため、当然「どのようなテーブルを作ればよいか」も決めることができません。
        
        **先ずは、「データベースを使ってどんな家計管理をしたいか」という要件をしっかり聞き出さなければなりません**。
        
- **理由2 要件をテーブル設計に落とし込む方法を知らない**
    - 要件を聞き出せたとして、その内容は「毎月の入出金の合計を一覧で見られるようにしたい」「システムは夫妻2人で使えるようにしたい」のような曖昧なものでしょう。つまり、要件をただ聞いただけでは「具体的にどんなテーブルを作ればよいか」までは明らかにならないのです。
        
        もちろん要件を意識しながらなんとなくテーブルを作ってみるという方法も考えられますが、しっかりとした根拠のないまま経験や感、度胸で作ったデータベースが、速くて、便利で、安全である確率は極めて低いでしょう。
        
        **聞き出した要件を優れたテーブル設計に確実に変換できる手法や手順を学ばなければならないのです**。
- **データベースを用いたシステムを開発するには**
    
    SQLやDBMSの機能に関する知識だけでは、データベースを用いたシステムは開発できない。要件をしっかりと理解し、その要件をデータベース設計に適切に落とし込むための方法論を活用しなければならない。

### 12.1.2 データベース設計の流れ
システム開発の一環としてデータベースを作ろうとする場合、私たちは何をすればよいのでしょうか。それを明らかにするには、先ず私たちが使える材料(INPUT)と、作るべきもの(OUTPUT)を明確にすることが大切です。

**お客様の用件を訊き**→INPUT→**データベース設計作業**→OUTPUT→**必要なテーブルを持つデータベース**

最初に行うことは用件聴取(インタビュー)です。お客様から用件を聞き出すことは、私たちエンジニアにとって非常に大切な作業です。
インタビューした要件は、後からでも確認しやすいように一覧表にまとめるとよいでしょう。これを材料として、最終的には、必要十分なテーブルを内部に持つデータベースを作ります。
各テーブルは、CREATE TABLE文やCREATE INDEX文などの複数のDDL文を実行すれば作ることができますので、成果物はDDL文と考えてもよいでしょう。
- **データベース構築のINPUTとOUTPUT**
    
    INPUT：要件の一覧表(お客様から聴取したもの)
    
    OUTPUT：一連のDDL文(実行すれば必要十分なテーブルが生成されるもの)
問題は、どのような手順でどのような作業をすれば、このINPUTからOUTPUTを生み出せるかです。これまでもたくさんの先人がさまざまな方法を試してきましたが、その多くに共通するのが次ページ図12-4のような流れです。

先ずは概要をイメージしておきましょう。
- **概念設計**
    - 管理すべき情報はどのようなものなのかを整理します。データベースやシステムに関することは考えず、要件に登場する情報だけをざっくりと把握します。例えば、家計管理データベースであれば、扱うべき情報として「利用者情報」や「入出金情報」などがあることを明確にします。また、情報間で関連がある場合、どのような関係があるかも合わせて整理します。
- **論理設計**
    - 概念設計で明らかになった各情報について、RDBを使う前提で構造を整理し、詳しく具体化していきます。論理設計では「どのようなテーブルを作り、それぞれのテーブルにどのような列を作るか」まで明らかにすれば十分です。型や制約など、付随的な部分については考えません。
- **物理設計**
    - 特定のDBMS製品(例えばOracle DB)をつ使う前提に立ち、論理設計で明らかになった各テーブルについて、その内容を詳しく具体化していきます。全てのテーブルの全ての列について、型、インデックス、制約、デフォルト値など、テーブル作成に必要な全ての要素を確定させます。この物理設計に基づいて、CREATE TABLE文などを含む一連のDDL文を作成し、最終的にデータベース内にテーブルを作成することができます。</details>

<details><summary>12.2 家計管理データベースの要件</summary>

### 12.2.1 立花いずみの要件
お客様にインタビューして、次のような案件を聞き出すことができました。

- 立花いずみの案件
    - 毎日のお金の出入りを記録したい(家計簿の高機能版)。
    - 利用者は家族全員で、それぞれ自分の入出金の行為を記録できるようにしたい。また、現在の家族は2人だが、将来増える可能性も考慮したい。
    - 費目の種類は後から追加できるようにしたい。
    - 費目によって「入金」か「出金」のいずれかが決まっている。
    - 1回の行為で、複数の入出金が発生する場合についても、その明細(費目と入出金の金額)をきちんと分けて記録したい。
    - 例えば、「大家さんに家賃を振り込んだ」場合、次のように記録したい。

| 行為の日付 | 行為の内容 | 費目 | 入出金額 |
| --- | --- | --- | --- |
| 2018-04-10 | 家賃を振り込んだ | 住居日 | 70,000 |
|  |  | 振込手数料 | 525 |

- 1回の行為の中に、同じ費目の明細を複数作ることは許さない。例えば、「住居費」の明細を2つ含む行為は記録できない。
- 将来的にはさまざまな集計をしたいけど、今はいらない。
- 入力時には入力ミスを防ぐ仕組みが欲しい。

### 12.2.2 立花コウジの要件
立花いずみの夫である立花コウジさんから次のような要件をお願いされたようです。
- 「利用者別の費目ごとの合計金額」を集計して、例えば次のように表示したい。

| 利用者名 | 費目名 | 合計金額 |
| --- | --- | --- |
| 立花いずみ | 給与 | 871,900 |
| 立花いずみ | 住居費 | 238,800 |
| 立花コウジ | 給与 | 921,900 |
| 立花コウジ | 住居費 | 238,800 |

- できれば、入出金行為に色々なタグを付けたい。タグの内容は「いいね！」「ムダ遣い！」「反省中」などで、後から追加できるようにしたい。また、タグは、どの利用者が付けたものかをわかるようにし、自分の入出金行為にも、自分以外の入出金行為にも付けることができるようにしたい。
要件を抱えているお客様が複数いる場合は特に注意が必要です。別の相手にインタビューをすると新たな用件が出てきて、概念設計の結果が変わってしまう可能性があるからです。特に他の要件と矛盾する用件が出てきた場合は、お客様同士で話し合い、どのようにするのかを決定してもらわなければなりません。

### 12.2.3 既存の家計管理ノート
夫妻が現在記録している家計管理ノートを材料として仕入れてきました。既に紙などを使って情報を管理している場合、それを入手しておくとテーブル設計の補助資料として活用することができます。</details>


<details><summary>12.3 概念設計</summary>

### 12.3.1 概念設計ですること
先ずは概念設計の流れを確認しておきましょう。

概念設計では、要件を実現するために、抽象的な概念としてどのような「情報の塊」を管理しなければならないかを明らかにします。

この情報の塊のことを**エンティティ**(entity)といい、通常エンティティは複数の**属性**(attribute)を持っています。さらに、エンティティ同士にどのような関連があるかも、この概念設計で明らかにします。

概念的な存在であるエンティティは、初心者にはなかなかイメージしにくいものです。慣れるまでは、これまで慣れ親しんだ「テーブル」のようなものだと考えてもよいでしょう。実際、エンティティはこの後の論理設計や物理設計を経てテーブルになりますので、いわば「テーブルの原石」のようなものなのです。
- **概念的なもののイメージを掴むためのヒント**
    - エンティティ：「テーブル」のようなもの。
    - 属性：テーブルの「列」のようなもの。
    - 関連：「リレーションシップ」のようなもの。
例えば、書店の在庫管理を概念モデルで表す場合、書籍情報や在庫情報がエンティティとして考えられます。書籍エンティティは、書籍のタイトルや価格という属性を持っています。また、在庫情報には「どの書籍が何冊あるか」という情報が含まれるため、書籍エンティティと在庫エンティティには関連があるといえます。

**※書店で「書籍」の在庫を管理するように、家計簿では「お金を使った事実」を管理する。だから、家計簿では「入出金行為」がエンティティになる。**

**※書籍のように形のあるものだけでなく、事実や行為のような形のないものもエンティティになる。**

### 12.3.2 ER図
概念設計の成果は、**ER図**(ERD:entity-relation diagram)という図にまとめることが一般的です。ER図を使うことで、エンティティ、属性、リレーションシップと俯瞰して見ることができます。

ER図には、2つの記述形式があります。図12-7は、ジェームズ・マーチンという人が考案したIE(Information Engineering)という形式に基づくER図です。本書では以降IE形式によるER図を紹介していきますが、アメリカ空軍が開発したIDEF1Xという形式も広く使われています。正式な仕様や各種の解説がWebサイト([http://www.idef.com/idef1x-data-modeling-method/](http://www.idef.com/idef1x-data-modeling-method/))で入手可能ですので興味がある方は調べてみてください。

### 12.3.3 ER図の記述ルール
ER図に登場する四角形はエンティティを表しています。四角形の上にはエンティティの名前が、四角形の中には属性の一覧が記述されます。図12-7では「利用者」や「入出金行為」などのエンティティがそれぞれ四角形で表されています。

属性の一覧は2つのグループに分けられます(図12-8)。四角形の中の線より上には、エンティティを一意に特定する主キーとなる属性を記述します。複数の属性で複合主キーを構成する場合、線より上に複数の属性が記述されます。

また、複数のエンティティ間にリレーションシップがある場合には、エンティティ同士を線で繋ぎ、外部キーとなる属性には「(FK)」と付記します。

エンティティ同士の数量的な関係を**多重度**や**カーディナリティ**といいます。例えば、家計管理の場合は1人の「利用者」が複数の「入出金行為」をする可能性がありますので、「利用者」と「入出金行為」の2つのエンティティは「1対多」の多重度があるといえます。

この多重度をER図中に記述する場合、図12-9のように表します。

このルールを念頭に、再度、図12-7の全体を眺めてみましょう。特に次の点を確認してください。
- **家計管理に関するER図のチェックポイント ※図12-7を見ながら確認すること。**
    1. 夫妻が考える家計管理には、5つのエンティティが登場する。
    2. 1人の「利用者」が、複数の「入出金行為」を行う(但し、利用者が1件も「入出金行為」を行なっていない状況もあり得るので多重度は0以上となる)。(例)『立花いずみ』が、『家賃の振込』と『スーパーで買い物』を行う。
    3. 1つの「入出金行為」には、1つ以上の「入出金明細」が含まれる(「入出金行為」には必ず1件以上の「入出金明細」があるはずなので多重度は1以上)。(例)『家賃の振込』には、『家賃の支払い』と『振込手数料の支払い』が含まれる。
    4. 1つの「費目」が、複数(0件以上)の「入出金明細」に付けられる。(例)『家賃の支払い』を行なった明細には、『住居費』費目が割り当てられる。
    5. ある1つの「タグ」が複数の「入出金行為」に付けられること(多重度0以上)があると同時に、1つの「入出金行為」に複数の「タグ」が付けられること(多重度0以上)もある。(例)『ありがとう！』タグが、『家賃の振り込み』と『スーパーで買い物』に付けられる。また、『外食の立て替え』には、『ありがとう！』と『反省中』タグが付けられる。

### 12.3.4 エンティティを導き出す方法
要件を聞いて、「どのようなエンティティが必要か」を導き出すことは、非常に高度な作業です。曖昧な要件に基づいてデータベースの利用イメージを頭の中に広げ、そこの登場する情報を見つけ出さなければならないからです。そこで、要件からエンティティを導き出すヒントを紹介します。
- **[ステップ1] 候補となる用語を洗い出す**
    - 要件(12.2節)の中から「名詞」を抜き出す。
    - 要件(12.2節)が実現されている姿を仮定して、そこに登場する「人」「物」「事実」「行為」などの用語を書き出す。
- **[ステップ2] 不要な用語を捨てる**
    - 他の用語の具体例でしかないものを捨てる。(例)「利用者」がすでにあれば、「いずみ」は捨ててよい。
    - 計算や集計をすれば算出可能な値は捨てる。
- **[ステップ3] 関連がありそうなものをまとめる**
    - 同じ用語に関連するものを集める。(例)「日付」「利用者」「内容」はいずれも「入出金行為」に関連する。何故なら「入出金行為をした日付」や「入出金行為の内容」だから。
- **[ステップ4] エンティティ名と属性名に分ける**
    - ステップ3でまとめたグループの中で「〜の〜」という日本語が成り立つ場合、前者がエンティティ名に、後者がその属性名になる。(例)「入出金行為」はエンティティ名に、「日付」はその属性になる。

しかし、ここに挙げたヒントを使っても、概念設計はかなり曖昧で難しいと感じるはずです。**たくさんのデータベース設計を行なったり、他の人が行った設計の結果を見たりすることを繰り返すうちに、自然と頭の中にエンティティが浮かぶようになる**でしょう。データベースを学び始めたばかりの私たちは、**とりあえず概念設計の目的と流れを把握することに専念し、あとは自由に繰り返し、要件からエンティティを引き出すことにチャレンジして**見るとよいでしょう。

**※「何が正解か？」にあまりこだわらず、概念設計をしてみて先輩方から意見をもらうのもよい。**

但し、1つだけ注意点があります。概念設計をいろいろ行っていると、エンティティの中に他のエンティティを登場させたくなることがあります。例えば、今回の場合、「1回の入出金行為の中に、入出金の明細がいくつか入るはずだよなぁ……」などと頭の中にイメージを広げたくなるかもしれません(図12-10)。

しかしER図ではエンティティの中にエンティティを作ること(二重構造)はできません。このような場合、「入出金明細」は別のエンティティとして、外部に取り出すようにしましょう(図12-10右側)。

このとき、外部に取り出したエンティティは、元のエンティティと関連があるはずです。元のエンティティと関連付けられるように、取り出したエンティティに元のエンティティの主キーを属性として追加しておきます。今回の例では、入出金行為エンティティの「入出金行為ID」を追加しました。

**※二重構造になってしまいそうなエンティティは、分割する。**</details>


<details><summary>12.4 論理設計</summary>

### 12.4.1 論理設計ですること
概念設計で作成したER図は、概念の世界における理想的なエンティティ構造を表しているに過ぎないため、このままの姿でデータベースに格納できるとは限りません。そこで、利用する予定のデータベースが扱いやすい構造にエンティティを変形する作業が論理設計です。

私たちが学習しているRDBは、「関連性のある複数の二次元表」として情報を扱う**リレーショナルデータモデル**(relational data model)でデータを管理します。このデータモデルでは、図12-10左側にあるような「二重構造のテーブル」を格納することができません。

- **論理設計の目的**
    
    概念上のエンティティをリレーショナルデータモデルで取り扱いやすい形のテーブルに変形する。

### 12.4.2 「多対多」の分解
図12-7のER図によると、「タグ」と「入出金行為」は「多対多」の関係をうまく扱うことができません。そこで、2つのエンティティの対応を格納した中間テーブルを追加することによって、「多対多」を2つの「1対多」の関係に変換します。

### 12.4.3 キーの整理
ここで、出揃った全てのエンティティのキーについて整理と確認をします。特に重要なのは、主キーです。種キーを持たないエンティティには、管理をしやすくするために人工的な主キー(人工キー)を追加します。例えば、「入出金行為」エンティティには、概念設計の段階ですでに「入出金行為ID」という人工キーを追加しています。

そのほか、不適切な主キーを持つエンティティがないか確認しておきましょう。

利用者エンティティの主キーは「利用者名」属性でよいようにも思えますが、次に挙げる「主キーが備えるべき3つの特性」に合致しません。

- **主キーが備えるべき3つの特性**
    - 非NULL性：必ず何らかの値を持っている。
    - 一意性：他と重複しない。
    - 不変性：一度決定されたら値が変化することがない(主キーは、一貫して同じ行を指し示す)。
名前を持たない家族はいませんし(非NULL性を備える)、

一部の例外を除いて日本の法律では同一戸籍内に同姓同名は許されません(ほぼ一意性を備える)。

その一方で、法律には「名前は正当な自由があれば変更できる」とも定められています。つまり、名前という情報は不変性を備えない情報なのです。

やはり利用者テーブルについても、「利用者ID」のような人工キーを追加してあげるとよいでしょう。

**※それに、将来「登録する名前を本名からニックネームに変更したい」場合もあるかもしれない。**

### 12.4.4 正規化
論理設計における最も中心的な作業は、正規化(normalization)の作業です。**正規化**とは、矛盾したデータを格納できなよう、テーブルを複数に分割していく作業です。第8章で行ったテーブル分割も正規化です。

テーブルを分割しないことによる致命的な問題は次の2点です。

- **テーブルを分割しない場合の懸念**
    - 内容に重複が多く、わかりにくい(p243の例2)。
    - データ更新時には複数の関連箇所を正確に更新しなければならず、更新を忘れたり間違えたりすると、データの整合性が損なわれる(p243の例3)。

人間は忘れたり間違えたりする生き物です。複数の箇所に対して100％の正確さで更新するということは期待すべきではありません。**同じ情報が複数の関連箇所にわたって格納されている限り、ある日、その一部の更新を忘れ、データの整合性が失われてしまうと考えるべき**なのです。

整合性が崩れにくい優れたテーブル設計の原則は、「**1つの事実は1箇所に**(one-fact in one-place)」です。私たちは正規化という手法を用いて正しくテーブルを分割することにより、ヒューマンエラーを防止し、この原則に則ったテーブル構造を手に入れることができるのです。</details>


<details><summary>12.5 正規化の手順</summary>

### 12.5.1 正規化の段階
正規化のよってテーブルが適切に分割された状態を正規形(normalized form)といいます。どの程度正規化されているかによって、正規形は第1正規形から第5正規形まで存在します。但し、通常のシステム開発が目的の場合は、業務で求められる第3正規形まで理解していれば問題ないでしょう。

もし、概念設計の結果得られたテーブルが第1正規形であれば、それを第2正規形に変形し、さらに第3正規形に変形するという手順を踏みます。

- **正規化の流れ**
    
    手元にあるエンティティ構造(テーブル構造)を、非正規形から第3正規形まで順次変形していく。
    
**※慣れれば機械的に行える作業なので、これも練習あるのみ。**

### 12.5.2 非正規形
もしあるテーブルが図12-16のような特徴を持つなら、非正規形といえます。

- 「セルの結合」を行っている。
- 1つのセルに複数行書いている。

しっかりと概念設計を行なった場合、その結果が非正規形になっている可能性はほとんどありません。何故なら、非正規形の構造は通常のER図では表現できないからです(図12-10の左側の段階が非正規形です。これを同じ図の右側に変形した時点で、非正規形から卒業しています)。

非正規形となる可能性が高まるのは、「現実のノート、帳票(帳簿や伝票などの総称)、画面などからテーブル設計を持ち込んだ」ケースです。

図12-17には「セルの結合」が含まれています。別の見方をすると、「1つの日付や内容に対して、**複数の費目ID**、**費目名**、**金額が繰り返し登場している**」ともいえます。このことから、「非正規形は**繰り返しの列**を含む」ともよく表現されます。

### 12.5.3 第1正規形への変形
先ず、非正規形のテーブルを第1正規形に変形しなければなりません。第1正規形とは、次のような条件を満たす形をいいます。

- **第1正規形の目指す姿と達成条件**
    
    テーブルの全ての行の全ての列に1つずつ値が入っているべきである。よって、「繰り返しの列」や「セルの結合」が現れてはならない。
    

非正規形を第1正規形に変形するには、次の3ステップの手順を実施します。図12-18と併せて読み進めてください。

- **[ステップ1] 繰り返しの列の部分を別の表に切り出す。**
    - 元のテーブルから「繰り返しの列」の部分を別テーブルとして切り出し、切り出したテーブルに名前をつけます。今回の場合は、繰り返されている「費目ID」「費目名」「金額」の列を切り出し、入出金明細テーブルとしました。
- **[ステップ2] 切り出したテーブルの仮の主キーを決める。**
    - 入出金明細テーブルの主キーとなる列を決めます。ステップ1で切り出した入出金明細テーブルには、「費目ID」「費目名」「金額」の3つの列がありますが、1つの入出金行為で同じ費目が複数使われることはないという要件がありましたので、「費目ID」を仮の主キーと定めます。
- **[ステップ3] 主キー列をコピーして複合主キーを構成する。**
    - 元のテーブルの主キー列を、切り出したテーブルにも加え、ステップ2の仮の主キーと合わせて複合種キーを構成します。今回の場合は、入出金明細テーブルに「入出金行為ID」列を追加し、「費目ID」と併せて複合主キーを構成します。

### 12.5.4 関数従属性
関連従属性(functional dependency)は列と列との間にある次のような関係性を示す用語です。
- **関数従属性**
    
    「ある列Aの値が決まれば、自ずと列Bの値も決まる」という関係。このとき、「列Bは列Aに関数従属している」という。

例えば、図12-18の入出金行為テーブルを見てみましょう。入出金行為IDがわかれば、何月何日の入出金であるか(「日付」列の内容)が確定できます。よって、「日付」は「入出金行為ID」に関数従属しているといえます。

他にも、「費目ID」と「費目名」、「利用者ID」と「利用者名」など、至る所に関数従属性を見つけることがでます。

そもそも主キーとは、**「その値を決めると、どの行であるか(各列の内容が何であるか)を完全に特定できる」という列**でした。つまり、そもそもテーブルに含まれる主キー以外の列(非キー列)は、主キー列に対して関数従属しているべきなのです。
- **テーブルにおける理想的な関数従属**
    
    すべての非キー列は、主キーに綺麗に関数従属しているべきである。

ここでのポイントは、「主キーに綺麗に関数従属している」ことです。実は、テーブルの列が何らかの理由で「主キーに汚く関数従属してしまう」ことがあります。これを排除することこそ、第2正規形の目的なのです。

### 12.5.5 第2正規形への変形
第2正規形への変形は、主キーに対する「汚い関数従属」の排除が目的であることはすでに述べました。どんな関数従属が「汚い」のか、注目してください。
- **第2正規形の目指す姿と達成条件**
    
    複合主キーを持つテーブルの場合、非キー列は、複合主キーの全体に関数従属すべきである。よって、「複合主キーの一部の列に対してのみ関数従属する列」が含まれてはならない。

第2正規形では、全ての非キー列が「複合主キーの全体」に関数従属することを求めています(これを本書では「綺麗に」と表現します)。複合主キーの一部の列にしか関数従属しないことが、「汚い関数従属」というわけです。専門用語では、この状態を**部分関数従属**といいます(図12-19)。

尚、複合主キーを持たないテーブルは「汚い関数従属」が含まれようがないので考慮不要(既に第2正規形になっている)といえます。あらためて図12-18の入出金明細テーブルを見てみると、テーブルに含まれる「費目ID」と「費目名」の2つの列は、部分関数従属になってしまっています。

- 費目名は費目IDに関数従属している。
- 入出金行為IDと費目IDは複合主キーを構成している。

この部分関数従属を排除し、第2正規形に変形するには、次の手順を実施します。

- **[ステップ1] 複合主キーの一部に関数従属する列を切り出す。**
    - 複合種キーの一部の列に関数従属している列を、別のテーブルとして切り出して名前を付けます。今回の場合は「費目名」を切り出し、費目テーブルとします。
- **[ステップ2] 部分関数従属先だった列をコピーする。**
    - 切り出した列が関数従属していた列を、ステップ1で作ったテーブルにコピーして主キーとします。今回の場合は、切り出した費目テーブルに「費目ID」列を追加して主キーとします。

### 12.5.6 第3正規形への変形
最後に目指すのは第3正規形です。目的を確認します。
- **第3正規形の目指す姿と達成条件**
    
    テーブルの非キー列は、主キーに直接、関数従属すべきである。よって、「主キーに関数従属する列にさらに関数従属する列」は存在してはならない。
    

第1、第2と同じく、「汚い関数従属を排除しよう」という考えに変わりはありませんが、排除しようとしているものが異なります。今回は、「主キーに対する間接的な関数従属」を汚い関数従属とみなし、それを排除しようとしています。間接的に関数従属することを、専門用語では**推移関数従属**と言います(図12-21)。

今回の例では、入出金行為テーブルの「利用者名」列が問題です。この列が関数従属する「利用者ID」はさらに主キーである「入出金行為ID」に関数従属しているので、「利用者名」は推移関数従属しているといえるでしょう。

次のような手順を踏んで、推移関数従属を排除しましょう(図12-22)。

- **[ステップ1] 間接的に主キーに関数従属する列を切り出す。**
    - 間接的に主キーに関数従属している列を、別のテーブルとして切り出して名前を付けます。今回の場合は「利用者名」を切り出し、利用者テーブルとします。
- **[ステップ2] 直接関数従属先だった列をコピーする。**
    - 切り出した列が関数従属していた列を、切り出したテーブルにコピーして主キーとします。今回の場合は、「利用者名」列が関数従属していた列は「利用者ID」列ですから、利用者テーブルに「利用者ID」列を追加して主キーとします。

この時点でのテーブル構造をER図にまとめたのが図12-23です。

### 12.5.7 正規化を覚えるコツ
