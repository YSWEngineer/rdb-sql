# 第3章 操作する行の絞り込み
SQLを用いて思いどおりにデータを操るには、「どの行を対象として、どのように操作するか」をDBMSに的確に伝えなければなりません。

特にWHERE句による対象行の指定は、SQL記述のキーポイントといえるでしょう。

この章では、WHERE句と絞り込み条件に関するさまざまな文法を学びます。

データベースにおけるより高度で複雑な処理が可能になり、SQLがいっそう楽しくなるでしょう。

<details><summary>3.1 WHERE句による絞り込み</summary>

### 3.1.1 WHERE句の大切さ
SQL文の中でWHEREを使うことで、処理対象となる行の絞り込みができます。WHEREキーワードから始まる一連の記述をWHERE句といいます。

SQLを学び始めて間もない頃は、WHERE句のことをSELECTやDELETEのちょっとした付属品のように思いがちです。

- SQLの言語としての特徴
    - 命令自体は単純で、数も少ない(主に使うものは4つ)。
    - しかし、さまざまな修飾語を付けることで、複雑な処理が可能になる。
    
    修飾語のうち最もよく使われるものが、WHERE句です。データを検索、更新、削除など多くの場合、WHERE句を用いて「テーブルのどの行を処理したいのか」を指定します。むしろ、WHERE句が伴わないSQL文を使うことの方が少ないでしょう。なぜなら、テーブル内のすべての行を更新したり削除したりする機会はあまりないからです。
    
    私たちはWHERE句を自由自在に使えてはじめて、データを自由自在に操作することができるのです。


### 3.1.2 WHERE句の基本
WHERE句に関して、3つの基本。
- WHERE句の基本
    1. 処理対象行の絞り込みに用いる→WHEREを指定しないと「すべての行」が処理対象になる。
    2. SELECT、UPDATE、DELETE分で使用可能→INSERT文では使用できない。
    3. WHEREの後ろには条件式を記述する→絞り込み条件に沿った「正しい条件式」を記述する。
    
    1と2については第2章で紹介しました。残る3については、WHERE句の基本構文をしっかり押さえることが大切です。
    
- WHERE句の基本構文
    
    ```sql
    WHERE 条件式
    ```
    
    ただし、WHEREの後ろにはどんな式でも書けるというわけではありません。たとえば、「出金額 < 10000」のような式を記述することができますが、「出金額 + 10000」のような計算式は書くことができません。WHEREの後ろに記述できるのは、条件式と呼ばれる式だけです。</details>


<details><summary>3.2 条件式</summary>

### 3.2.1 真と偽
条件式とは、その結果が必ず真(TRUE)か偽(FALSE)になる式のことです。私たちの日常生活における「YesとNo」のようなものと考えても差し支えありません。

たとえば、「出金額 < 10000」という式は、出金額という列に格納されている値が10000未満の場合は式の意味が正しいので真、10000以上の場合は式の意味が正しくないため偽と判定できます。

では、「出金額 + 10000」という式ではどうでしょうか。

出金額はふつう数字の値です。仮に5000だとすると、「出金額 + 10000」という式の結果も15000という数値になります。結果が数値や文字列、日付などになる式は、WHERE句に記述することはできません。

- WHERE句に書けるもの
    
    結果が必ず真(TRUE)または偽(FALSE)となる条件式


### 3.2.2 WHERE句のしくみ
DBMSがどのようにWHJERE句を処理するか、その仕組みを見てみましょう。

一円以上の出金のあった行をすべて削除するDELETE文

```sql
DELETE FROM 家計簿 WHERE 出金額 > 0
```

**1行ずつ順番に、条件に合うかどうかをチェックするために、「真か偽になる式」しか書いてはいけない。**

WHERE句を含むSQL文を受け取ったDBMSは、テーブル中のすべての行について条件式が真になるかをそれぞれ調べます。そして、真になった行についてのみ、SELECTやUPDATE、DELETEなどの処理を行うのです。</details>


<details><summary>3.3 さまざまな比較演算子</summary>

### 3.3.1 基本的な比較演算子
条件式は、「＝」(等号)や「<」(不等号)のような記号を含んだ式になることがほとんどです。これらの記号は比較演算子といい、その記号の左右にある値を比較して、記号の意味が正しければ真(TRUE)、正しくなければ偽(FALSE)に「化ける」役割を持っています。本書では、SQLの実行によって演算子などが別の値に変化することを「化ける」と表現することにします。

```sql
出金額(3000) > 0 # TRUE
出金額(3000) = 0 # FALSE
```

SQLで利用される比較演算子には他にもたくさんのしゅるいがあります。なかでも次に挙げる6つは最も基本的な比較演算子です。

### 3.3.2 NULLの判定
- NULLとは
    - そこに何も格納されていない、未定義であることを表す。
    - 数字のゼロや空白文字とも異なる。
    
    次の家計簿テーブルは金額がゼロだった箇所がNULLになっています。つまり、0という値すら入っていない空欄の状態になっていることを表しています。
    
    たとえば、入金額が「0」の場合と「NULL」の場合では、意味が異なります。
    
    - 入金額が「0」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金し、0円入金した。
        
    - 入金額が「NULL」の場合
        
        2月3日にコーヒー(食費)を購入。380円出金した。
        
    
    0という値が入金額として記入されているということは、「0円だけれども入金があった」という意味です。一方、NULLとは何もないこと、未定義であることを意味するのですから、入金が発生しなかった、または不明なことを表します。
    
    NULLかどうかを判定するには、=演算子や<>演算子は利用できません。たとえば「SELECT ＊ FROM 家計簿 WHERE 出金額 = NULL」という記述は、正しく判定されません。
    
    列の値がNULLであることを判定するためには`IS NULL 演算子`、NULLでないことを判定するためには`IS NOT NULL 演算子`を使います。
    
- NULLの判定
    - NULLであることを判定する。
    
    ```sql
    式 IS NULL
    ```
    
    - NULLでないことを判定する。
    
    ```sql
    式 IS NOT NULL
    ```
    
    正しいNULLの判定方法
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額　IS NULL
    ```
    
    NULLであるかの判定をすべきところに通常の比較演算子を使ってしまうという誤りは、SQLを学び始めて間もない頃によく犯してしまう代表的なミスです。はじめのうちは、意識して注意するようにしましょう。
    
- NULLは＝で判定できない！
    
    NULLは「＝」や「<>」では判定できない。必ずIS NULLやIS NOT NULLを使って条件式を作ること。
    
- 比較演算子の＝でNULLかどうかを判定してはいけない理由—3値論理
    
    ＝などの比較演算子ではNULLの判定ができない理由が気になるという人のために、少し踏み込んで仕組みを紹介しましょう。
    
    この章では、条件式の結果は常に真(TRUE)か偽(FALSE)になると説明しました。しかしSQLの条件式は、これら2つ以外にも、UNKNOWN(不明、計算不能)という3つ目の結果を持つ3値論理と呼ばれる仕組みを採用しています。このUNKNOWNについて、次の2つのことを理解すると、きっと謎が解けるでしょう。
    
    1. ＝や<>などの通常の比較演算子は、もともと値と値を比較するためのもの。よって、「値ではないNULL」を比較すると、不明な結果であるUNKNOWNになる。
    2. WHERE句による絞り込みは、条件式が真(TRUE)となる行だけが選ばれる。条件式が偽(FALSE)やUNKNOWNとなる行は処理対象にならない。


### 3.3.3 LIKE演算子
文字列があるパターンに合致しているかをチェックすることをパターンマッチングといいます。SQLではこのパターンマッチングにLIKE演算子を使います。パターンマッチングを行うと、部分一致の検索(〇〇○という文字列を一部に含むか？という判定)が簡単にできます。
- LIKE演算子によるパターンマッチング
    
    ```sql
    式 LIKE パターン文字列
    ```
    
    パターン文字列に使用できる文字には、主に次のようなものがあります。
    
    | パターン文字 | 意味 |
    | --- | --- |
    | % | 任意の0文字以上の文字列 |
    | _(アンダースコア) | 任意の1文字 |
    
    1月に関連する行を取得するSELECT文
    
    ```sql
    SELECT * FROM 家計簿
     WHERE メモ LIKE '%1月%' # 1月の前後に任意の0文字以上の文字列が付いてもよい
    ```
    
    結果表
    
    | 日付 | 費目 | メモ | 入金額 | 出金額 |
    | --- | --- | --- | --- | --- |
    | 2018-02-10 | 給料 | 1月の給料 | 280000 | 0 |
    | 2018-02-18 | 水道光熱費 | 1月の電気代 | 0 | 7560 |
    
    「％」は0文字以上の任意の文字列を意味する記号ですから、「**％1月％**」は1月の前後に0文字以上の文字が付いていてもよいこと、つまり1月という文字を含む文字列であることを意味します。
    
    同様に、「**％1月**」は、1月という文字で終わる文字列であることを意味し、「**1月_**」は「1月で始まり、その後ろに任意の1文字がある文字列」という意味になります。


### 3.3.4 BETWEEN 演算子
BETWEEN演算子は、ある範囲内に値が収まっているかを判定します。
- BETWEEN演算子による範囲判定
    
    ```sql
    式 BETWEEN 値1 AND 値2
    ```
    
- ％や_を含む文字列をLIKEで探したい
    
    「100％」という文字で終わるかを判定したい場合のように、％や_の文字そのものを含む文字列を部分一致検索したい時には、少し工夫が必要です。なぜなら、次のようにそのまま記述すると、％は特殊な意味の文字として扱われてしまうからです。
    
    ```sql
    /* 「100を含む文字列」という意味になる */
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100'
    ```
    
    パターン文字列の中で、単なる文字として％や_を使いたい場合、次のようにESCAPE句を併用した記述を行います。
    
    ```sql
    SELECT * FROM 家計簿 WHERE メモ LIKE '%100$%' ESCAPE '$'
    ```
    
    ESCAPE句で指定した文字(上の行では$)はエスケープ文字といい、パターン文字列において特殊な取り扱いがされるようになります。この例では、今回のエスケープ文字$に続く%や_は、ただの文字として扱われます。
    
    BETWEEN演算子では、値が「値1以上かつ値2以下」の場合に真になります。値がちょうど値1や値2の場合も真になる点に注意してください。
    
    たとえば、出金額の列が100以上3000以下の範囲になる行のみを検索するには、次のようなSQL文を記述します。
    
    100〜3,000円の出費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 出金額 BETWEEN 100 AND 3000
    ```
    
    ※次節に登場する論理演算子ANDでも同じ判定が可能。状況にもよるが、BETWEENのほうが処理性能が悪いことがあるから注意すること。


### 3.3.5 IN/NOT IN演算子
IN演算子は、値が括弧内に列挙した複数の値の(値リスト)のいずれかに合致するかを判定する演算子です。＝演算子では、1つの値との比較しかできませんが、IN演算子を使えば、一度にたくさんの値との比較が可能です。
- IN演算子による複数値との比較
    
    ```sql
    式 IN (値1, 値2, 値3...)
    ```
    
    食費・交通費を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 IN ('食費', '交際費') # 値リスト
    ```
    
    逆に、括弧内に列挙した値のどれとも合致しないことを判定するには、NOT IN演算子を使います。次のリストは、費目の列が「食費」でも「交通費」でもない行が抽出対象となります。
    
    食費でも交際費でもない行を取得するSELECT文
    
    ```sql
    SELECT *
      FROM 家計簿
     WHERE 費目 NOT IN ('食費', '交際費')
    ```


### 3.3.6 ANY/ALL演算子
IN演算子では、ある値が複数の値のどれかと等しいかを判定することができました。もし、複数の値と代償を比較したい場合には、ANY演算子やALL演算子を利用することができます。

ANYやALLは、必ずその直前に比較演算子をつけて利用します。これにより複数の値との比較を一度に行うことができます。

ただし、DBMSによっては、「副問い合わせ」でしか使えないことがあります。
- ANY/ALL演算子による複数値との比較
    - 値リストのそれぞれと比較して、いずれかが真なら真
    
    ```sql
    式 基本比較演算子 ANY (値1, 値2, 値3...)
    ```
    
    - 値リストのそれぞれと比較して、すべて真なら真
    
    ```sql
    式 基本比較演算子 ALL (値1, 値2, 値3...)
    ```
    
    ※基本比較演算子とは、「＝」「<」「<>」などの6つの演算子のこと
    
    - IN演算子の場合……出金額が値リストの中の**「どれか」**と**「一致」**するなら真。
        - 出金額(3000) IN (1000, 2000, 3000)
            - 出金額(3000)はINの右辺の3000と一致するので式の値は真
    - < ANY演算子の場合……出金額が値リストの中の**「どれか」**より**「小さい」**なら真。
        - 出金額(2500) < ANY (1000, 2000, 3000)
            - 出金額(2500)はANYの右辺の3000より小さいので式の値は真。
    - < ALL演算子の場合……出金額が値リストの中の**「すべて」**より**「小さい」**なら真。
        - 出金額(1000) < ALL (1000, 2000, 3000)
            - 出金額(1000)はANYの右辺の2000と3000より小さいが、1000より小さくないので式の値は偽。
    
    ANYやALLの例を冷静に見てみると、わざわざANYを使って「1000と2000と3000のどれかより小さい」という複雑な条件を書かなくても、はじめから「出金額 < 3000」と書けばよいのです。
    
    ANYやALLといった演算子は、単体で利用してもあまりメリットはなく、**「式」や「副問い合わせ」などの道具と組み合わせて初めて、その真価を発揮**します。**まずはANYやALLの構文と仕組みをしっかりマスター**しておいてください。</details>


<details><summary>3.4 複数の条件式を組み合わせる</summary>

### 3.4.1 論理演算子
WHERE句に条件式を使用することは前節で解説した通りです。しかし1つの条件式ではうまく行を絞り込めない場合、論理演算子を用いて、複数の条件式を組み合わせることができます。

代表的な論理演算子には、AND演算子とOR演算子があります。
- AND演算子とOR演算子
    - 2つの条件式の両方が真の場合だけ、真となる(AかつB)。
    
    ```sql
    条件式1 AND 条件式2
    ```
    
    - 2つの条件式のどちらかが真ならば、真となる(AまたはB)。
    
    ```sql
    条件式1 OR 条件式2
    ```
    
    2つの条件式を組み合わせたWHERE句
    
    ```sql
    UPDATE 湊くんの買い物リスト
       SET 価格 = 6200
     WHERE 名称 = 'スッキリ勇者クエスト'
       AND 販売店 = 'B'
    ```
    
    ANDとORは、両辺に条件式を必要とする演算子です。一方、右辺しか必要としないNOT演算子も存在します。NOTを記述すると、右辺の条件式の結果は、真は偽に、偽は真に逆転します。
    
- NOT演算子による真偽値の逆転
    
    ```sql
    NOT 条件式
    ```
    
    たとえば、「WHERE NOT 販売店 = ‘B’」という記述で、「販売店がB以外の行」を取り出すことができます。


### 3.4.2 論理演算子の優先度
論理演算子で条件式を組み合わせる際は、演算子が評価される優先順位に注意を払う必要があります。複数の論理演算子が使われている場合では、(1)NOT、(2)AND、(3)ORの優先順位に従って処理されていきます。

特に、ANDとORの優先順位については注意が必要です。

たとえば、「販売店AかBで売っている、ゲームかDVD」を検索したいために、以下の内容を実行すると、意図に反して2行目以外のすべての行が返されてしまします。

複数の論理演算子を使ったSELECT文

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B'     /* 条件式2 */
   AND カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD'   /* 条件式4 */

SELECT * FROM 湊くんの買い物リスト  WHERE 販売店 = 'A' OR 販売店 = 'B' AND カテゴリ = 'ゲーム' OR カテゴリ = 'DVD' 
```

これはORよりもANDの優先順位が高いため、DBMSがまず条件式2と3を先に評価し、その結果と条件式1と4をORで評価してしまったからです。

このような場合は、条件式に括弧をつけることでその評価の優先順位を引き上げることができます。

複数の論理演算子を使ったSELECT文(条件式に括弧を付ける)

```sql
SELECT * FROM 湊くんの買い物リスト
 WHERE ( 販売店 = 'A'     /* 条件式1 */
    OR 販売店 = 'B' )    /* 条件式2 */
   AND ( カテゴリ = 'ゲーム'  /* 条件式3 */
    OR カテゴリ = 'DVD' )  /* 条件式4 */
```

DBMSは、括弧で括られた条件式1と2、3と4をそれぞれORで処理し、最後にその結果をANDで評価します。これで目的通り、上の結果表のように「販売店AかBで売っているゲームかDVD」の行を得ることができます。

- 括弧による優先順位の引き上げ
    
    条件式を括弧で括ると、評価の優先順位が引き上がる。</detals>


<details><summary>3.5 主キーとその必要性</summary>

### 3.5.1 思いどおりに削除できない!?
| 日付 | 費目 | メモ | 入金額 | 出金額 |
| --- | --- | --- | --- | --- |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-03 | 食費 | チョコレートを購入 | 0 | 105 |
| 2018-03-06 | 教育娯楽費 | 月刊SQLを購入 | 0 | 1280 |
このテーブルの1行目だけを削除する方法を考えてみましょう。たとえば、「DELETE FROM 家計簿 WHERE 日付 = ‘2018-03-03’ AND 出金額 = 105」としても、1行目と2行目の両方が削除されてしまいます。

紙面では「上の行」「下の行」と記述できますが、データとしては1行目と2行目は全く同じものであり、区別する手段がありません。そして、行を区別できないということは、ある特定の行だけを指定して操作することができないことを意味します。

- 重複した行がもたらす問題
    
    完全に重複した行が存在すると、そのうちのある行だけを区別、識別することはできない。よって、ある行だけを操作することもできない。
    
    このような理由から、よほど特殊な状況を除いて、テーブルの中に重複した行が格納されるようなことは避けるべきとされています。今回の場合は、1日にまったく同じ内容の買い物を複数回するとどうしても重複した行を記録することになってしまうため、そもそもテーブルの構造自体に問題があるといえます。


### 3.5.2 特定の行を削除する方法
| 社員番号 | 年齢 | 性別 | 名前 |
| --- | --- | --- | --- |
| 2003031 | 45 | 1 | ヨシダ　シゲル |
| 2003032 | 45 | 1 | ヨシダ　シゲル |
| 2005011 | 31 | 1 | スガワラ　タクマ |
| 2012001 | 22 | 1 | ミナト　ユウスケ |
| 2012002 | 24 | 2 | アサカ　アユミ |
「ヨシダ　シゲル」さんという同姓同名で年齢も性別も同じ社員が2名在籍しています。しかし、次のようにして「上の行」のヨシダシゲルさんだけを削除することができます。

上のヨシダシゲルさんだけを削除する

```sql
DELETE FROM 社員
 WHERE 社員番号 = '2003031' /* 社員番号で対象行を特定 */
```

同姓同名にもかかわらず削除したい行を正しく識別することができたのはこのテーブルが「社員番号」という列を持っていたおかげです。加えて、この「社員番号」という情報が、次のような特殊な条件を満たすものであることも非常に重要です。

- 「社員番号」が備える特殊な性質
    - 社員番号を持たない社員は存在しない。
    - 同じ社員番号が、異なる社員に割り振られることはない。
    
    →「社員テーブルで行が重複することはあり得ない」
    
    社員テーブルにおける社員番号のように、「この値を指定することで、ある1行を完全に特定できる」という役割を担う列のことを、主キー(primary key)といいます。主キーとなる列は、次のような特性を持っています。
    
- 主キーとなる列が持つべき特性
    - 必ず何らかのデータが格納される(NULLではない)。
    - 他の行と値が重複しない。
    
    私たちがデータベースで情報を管理する場合、ある特定の行を削除したり更新したりすることは頻繁に発生します。従って、あらゆる行をいつでも自由にWHERE句で特定できるためにも、すべてのテーブルは主キーとなるような列を必ず持つべきなのです。
